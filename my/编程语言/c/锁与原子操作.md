# 锁与原子操作

```C
#ifndef XLOCK_HEADER
#define XLOCK_HEADER

#include <pthread.h>

/* 特殊说明: */
/* 原子操作和锁在代码中当成函数使用，所以这里特别使用了小写来定义宏，与编程*/
/* 规范不完全一致，但是可以更方便的写出风格一致的代码 */

/* 原子操作 使用 GCC 的 built-in 函数*/
/* 对于单变量尽量不用锁而使用原子操作,
 * 实际测试结果:原子操作的速度是线程锁的6～7倍*/
/* 能使用原子操作的变量只能是int,long,long long(及对应unsigned类型) */

#define atomic_read(ptr)                                      \
    (__sync_add_and_fetch(ptr, 0)) 

#define atomic_inc(ptr)                    \
    ((void)__sync_add_and_fetch(ptr, 1))

#define atomic_dec(ptr)                    \
    ((void)__sync_sub_and_fetch(ptr, 1)) 

#define atomic_add(ptr, val)               \
    ((void)__sync_add_and_fetch(ptr, val))

#define atomic_sub(ptr, val)               \
    (__sync_sub_and_fetch(ptr, val))

#define atomic_set(ptr, val)               \
    ((void)__sync_lock_test_and_set(ptr, val))

#define atomic_set_return_old(ptr, val)          \
    (__sync_lock_test_and_set(ptr, val))

#define atomic_set_zero(ptr)               \
    ((void)__sync_lock_release(ptr))

#define atomic_dec_and_test(ptr) (atomic_sub(ptr, 1) == 0)

#define atomic_inc_and_return(ptr)         \
    (__sync_add_and_fetch(ptr, 1))

#define atomic_test_and_set(ptr, oldval, newval)                     \                    
    (__sync_bool_compare_and_swap((ptr), (oldval), (newval)))

#define atomic_test_and_set_return_old(ptr, oldval, newval) \
    (__sync_val_compare_and_swap((ptr), (oldval), (newval)))

/* 读写锁,使用pthread的读写锁 */
typedef pthread_rwlock_t rwlock_t;
#define rwlock_init(lock) ((void)pthread_rwlock_init((lock), 0))
#define write_lock(lock) ((void)pthread_rwlock_wrlock((lock)))
#define read_lock(lock) ((void)pthread_rwlock_rdlock((lock)))
#define write_unlock(lock) ((void)pthread_rwlock_unlock((lock)))
#define read_unlock(lock) ((void)pthread_rwlock_unlock((lock)))
#define write_trylock(lock) (pthread_rwlock_trywrlock((lock)))
#define read_trylock(lock) (pthread_rwlock_tryrdlock((lock)))
#define rwlock_destroy(lock) ((void)pthread_rwlock_destroy((lock)))

/* 自旋锁,使用pthread的自旋锁 */
typedef pthread_spinlock_t spinlock_t;
#define spin_lock_init(lock) ((void)pthread_spin_init((lock), 0))
#define spin_lock(lock) ((void)pthread_spin_lock((lock)))
#define spin_unlock(lock) ((void)pthread_spin_unlock(lock))
#define spin_trylock(lock) ((void)pthread_spin_trylock((lock)))
#define spin_lock_destroy(lock) ((void)pthread_spin_destroy(lock))
/*互斥锁，使用pthread的互斥锁*/
typedef pthread_mutex_t mutex_t;
#define mutex_init(lock) (pthread_mutex_init((lock), 0))
#define mutex_lock(lock) ((void)pthread_mutex_lock((lock)))
#define mutex_unlock(lock) ((void)pthread_mutex_unlock(lock))
#define mutex_destroy(lock) ((void)pthread_mutex_destroy(lock))

typedef pthread_cond_t cond_t;
#define cond_init(cond) (pthread_cond_init((cond), 0))
#define cond_wait(cond, lock) (pthread_cond_wait((cond), (lock)))
#define cond_signal(cond) (pthread_cond_signal(cond))
#define cond_destroy(lock) ((void)pthread_cond_destroy(lock))

#endif /*__LIST_NODE_H__*/

```

