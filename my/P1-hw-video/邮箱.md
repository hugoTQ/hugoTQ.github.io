

[TOC]

目的

- 梳理
- 存在问题
- 如何优化

内容

1. 梳理邮箱使用
2. 邮箱与imedia交互

## 模块、结构体关系

![1555905404774](.\邮箱.assets\1555905404774.png)

## 结构体

- task_ccb

```c
// master_control.h
// task_ccb  FIXME：命名晦涩
typedef struct tagFPU_TSURM_CCB_STU{ 	
    MAILBOX_SHARE_MEMORY_PARAS_S  down_mailbox[22];
    MAILBOX_SHARE_MEMORY_PARAS_S  up_mailbox[22];
    int down_valid[22];
	int up_valid[22];
    int udwUpMailCount;
    int udwDownMailCount;
    int up_mailbox_output_type[22];
    int templet_index[22] ;    /*邮箱对应的模板中的第几个*/
} FPU_TSURM_CCB_STU

```

- start_split_req，start_trans_req，start_merge_req

```C
// data_proc.h  主控模块与媒体数据IO处理模块之间的C接口结构声明 //FIXME 命名不好
// 分片
typedef struct tagMC_DP_START_SPLIT_REQ_S {
    MAILBOX_SHARE_MEMORY_PARAS_S down_mail_box; // 视频输入
    int up_mailbox_num;
    MAILBOX_SHARE_MEMORY_PARAS_S vUp_mail_box;  // 视频输出 
    MAILBOX_SHARE_MEMORY_PARAS_S aUp_mail_box;  // 音频输出
    //MAILBOX_SHARE_MEMORY_PARAS_S tUp_mail_box;// 字幕输出
    int output_type; // 写死了TRANSCODE_OUTPUT_VIDEO_AUDIO   
} MC_DP_START_SPLIT_REQ_S

// 转码
typedef struct tagMC_DP_START_TRANS_REQ_S {
    UINT32 down_mailbox_num; /*下行邮箱个数*/ // TODO 目前没用
    MAILBOX_SHARE_MEMORY_PARAS_S down_mail_box[MAX_TRANS_DOWN_BOX];
    int down_valid[MAX_TRANS_DOWN_BOX];
    int up_mailbox_num;
    MAILBOX_SHARE_MEMORY_PARAS_S up_mail_box[CTE_MAX_MAIL_BOX_CNT];
    int up_valid[CTE_MAX_MAIL_BOX_CNT];
    int output_type[CTE_MAX_MAIL_BOX_CNT]; /* 音频、视频、音视 tagTRANSCODE_OUTPUT_TYPE */
} MC_DP_START_TRANS_REQ_S;

/*合并命令请求*/
typedef struct tagMC_DP_START_MERGE_REQ_S {
    int inputFileType[CTE_MAX_MAIL_BOX_CNT];// CTE_TRANS_INDEX_TYPE //TODO 由于合并阶段 ，mc和io的邮箱index不一致，需要引入此标记，应该优化合并阶段mc->io邮箱逻辑
    MAILBOX_SHARE_MEMORY_PARAS_S down_mail_box[CTE_MAX_MAIL_BOX_CNT];
    MAILBOX_SHARE_MEMORY_PARAS_S up_mail_box[CTE_MAX_MAIL_BOX_CNT];
    int output_type[CTE_MAX_MAIL_BOX_CNT];  /* 音频、视频、音视 tagTRANSCODE_OUTPUT_TYPE */
} MC_DP_START_MERGE_REQ_S;

```

- write_ccb

```c
//io_write.h
typedef struct io_write_thread_struct {
    UINT32 up_mailbox_num; /*上行邮箱的总个数*/
    MAILBOX_SHARE_MEMORY_PARAS_S up_mail_box[CTE_MAX_MAIL_BOX_CNT];
    INT32 up_valid[CTE_MAX_MAIL_BOX_CNT] ; // 1 VALID 0 INVALID
    UINT32 code_output_type[CTE_MAX_MAIL_BOX_CNT]; /*记录这个mailbox 是音视频还是音频
}iow_block；
```

- read_ccb

```c
// io_read.h
// TODO 注释命名看不出结构体干嘛的
typedef struct ST_TAG_TaskRd_READ {
    int split_num;    /* input */ //TODO 什么意思？？跟cur_split什么区别？？？？
    int outputFormat; /*见FPU_FP_FILE_FORM_EN*/ // TODO 好像是已废弃
    TRANS_VIDEO_SPEC_S output_transtable;

    // 主控带下来邮箱相关信息
    int inputFileType; /*  CTE_TRANS_INDEX_TYPE */ // TODO 目前只有合并用在使用
    MAILBOX_SHARE_MEMORY_PARAS_S down_mailbox;
    int down_valid; // 1 VALID 0 INVALID
} task_rd;

typedef struct io_read_thread_struct {
     task_rd task[22];
} ior_block；
```

## index关系

1. 分片
   1. 初始化task_ccb（master_control_proc.c）

      ```C
      UINT32 mc_fill_cte_split_task_info(task_start_split_req_t *ctm_req_msg,
                                         FPU_TSURM_CCB_STU *cte_task,
                                         UINT32 *down_mail_num, UINT32 *up_mail_num)
      {
      	cte_task->up_mailbox_output_type[0] = TRANSCODE_OUTPUT_VIDEO_AUDIO;
          *down_mail_num = 1; 
          *up_mail_num = 2;
          //后面没有用到up_valid和down_valid，所以没有设置
          
      }
      ```
   
      
   
    2. task_ccb 赋值给 start_spilt_req （master_control_fp.c）
   
       ```c
       UINT32 mc_fp_send_start_split_task_req(UINT32 cte_task_id)
       {
           start_split_req->output_type = cte_task->up_mailbox_output_type[0];//FIXME:注意这里start_split_req->output_type不是一个数组，应该考虑切转合统一
           start_split_req->up_mailbox_num = (UINT8)cte_task->udwUpMailCount;
        
           (VOID)CTE_MEM_CPY(&start_split_req->down_mail_box, sizeof(MAILBOX_SHARE_MEMORY_PARAS_S), &cte_task->down_mailbox[0], sizeof(MAILBOX_SHARE_MEMORY_PARAS_S));
        (VOID)CTE_MEM_CPY(&start_split_req->vUp_mail_box, sizeof(MAILBOX_SHARE_MEMORY_PARAS_S), &cte_task->up_mailbox[0], sizeof(MAILBOX_SHARE_MEMORY_PARAS_S));
           (VOID)CTE_MEM_CPY(&start_split_req->aUp_mail_box, sizeof(MAILBOX_SHARE_MEMORY_PARAS_S), &cte_task->up_mailbox[1],
       sizeof(MAILBOX_SHARE_MEMORY_PARAS_S));
           // FIXME:1.魔鬼数字难懂，但很难优化，2.应有统一的地方赋值一次
       }
       ```
       
    3. start_spilt_req 赋值给 io_read_ccb 和 io_write_ccb（io_control.h）
   
       ```c
    UINT32 io_split_resource_alloc(UINT32 index, MC_DP_START_SPLIT_REQ_S *start_request)
       {
           // 设置io_read_ccb
           ior_ccb->task[0].split_num = 1; 
           ior_ccb->task[0].down_mailbox = start_request->down_mail_box;
             	// 设置io_write_ccb
            iow_ccb->up_mailbox_num = start_request->up_mailbox_num;
            iow_ccb->up_mail_box[0] = start_request->vUp_mail_box; 
            iow_ccb->up_mail_box[1] = start_request->aUp_mail_box;
                /*分片只有一个输出*/
           iow_ccb->up_valid[0] = VALID; // TODO ugly 后续io_write根本没用到这个valid做输出
           iow_ccb->up_valid[1] = VALID;
       }
         
       ```
   
   
   
    4. task_ccb 赋值给 imedia（master_control_imedia.c）
   
       ```C
       UINT32 mc_imedia_send_start_split_task_req(FPU_TSURM_CCB_STU *cte_task,
               UINT32 cur_channel_id,
               UINT32 cte_task_id)
       {
           // FIXME: 魔鬼数字
           // 封装下行邮箱接口
           start_split_para->stDownMailInfo.uiShareMemKeyValue =
               cte_task->down_mailbox[0].uiShareMemKeyValue;
           start_split_para->stDownMailInfo.ulOffSetValue =
               cte_task->down_mailbox[0].ulOffSetValue;
           start_split_para->stDownMailInfo.uiMailBoxLength =
               cte_task->down_mailbox[0].uiMailBoxLength;
       
           // 封装上行视频邮箱接口
           start_split_para->stUpVMailInfo.uiShareMemKeyValue =
               cte_task->up_mailbox[0].uiShareMemKeyValue;
           start_split_para->stUpVMailInfo.ulOffSetValue =
               cte_task->up_mailbox[0].ulOffSetValue;
           start_split_para->stUpVMailInfo.uiMailBoxLength =
               cte_task->up_mailbox[0].uiMailBoxLength;
       
           // 封装上行音频邮箱接口
           start_split_para->stUpAMailInfo.uiShareMemKeyValue =
               cte_task->up_mailbox[1].uiShareMemKeyValue;
           start_split_para->stUpAMailInfo.ulOffSetValue =
               cte_task->up_mailbox[1].ulOffSetValue;
           start_split_para->stUpAMailInfo.uiMailBoxLength =
               cte_task->up_mailbox[1].uiMailBoxLength;
       }
       ```
   
    5. io逻辑
   
        
   
2. 转码

   

3. 合并

   

### 问题总结与优化

1. index的宏非常混乱（定义位置，使用，命名），index与inputType，outputType大多数场景是冗余的，inputType与outputType枚举定义混乱
   - 优化方案：
         方案一：使用固定index，切转合上下行邮箱定义独立宏，去掉inputType，outputType，单独为分片定义splitInputType，为合并定义mergeOutputType，
   
2. 邮箱的遍历逻辑没有形成统一
   - 统一使用MAX_NUM和valid遍历邮箱，但合并阶段改动量较大。

3. 枚举定义混乱，整个初始化逻辑可读性很差，task_ccb与io_ccb统一的变量值可能会不一致，可读很差，开发、定位问题困难
   - 抽出一个datamailInfo结构体，统一task_ccb，write_ccb,read_ccb不同场景下的邮箱逻辑与参数
   - start_xxx_req去掉邮箱相关信息，初始化write_ccb与read_ccb的时候memcpy task_ccb的datamailInfo（使用引用可能有并发问题），提高可读减少出错
   - 抽取initDatamailInfo()，在改函数内实现所有场景邮箱初始化
   - 定义在datamail.c



0429已完成：

- 抽取IOContext，WriteContext，ReadContext
- 去掉outputType，抽成MergeType
- 音频转码下行邮箱定为10，转码inputType判断改为判断index

待完成：

	1. io read write轮训邮箱逻辑改为MAX_NUM（未完成，，merge未完成）
 	2. 去掉start**req邮箱相关（未完成，merge未完成）

- 不由up down num分配邮箱给taskccb（已完成）

- 定义所有输入输出邮箱index枚举（已完成）

- 邮箱初始化
  - 抽取initDatamailInfo（未完成)
  - 分配邮箱给cte_ccb
  
- 

- taskccb赋值改io 邮箱使用指针（未完成）

  



## 与imedia交互

- 分片
  - io_read
  - io_write
  - master_control_imedia.c
- 转码
  - io_read
  - io_write
  - master_control_imedia_trans.c
- 合并
  - io_read
  - io_write
  - master_control_imedia.c



