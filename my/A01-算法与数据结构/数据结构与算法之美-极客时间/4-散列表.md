# 散列表

## 装载因子

**装载因子 ：装载因子 = 填入表中的元素个数 / 散列表长度**

> 关于散列表的时间复杂度：散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得 不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。
>
> 关于散列表碰撞攻击：如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列 表碰撞攻击的基本原理。
>

## 解决散列冲突

### 1. 开放寻址法

发生冲突时，重新探测一个新的位置。有以下3种开放寻址法。

- 线性探测法---往后找空位，步长固定为1
  - 删除元素时要标注delete，查找遇到delete时不能停，继续往后查找
  - 线性探测的问题：当数据越来越多，冲突概率越来越大，退化为O(n)
- 二次探测法---与线性探测法类似，只是遇到冲突时步长为n的平方
- 双重散列法---一组散列函数，遇到冲突时，使用下一个散列函数

**开放寻址法存都存着一个相同的问题，就是空闲位置不多时，冲突概率高，因此插入效率低下。用装载因子表示空位多少：散列表的装载因子 = 填入表中的元素个数 / 散列表长度**

### 2. 链表法

![1579594756451](../../../../../projectdocsmyimages/1579594756451.png)

#### 2.2 链表法复杂度

插入：O(1)

查找，删除：O(k)，其中k=元素总数/散列表中槽个数



## 装载因子过大怎么办

1. 动态扩容，一般容量翻倍，装载因子若是0.8，就会降到0.4
2. 动态扩容的时间复杂度，一般插入不需要扩容是O(1)， 扩容需要重新插入，时间复杂度是O(n)，均摊时间复杂度接近O(1)
3. 如何避免低效的扩容：
   1. 扩容只为新的散列表申请内存，不办搬移元素
   2. 插入数据到新表时，同时搬移旧表的一个元素到新表
   3. 查找时先查新表，找不到时，再查旧表
   4. 每次的时间复杂度时O(1)