计划：工作日每天3~4道题。周末每天10~15道题。一个月150~200道题

目标：1.算法，2.技巧   2. 手写

难点：1.算法想不到 2.技巧记不住  3.手写细节很多，容易遗漏 

切记避免：记不住的硬想，浪费很多时间，不熟练写代码浪费很多时间

方法：第一阶段：快速，多遍过算法 ，过三遍，不写代码，只看代码，写总结，1个月

​		   第二阶段：手写，三遍，15天

| 日期 | 题目数 |      |
| ---- | ------ | ---- |
| 0103 | 9道    |      |
| 0106 | 6道    |      |
| 0113 | 7道    |      |



[TOC]



# 记录

| *：没有头绪<br />?：不是最优解<br />Y：过关 | title                                              | tag        | note                                                         |
| ------------------------------------------- | :------------------------------------------------- | ---------- | ------------------------------------------------------------ |
| ？2021/1/3                                  | 1.1 字符串循环移位包含                             | 字符串     |                                                              |
| *2021/1/3                                   | 1.2 字符串循环位移                                 | 字符串     |                                                              |
| ?2021/1/3                                   | 1.3 字符串中单词的翻转                             | 字符串     |                                                              |
| ?2020/9/3<br />?2021/1/3                    | 1.4 两个字符串包含的字符是否完全相同               | 字符串     | 一开始判断长度不等则返回，可以省略最后遍历哈希表             |
| ?                                           | 1.5 计算一组字符集合可以组成的回文字符串的最大长度 | 字符串     |                                                              |
| *2021/1/3                                   | 1.6 字符串同构                                     | 字符串     | 判断两个字符串的同一位置的字符上一个位置是否相同             |
| *2021/1/3                                   | 1.7 回文子字符串个数                               | 字符串     | 枚举每一个可能的回文中心，两个指针向两边拓展                 |
| *2021/1/3                                   | 1.8  判断回文数                                    | 字符串     |                                                              |
| *2021/1/6                                   | 1.9 连续0，1组合子串个数                           | 字符串     | 划分区间，记录每个区间长度，相邻区间长度最小值为子字符串连续01子字符串个数 |
| Y                                           | 2.1 数组中两个数的和为给定值                       | 哈希表     |                                                              |
| Y                                           | 2.2 判断数组是否含有重复元素                       | 哈希表     |                                                              |
| Y*2021/1/6                                  | 2.3 最长和谐序列                                   | 哈希表     |                                                              |
| *2021/1/6                                   | 2.4 最长连续序列                                   | 哈希表     | 注意要求O(N)时间复杂度                                       |
| *Y 2021/1/6                                 | 3.1 找出两个链表的交点                             | 链表       | a+c+b=b+c+a , a+b=b+a => null                                |
| *Y 2021/1/13                                | 3.2 链表反转                                       | 链表       | 方法一头插法：两个指针即可；<br />方法二递归：反复思考，比较难掌握 |
| ？                                          | 3.3 归并两个有序的链表                             | 链表       |                                                              |
| ？                                          | 3.4 从有序链表中删除重复节点                       | 链表       | 注意：考虑到有3个以上等值，所以相等后不能直接移动cur指针；<br />递归：上一级已经返回去重的链表，想想这一级递归要干啥 |
| *                                           | 3.5 删除链表的倒数第 n 个节点                      | 链表       | 要注意删除的是第一个元素时的情况。快指针指向空               |
| *2021/1/13                                  | 3.6 交换链表中的相邻结点                           | 链表       | 利用头结点让代码没那么丑，网上很多用了4个指针，其实3个指针也可以 |
| *2021/1/13                                  | 3.7 链表求和                                       | 链表       | 0113：算法简单，实现细节多                                   |
| ？2021/1/13                                 | 3.8 回文链表                                       | 链表       | 注意当结点总数为偶数是，中点是要下中点在翻转<br />0113：考虑O(1)空间复杂度，实现细节多 |
| ？2021/1/16                                 | 3.9 分割                                           | 链表       | 关键是这里的商和余数是怎么用，想想这道题与除法的关系<br />0116： |
| ？2021/1/17                                 | 3.10 链表元素按奇偶聚集                            | 链表       | 可以不需要判断奇偶，但是要注意循环边界<br />0116：每次循环就把改变两个指针，时间复杂度可以降低一半。另外注意循环结束第二个节点已经改变，不能用head.next表示第一个偶数节点 |
|                                             | 4.1 把数组中的 0 移到末尾                          | 数组与矩阵 |                                                              |
|                                             | 4.2 改变矩阵维度                                   | 数组与矩阵 |                                                              |
| *                                           | 4.3 找出数组中最长的连续1                          | 数组与矩阵 |                                                              |
| 8                                           | 4.4 有序矩阵查找                                   | 数组与矩阵 | 从左下或者右上开始都可以，因为左上/右下都是比当前元素都大/小，没法确定下一步如何走 |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |
|                                             |                                                    |            |                                                              |



# 精选200

# 1. 字符串

## 1.1 字符串循环移位包含



>题目：编程之美 3.1
>
>​	s1 = AABCD, s2 = CDAA
>​	Return : true
>​	给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。
>
>解答：
>
>​	s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串
>​	即可。

```PYTHON
str1 = 'AABCD'
str2 = 'CDAA'
str11 = 'AABCD' * 2
if str2 in str11:
    print("true")
else:
    print("false")
```



## 1.2 字符串循环位移

>题目：编程之美 2.17
>
>​	s = "abcd123" k = 3
>​	Return "123abcd"
>​	将字符串向右循环移动 k 位。
>
>解答：
>
>​	将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。

```PYTHON
str1 = 'abcd123'
reverse_last_index = 3
str11 = str1[-(reverse_last_index+1)::-1]
str12 = str1[:-(reverse_last_index+1):-1]
ret = (str11+str12)[::-1]
print('ret:', ret)
```



## 1.3 字符串中单词的翻转

>程序员代码面试指南，题目：
>
>​	s = "I am a student"
>​	Return "student a am I"
>
>解答：
>
>​	将每个单词翻转，然后将整个字符串翻转。

```python

"""
s = "I am a student"
Return "student a am I"
"""
str1 = "I am a student"
str_split = str1.split(' ')
for index, word in enumerate(str_split):
    str_split[index] = word[::-1]
ret = ' '.join(str_split)
print('ret:', ret[::-1])

output:
ret: student a am I
```



## 1.4 两个字符串包含的字符是否完全相同

[两个字符串包含的字符是否完全相同](https://leetcode-cn.com/problems/valid-anagram/description/)

>给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。
>
>s = "anagram", t = "nagaram", return true.
>s = "rat", t = "car", return false.

```python
# 1.一开始判断长度不等则返回，可以省略最后遍历哈希表  2.用fromKeys初始化哈希表可以省去判断in，但需要用ord得到字符哈希值 3.由于保证了长度相等，若s和t不是字母异或词，则肯定出现t有的字母s没有，因此一定会出现哈希表count数值小于0情况，可以省略最后遍历哈希表count是否全为0的这一步骤
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        dict1 = dict.fromkeys(range(26), 0)
        for k,v in enumerate(s):
            dict1[ord(v) - ord('a')] += 1
        for k,v in enumerate(t):
            dict1[ord(v) - ord('a')] -= 1
            if dict1[ord(v) - ord('a')] < 0:
                return False

        return True
```

## 1.5 计算一组字符集合可以组成的回文字符串的最大长度

[409. Longest Palindrome (Easy)](https://leetcode-cn.com/problems/longest-palindrome/description/)

>Input : "abccccdd"
>Output : 7
>Explanation : One longest palindrome that can be built is "dccaccd", whose length

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        wordCnt = dict.fromkeys(range(256), 0)

        for k,v in enumerate(s):
            wordCnt[ord(v)] += 1

        hasOdd = False
        len = 0
        for v in wordCnt.values():
            num = v // 2
            mod = v % 2

            len += num * 2
            if mod > 0:
                hasOdd = True

        return len + (1 if hasOdd else 0)
```



## 1.6 字符串同构

[205. Isomorphic Strings (Easy)](https://leetcode-cn.com/problems/isomorphic-strings/description/)

>给定两个字符串 s 和 t，判断它们是否是同构的。
>
>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
>
>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
>
>**示例 1:**
>
>输入：s = "egg", t = "add"
>输出：true
>**示例 2：**
>
>输入：s = "foo", t = "bar"
>输出：false
>**示例 3：**
>
>输入：s = "paper", t = "title"
>输出：true

```PYTHON
"""
记录映射关系代码不好写，就死记这种方法。
记住：字符串同构：同一位置上的字符上次出现为位置相同。
"""
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        preIndex1 = dict.fromkeys(range(256), -1)
        preIndex2 = dict.fromkeys(range(256), -1)

        for i in range(len(s)):
            if preIndex1[ord(s[i])] != preIndex2[ord(t[i])]:
                return False
            preIndex1[ord(s[i])] = i
            preIndex2[ord(t[i])] = i
        return True
```

## 1.7 回文子字符串个数

[647. Palindromic Substrings (Medium)](https://leetcode-cn.com/problems/palindromic-substrings/description/)

>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
>
>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
>
>
>
>**示例 1：**
>
>输入："abc"
>输出：3
>解释：三个回文子串: "a", "b", "c"
>
>
>
>**示例 2：**
>
>输入："aaa"
>输出：6
>解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

```python
"""
中心拓展法：
时间复杂度：O(n^2)
空间复杂度：O(1)
"""
class Solution:
    def countSubstrings(self, s: str) -> int:
        cnt = 0
        for i in range(len(s)):
            cnt += self.extendCountSubString(s, i, i)
            cnt += self.extendCountSubString(s, i, i+1)
        return cnt

    def extendCountSubString(self, s:str, start:int, end:int)-> int:
        cnt = 0
        while start >= 0 and end < len(s) and s[start] == s[end]:
            cnt += 1
            start -= 1
            end += 1
        return cnt
"""
Manacher 算法：
时间复杂度：O(n)
空间复杂度：O(n)
todo：
"""

```

## 1.8 判断一个整数是否是回文数

[9. Palindrome Number (Easy)](https://leetcode-cn.com/problems/palindrome-number/description/)

>**示例 1:**
>
>输入: 121
>输出: true
>**示例 2:**
>
>输入: -121
>输出: false
>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
>**示例 3:**
>
>输入: 10
>输出: false
>解释: 从右向左读, 为 01 。因此它不是一个回文数。

```python
# 方法一：python语法糖
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 :
            return False
        l1 = list(str(x))
        f, b = 0, len(l1) - 1
        while f < b and l1[f] == l1[b]:
            f += 1
            b -= 1 
        return True if f >=b else False
    
# 方法二：传统方法
# 1.想想如何翻转一个数
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x == 0:
            return True
        if x < 0 or x % 10 == 0:
            return False

        right = 0
        while x > right:
            right = right * 10 + x % 10
            x = x // 10

        return  x == right or x == right // 10
```

## 1.9 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数

[696. Count Binary Substrings (Easy)](https://leetcode-cn.com/problems/count-binary-substrings/description/)

>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
>
>重复出现的子串要计算它们出现的次数。
>
>**示例 1 :**
>
>输入: "00110011"
>输出: 6
>解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
>
>请注意，一些重复出现的子串要计算它们出现的次数。
>
>另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
>**示例 2 :**
>
>输入: "10101"
>输出: 4
>解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

```PYTHON
# 方法一：思路：划分区间，记录每个区间长度，相邻区间长度最小值则为这两个区间组成的字符串连续1,0数量相同的子字符串个数。
#       举例：00111
#				相同数量子串有2个：0011,01
#				也就是两个区间长度{2,3}的最小值2
# 		实现技巧，只用 lastLen 保留上一个区间的长度，得到当前区间长度 curLen，ans += min(lastLen,curLen)
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        i, n, ret, lastLen = 0, len(s), 0, 0
        while i < n:
            curLen = 0
            c = s[i]
            while i < n and s[i] == c:
                curLen += 1
                i += 1
            ret += min(lastLen, curLen)
            last = curLen
        return ret
```





# 2. 哈希表

## 2.1 数组中两个数的和为给定值

[1. Two Sum (Easy)](https://leetcode-cn.com/problems/two-sum/description/)

>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
>
>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
>
>**示例 1：**
>
>输入：nums = [2,7,11,15], target = 9
>输出：[0,1]
>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
>**示例 2：**
>
>输入：nums = [3,2,4], target = 6
>输出：[1,2]
>**示例 3：**
>
>输入：nums = [3,3], target = 6
>输出：[0,1]

```PYTHON
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dict1 = {}
        for k,v in enumerate(nums):
            if target - v not in dict1:
                dict1[v] = k
            else:
                return [dict1[target - v], k]
        return None
```

## 2.2 判断数组是否含有重复元素

[217. Contains Duplicate (Easy)](https://leetcode-cn.com/problems/contains-duplicate/description/)

>**示例 1:**
>
>输入: [1,2,3,1]
>输出: true
>**示例 2:**
>
>输入: [1,2,3,4]
>输出: false
>**示例 3:**
>
>输入: [1,1,1,3,3,4,3,2,4,2]
>输出: true

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        dict1 = {}
        for k, v in enumerate(nums):
            if v in dict1:
                return True
            dict1[v] = 1
        return False
```

## 2.3 最长和谐序列

[594. Longest Harmonious Subsequence (Easy)](https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/)

> 和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1
>
> **示例 1:**
>
> ```
> 输入: [1,3,2,2,5,2,3,7]
> 输出: 5
> 原因: 最长的和谐数组是：[3,2,2,2,3].
> ```

```PYTHON
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        dicts = {}
        for v in nums:
            dicts[v] = dicts.get(v, 0) + 1

        ret = 0
        for key, value in dicts.items():
            if key + 1 in dicts:
                ret = max(dicts[key + 1] + value, ret)
        return ret
```



## 2.4 最长连续序列

[128. Longest Consecutive Sequence (Hard)](https://leetcode-cn.com/problems/longest-consecutive-sequence/description/)

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> **要求：**你可以设计并实现时间复杂度为 `O(n)` 的解决方案吗？
>
> **示例 1：** 
>
> 输入：nums = [100,4,200,1,3,2]
> 输出：4
> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
> **示例 2：**
>
> 输入：nums = [0,3,7,2,5,8,4,6,0,1] 
> 输出：9

```PYTHON
# 注意要求O(N)
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums_set = set(nums)
        ret = 0
        for v in nums_set:
            if v - 1 not in nums_set: # 最长序列的第一个值v，v-1必定不存，因此检查是否存在v-1即可判断是否跳过
                count = 1

                while v + 1 in nums_set:
                    v += 1
                    count += 1
                ret = max(ret, count)
        return ret
"""
如何分析这段代码的时间复杂度？
	每个数只会进入内层循环一次，所以是O（N）。
	比如有【1，2，3，11，12，13】
		v=1，进入内循环：
			2，3
      v=11，进入内循环：
      	 12，13
  	end
"""
```



# 3. 链表

## 3.1 找出两个链表的交点

---

[160. Intersection of Two Linked Lists (Easy)](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

> **注意**：
>
> 如果两个链表没有交点，返回 null.
> 在返回结果后，两个链表仍须保持原有的结构。
> 可假定整个链表结构中没有循环。
> 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

``` PYTHON
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        l1, l2 = headA, headB
        # 因为一个节点只有一个next指针，因此当两链表相交，两链表交点以后也都是公共节点。 
        # 定义：A/B分别为两链表非公共部分，C为公共部分
        # 情况1：有交点：A+C+B = B+C+A，以下实现最终l1,l2 指向第一次公共节点也即是交点，终止循环并最终返回交点
        # 情况2：没有交点：A+B = B+A， 以下实现最终l1,l2 都为null，也即相等，终止循环并最终返回null
        while l1 is not l2:
            l1 = l1.next if l1 else headB
            l2 = l2.next if l2 else headA
        return l1
```

## 3.2 链表反转

----

[206. Reverse Linked List (Easy)](https://leetcode-cn.com/problems/reverse-linked-list/description/)

```PYTHON
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
"""
1.头插法
	1.1 三指针法
"""
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre, cur = None, head
        while cur is not None:
            next = cur.next
            cur.next = pre
            pre, cur = cur, next
        return pre
    
"""
	1.2 优化：两指针法：利用head作为cur指针遍历
"""
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 1.init
        pre = None
        while head is not None:
            # 1. init
            next = head.next
            # 2. excute step 1
            head.next = pre
            # 3. prepare next loop
            pre, head = head, next
        return pre
"""
2.递归法
    #######################################################
    # 1.本级递归应该做什么：在这一级递归中，应该完成什么任务？
    	方案1：修改当前节点next指针，指向前驱节点？这样要head和pre都传参，不太好。
    	更好的方案：修改当前节的下一个节点的next指针，指向当前节点：
    	head->next->next = head; head->next = 0
    # 2 找整个递归的终止条件：递归应该在什么时候结束？	根据1可知终止条件: head==0 or head->next==0
    # 3.找返回值：应该给上一级返回什么信息？	最终返回的是最后一个节点，因此 当 head==0 or head->next==0 return head 否则 返回上级递归函数返回的结果last（也即最后一个节点），但是本级递归（head->next->next = next; head->next = 0）又只能在递归函数后执行，因此要把上级递归返回last保存起来，在最后返回。
    
   tips： 递归可以说是走到链表末，从后往前的，与一般的循环的方法比较，递归法无需保存next节点，是需要保存pre节点，而递归法特点已经在每层递归中保存了前驱节点，也即上层递归的head。
    #######################################################
"""
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 2. 整个递归终止条件
        if head is None or head.next is None:
            return head

        # 3.1 保存上级递归结果（也即最后一个节点）
        last = self.reverseList(head.next)
        # 1. 本级递归要做的
        head.next.next = head
        head.next = None

        # 3.2 给上级返回最后一个节点
        return last
```

## 3.3 归并两个有序的链表

---

[21. Merge Two Sorted Lists (Easy)](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/)

```python
# 方法一迭代法：
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = ListNode(-1)

        pre = head
        while l1 is None and l2 is None:
            if l1.val <= l2.val:
                pre.next = l1
                l1 = l1.next
            else:
                pre.next = l2
                l2 = l2.next
            pre = pre.next

        pre.next = l1 if l1 is None else l2

        return head
# 方法二递归法：
####### 思考过程
# 1.终止条件：l1 为空 or l2 为空
# 2.本级递归要做什么：1.获取更小的节点作为min 2.min.next指向递归返回（其余节点合并后的结果）
# 3.返回什么：返回更小节点
# 总结 ：本级要做什么和返回并不是分开思考的，本级迭代的要做的是“得到更小的节点”
######
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        if l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```



## 3.4 从有序链表中删除重复节点

---

[83. Remove Duplicates from Sorted List (Easy)](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

> 无需考虑删除节点的next。。

```python
# 直接法
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        cur = head
        while cur is not None and cur.next is not None:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
```



## 3.5 删除链表的倒数第 n 个节点

[19. Remove Nth Node From End of List (Medium)](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/)

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast, slow = head, head
        while n > 0:
            fast = fast.next
            n = n - 1
        if fast is None: # 当删除倒数第一个节点时，出现该情况，容易遗漏
            return slow.next 
        while fast.next is not None:
            slow = slow.next
            fast = fast.next
        slow.next = slow.next.next
        return head
```



## 3.6 交换链表中的相邻结点

[24. Swap Nodes in Pairs (Medium)](https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/)

> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
>
> **你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

```PYTHON
# 如果不用头结点，保存第一个节点需要加判断条件，比较丑
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        cur = head
        pre = dummy
        while cur is not None and cur.next is not None:
            # prepare
            temp = cur.next

            # swap
            cur.next = cur.next.next
            temp.next = cur
            pre.next = temp
				
            # after
            pre = cur # 易错，不是pre=temp
            cur = cur.next

        return dummy.next # 易错，不能直接返回head
```



## 3.7 链表求和

[445. Add Two Numbers II (Medium)](https://leetcode-cn.com/problems/add-two-numbers-ii/description/)

> 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>
> **示例：**
>
> ```
> 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 8 -> 0 -> 7
> ```

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1 = self.buildStack(l1)
        s2 = self.buildStack(l2)
        ans = None

        addFlag = 0
        while s1 or s2 or addFlag != 0:
            a = 0 if not s1 else s1.pop()
            b = 0 if not s2 else s2.pop()
            c = a + b + addFlag
            addFlag = c // 10
            curNode = ListNode(c%10)
            curNode.next = ans
            ans = curNode
        return ans

    def buildStack(self, l1: ListNode) -> list:
        list1 = []
        while l1:
            list1.append(l1.val)
            l1 = l1.next
        return list1
```



## 3.8 回文链表

[234. Palindrome Linked List (Easy)](https://leetcode-cn.com/problems/palindrome-linked-list/description/)

> 请判断一个链表是否为回文链表。
>
> 尝试O(1)空间复杂度完成。
>
> **示例 1:**
>
> ```
> 输入: 1->2
> 输出: false
> ```
>
> **示例 2:**
>
> ```
> 输入: 1->2->2->1
> 输出: true
> ```

```python
"""
最简单方法：copy到数组，再通过双指针法判断。空间复杂度O(N)
"""


"""
空间复杂度 O(1):
	快慢指针法：找中点，翻转，比较
 	主要难点是找中点。注意当结点偶数时，需要指向下中点再翻转
"""
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        # 1. 快慢指针找到中点，注意是偶数时是下中点
        # 2. 翻转
        # 3. 比较
       half = self.endOfHalf(head)
       return self.isEqual(head, self.reversedList(half))


    def endOfHalf(self, head:ListNode) -> ListNode:
        fast, slow = head, head
        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next
        return slow

    def reversedList(self, head:ListNode) -> ListNode:
        pre = None
        while head is not None:
            nextNode = head.next
            head.next = pre
            pre, head = head, nextNode
        return pre

    def isEqual(self, head:ListNode, half:ListNode) -> bool:
        while head is not None and half is not None:
            if head.val != half.val:
                return False
            head = head.next
            half = half.next

        return True
```



## 3.9 分隔链表

[725. Split Linked List in Parts(Medium)](https://leetcode-cn.com/problems/split-linked-list-in-parts/description/)

> 给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。
>
> 每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。
>
> 这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。
>
> 返回一个符合上述规则的链表的列表。
>
> 举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]
>
> **示例 1：**
>
> 输入: 
> root = [1, 2, 3], k = 5
> 输出: [[1],[2],[3],[],[]]
> 解释:
> 输入输出各部分都应该是链表，而不是数组。
> 例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
> 第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
> 最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。
> **示例 2：**
>
> 输入: 
> root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
> 输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
> 解释:
> 输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。

```python
class Solution:
    def splitListToParts(self, root: ListNode, k: int) -> List[ListNode]:
        head = root
        result = []
        len = 0
        while head is not None:
            head = head.next
            len += 1

        dummy = ListNode(-1)
        dummy.next = root
        size = len // k
        mod = len % k
        for i in range(k):
            cur = dummy
            result.append(dummy.next)
            for j in range(size):	# 对于每个槽，先放入商的部分
                cur = cur.next
            if mod > 0:				# 对于每个槽，都放入余数部分
                cur = cur.next
                mod -= 1

            dummy.next = cur.next
            cur.next = None

        return result
```



## 3.10 链表元素按奇偶聚集

[328. Odd Even Linked List (Medium)](https://leetcode-cn.com/problems/odd-even-linked-list/description/)

> 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
>
> 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
>
> **示例 1:**
>
> 输入: 1->2->3->4->5->NULL
> 输出: 1->3->5->2->4->NULL
> **示例 2:**
>
> 输入: 2->1->3->5->6->4->7->NULL 
> 输出: 2->3->6->7->1->5->4->NULL
> 说明:
>
> 应当保持奇数节点和偶数节点的相对顺序。
> 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

```PYTHON
# 方法二：无需判断奇偶，直接修改两个next，可以省一个判断和num变量，代码简洁很多，但要注意循环边界
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:return head
        odd = head
        even_head = even = head.next	# 注意必须保存第二个节点，因为后面head.next已经变了
        while odd.next and even.next:
            odd.next = odd.next.next
            even.next = even.next.next
            odd,even = odd.next,even.next
        odd.next = even_head
        return head
```



# 4. 数组与矩阵

## 4.1 把数组中的 0 移到末尾

[283. Move Zeroes (Easy)](https://leetcode-cn.com/problems/move-zeroes/description/)

```PYTHON
# 方法一：两次遍历
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        j = 0
        for v in nums:
            if v != 0:
                nums[j] = v
                j += 1
        for i in range(j, len(nums)):
            nums[i] = 0

# 方法二：一次遍历，不好记，想不起来就用方法一好了
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        index = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[index] = nums[index], nums[i]
                index += 1
        return nums
    
```

两种方法时间空间复杂度都一样：O(N)，O(1)， 不过方法一赋值操作比较多，特别对于0都在非零前面的情况



## 4.2 改变矩阵维度

[566. Reshape the Matrix (Easy)](https://leetcode-cn.com/problems/reshape-the-matrix/description/)

```PYTHON
# 方法一：转数组在重组，利用python 切片代码简洁
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        if len(nums) * len(nums[0]) != r * c:
            return nums
        res = [i for j in nums for i in j]    
        return [res[i:i+c] for i in range(0,len(res),c)]
    
# 方法二：不用额外空间
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        if len(nums) * len(nums[0]) != r * c:
            return nums

        retList, subList，nn = [], [], 0
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                if nn < c:
                    subList.append(nums[i][j])
                    nn += 1
                if nn == c:
                    retList.append(subList.copy())
                    subList.clear()
                    nn = 0
        return retList
```



## 4.3 找出数组中最长的连续1

[485. Max Consecutive Ones (Easy)](https://leetcode-cn.com/problems/max-consecutive-ones/description/)

```PYTHON
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        ret, count = 0, 0
        for i in range(0, len(nums)):
            count = 0 if nums[i] == 0 else count + 1
            ret = max(ret, count)
        return ret
```





## 4.4 有序矩阵查找

## 4.5 有序矩阵的 Kth Element

## 4.6 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数
## 4.7 找出数组中重复的数，数组值在 [1, n] 之间

## 4.8 数组相邻差值的个数

## 4.9 数组的度

## 4.10 对角元素相等的矩阵

## 4.11 嵌套数组

## 4.12 分隔数组



# 5. 栈与队列

# 6. 树

# 7.图

# 8.位运算

------------------------

# 9. 双指针

# 10.排序

# 11. 二分查找

# 12. 搜索

# 13. 分治

# 14. 贪心思想

# 15. 动态规划

# 16. 数学