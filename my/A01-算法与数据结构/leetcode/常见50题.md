#### [9.回文数](https://leetcode-cn.com/problems/palindrome-number/)

```c
class Solution {
    public boolean isPalindrome(int x) {
        //思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false
        if (x < 0 || (x % 10 == 0 && x != 0)) return false;
        int revertedNumber = 0;
        while (x > revertedNumber) {// 巧妙，避免了溢出，而且减少一半运算
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
      	// 如果位数位偶数，一半相等，如果位数位奇数，除10相等
        return x == revertedNumber || x == revertedNumber / 10;
    }
}
 时间复杂度：时间复杂度：O(log10n),对于每次迭代，我们会将输入除以10
 空间复杂度：O(1)
```





#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```c
//思路：遍历寻找最大收益，遍历当某天表示当前卖出，收益=当天价格-之前最低那天，。因此要记录两个字，最大收益，与当前天最小价格。
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}
```



#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```c
int maxProfit(int* prices, int pricesSize){
    int profile = 0;
    
    for (int i= 1; i < pricesSize; i++) {
        if (prices[i-1] < prices[i]) {
            profile += prices[i] - prices[i-1];
        }
    }
    
    return profile;
}
```



#### [217-存在重复数字](https://leetcode-cn.com/problems/contains-duplicate/solution/cxian-pai-xu-hou-pan-duan-shi-fou-you-lian-xu-zhon/)

```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
       unordered_set<int> data;
        for (int i = 0;i<nums.size();i++) {
            if(data.find(nums[i]) != data.end()) {
                return true;
            }
            data.insert(nums[i]);
        }
        return false;
    }
};
```

1. 用C只能用排序
2. 用C++的unordered_set比较快

#### [160-链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/)

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    if(headA == NULL || headB == NULL) return NULL;
    struct ListNode *a = headA, *b = headB;
    while(a != b) {
        a = a == NULL ? headB : a->next;
        b = b == NULL ? headA : b->next;
    } 
    return a;
}
```

方法：定义指针A和B，分别遍历链a，b，到末尾的指针遍历另一条链。两指针相遇则是相交结点，若两指针没有相遇表示两条链表不相交。

原理：指针A，B以相同的速度（每次一步），指针A走了a非公共部分+公共部分+b非公共部分，指针B走了b非公共部分+公共部分+a非公共部分，相同的速度走了相同的路程，即同时到终点（相交点）。



#### [53-最大子序和](https://leetcode-cn.com/problems/maximum-subarray/solution/xiang-xi-jie-du-dong-tai-gui-hua-de-shi-xian-yi-li/)（结果子数组最少包含一个元素）

```c
int maxSubArray(int* nums, int numsSize){
    if (numsSize <= 0) return 0;
    int sum = nums[0] , ans = nums[0];
    for (int i = 1; i < numsSize; i++) {
        if (sum > 0) {
            sum += nums[i];
        } else {
            sum = nums[i];
        }
				ans = sum>ans ? sum:ans;
    }
    return ans;
}
```

转化为动态规划：求以每个结点为结束点，最大序列和。

状态转移方程：sum[i] = max{sum[i-1] + a[i], a[i]}

注意：数列只有-1的情况，所以初始为第一个元素。



#### [70-爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/)

方法一：动态规划，第 *i* 阶可以由以下两种方法得到：

1. 在第 (i-1)(*i*−1) 阶后向上爬1阶。

2. 在第 (i-2)(*i*−2) 阶后向上爬2阶。

3. dp[i]=dp[i−1]+dp[i−2]

4. 时间复杂度O(n),空间复杂度O(n)

   

```c
int climbStairs(int n){
    if (n < 3) return n;
    int first = 1;
    int second = 2;
    for (int i = 2; i < n; i++) {
        int third = first + second;
        first = second;
        second = third;
    }
    return second;

```

方法二：斐波那契数列

1. 时间复杂度O(n),空间复杂度O(1)



#### [231-二的幂](https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/)

```c
bool isPowerOfTwo(int n){
	return n>0 && (n&(n-1)==0;
}
```

1. 需要排除掉n<0，因为当N是MIN_INT，n-1会溢出

2. 要排除掉n=0，因为判断中等于0，但0不是2的幂

3. 需要注意&的优先级小于==，所以(n&(n-1))要加括号

   

#### [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```c
int removeDuplicates(int* nums, int numsSize){
    if(numsSize == 0) return 0;
    int fast=0,slow=0;
    for(;fast<numsSize;fast++) {
        if(nums[fast] != nums[slow]) {
            slow ++;
            nums[slow] = nums[fast];
        }
    }
    return slow+1;
}
```

1. 最后返回要加1
2. 当元素个数为0和为1时，slow都没有变化，最后返回1，所以要排除元素个数为0的情况



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    int last = m+n-1;
    m--;		// 可以省略额外变量
    n--;
    while(m>=0&&n>=0) {
        if(nums1[m] > nums2[n]) {
            nums1[last--] = nums1[m--];
        } else {
            nums1[last--] = nums2[n--];
        }
    }
    while(n >= 0) {	// 只需要处理n>=0的情况
        nums1[last--] = nums2[n--];
    }
}	
```



#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```c
bool hasCycle(struct ListNode *head) {
    if(head == NULL) return false;
    struct ListNode *fast = head->next, *slow = head;
    while(fast != slow && (fast != NULL && fast->next != NULL)) {
        fast = fast->next->next;
        slow = slow->next;
    }
    return fast == slow;
}
```

这么简单的题目都错漏百出，首先，fast不能出初始化为head，不然while一开始就跳出了。其次，while 条件应该是&&，不是||。



#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```c
bool isValid(char * s){
    if (s==NULL) return true;
    
    int *stack = (int*)malloc(sizeof(int)*strlen(s));
    int top = 0;
    
    while(*s!='\0') {
        if (*s == '(' || *s == '[' || *s == '{') {
            stack[top++] = *s;
        } else {
            if (top == 0) return false;
            if (*s == ')' && stack[--top] != '(')  return false;
            else if (*s == ']' && stack[--top] != '[') return false;
            else if (*s == '}' && stack[--top] != '{') return false;
        }
        s++;
    }
    
    return top==0;
}
```

也容易出错：

1. C语言，也可以简单用一个top下索引用作一个栈
2. 判空指针
3. top是先--