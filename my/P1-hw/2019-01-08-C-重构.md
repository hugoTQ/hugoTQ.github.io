

[TOC]

#   C语言代码规范

## 基础原则

### 删除废弃代码

1. 删掉注释代码

   开发阶段注释代码方便重构，上库检视注释代码是否有必要保留，CTE有几千行注释的以后也不可能用的代码，假如后面可能还有用的注释块代，请写下保留理由，理论上大部分注释代码都没必要保留，查看历史版本即可

2. 删除无用变量

   例如下面这个valid变量，注释已写明该变量已弃用

![1548991664992](C:\Users\h00379181\AppData\Roaming\Typora\typora-user-images\1548991664992.png)

引用valid的地方都是if判断和赋1，删掉不会影响功能，立马简化很多逻辑，写下这个注释的人怎么想的。。。。

![1548991804318](C:\Users\h00379181\AppData\Roaming\Typora\typora-user-images\1548991804318.png)

3. 删掉无用参数

![1548993460261](C:\Users\h00379181\AppData\Roaming\Typora\typora-user-images\1548993460261.png)

![1548993506063](C:\Users\h00379181\AppData\Roaming\Typora\typora-user-images\1548993506063.png)

可以看到up_mail_index 在函数内没有到，随着代码改动，无用的参数都删了吧。。

我认为上面是最基本的编码习惯了，按理不需要提出来

### 错误单词

spilte -> spilt

templet->template

### 命名

函数，结构体类型，枚举类型，联合体类型大驼峰
全局变量，局部变量，局部常量，函数参数，宏参数，结构体中字段，联合体中成员小驼峰
宏，全局常量(const)，枚举值，goto 标签全大写，下划线分割

### 结构体

- typedef 使用匿名结构体，指针自嵌套，加上tag前缀
- 

c文件应该放结构体吗？

结构体上下两个命名？大小写等规范

### 函数

入参

static的好处

###　常量

放头c文件还是头文件？

注释怎么写？

### 错误返回

错误码太细会导致代码不好写？底层设置

### 异常处理

### 宏定义

### 注释

###　排版

### 可读性

## 重构有基本原则

- 小步重构，用例保障。



## 小技巧使用

1. alloc省去memset，减少出错提高代码简洁，当然既然alloc包含了memset动作，必然有性能差别，实测：
2. ide使用
   - 重命名
   - 自动删除空格
   - 行宽线
3. 通过大写命名还是static？
4. 

# CTE 重构

原则：

- 可读性
- 扩展性
- 开发效率
- 质量保障

方法：

- 模块划分
- 命名
- 函数行数
- 结构体定义
- 降低耦合

**搜下TODO**

## 不用extern

## 宏重复

1. 基础类型

u32 INT32

NULL NULL_PTR

基本类型为什么定义宏？typedef SIZE_T size_t

io不涉及业务，只用valid判断，输入文件，输出文件封装一个结构体。具体valid和文件名独立业务层做

2. 相关代码

cte_typedef.h

pub.h

## master->io->imedia 统一结构体

- 干掉start_***_req里可以在task_ccb获取的信息
- 整理task_ccb，抽出结构体
  - 邮箱
  - path
  - 
- 邮箱
- 各种输入输出路径
- 各种标志位
- 各种枚举类型

## 命名

- 规范
- 统一命名
  - cutpic。。screenshot。。thumnail。。JPEG。。。
  - 参考公司最新规范
- 命名不好

## 重复代码

- 模块/函数

- 结构

- 拼接

- 错误码

- 合并拼接文件

- 举例：split与trans

  ## 代码逻辑与结构优化

  例1: 同一代码段重复了4次

  ```c
  UINT32 read_io_transcode_task(ior_block *task_cb)
  {
      // 预处理
      err_code = (UINT32)preProcess();
      if (TASK_SUCCESS != err_code){
          fun2();
          fun3();
          return ;
      }
  	
      // 对视频/音频邮箱操作
      err_code = fun1(0);
      if (TASK_SUCCESS != err_code){
          fun2();
          fun3();
          return ;
      }
  
      // 对字幕邮箱操作
      if (CTE_STR_LEN(task_cb->in_srt_path) != 0){
          err_code = fun1(1);
          if (TASK_SUCCESS != err_code)
          {
              fun2();
              fun3();
              return ;
          }
      }
  
      // 对水印邮箱操作
      UINT32 watermark_task_num = TRANS_DOWNMAIL_WATERMARK_INDEX;
      for (...){
          err_code = fun1(i); 
          if (TASK_SUCCESS != err_code)
          {
              fun2();
              fun3();
              return ;
          }
      }
  }
  
  INT32 preProcess(ior_block *task_ior_cb)//120行代码
  {
      fun4~8(0)//20行重复代码
  
      if (CTE_STR_LEN(task_ior_cb->in_srt_path) != 0)
      {
         fun4~8(1)//20行重复代码
      }
  
      for (i = 0; i < watermark_num; i++, watermark_task_index++)
      {
          fun4~8(i)//20行重复代码
      }
  }
  ```

  重构后：原180代码重构后90行

  ```C
  UINT32 read_io_transcode_task(ReadControlBlock *readcb)
  {
      // 预处理，打开第一个文件
      err_code = (UINT32)preProcess(readcb);
      if (TASK_SUCCESS != err_code)
      {
          fun2();
          fun3();
          return;
      }
  
      // 轮询邮箱
      for(...) {
          if (!isValid) {
              continue;
          }
          err_code = fun1(i);
          if (TASK_SUCCESS != err_code)
          {
              fun2();
              fun3();
              return;
          }
      }
  
      return ;
  }
  
  INT32 preProcess(ReadControlBlock *readcb) // 60行
  {
      for(UINT32 mailboxIndex = 0; mailboxIndex < MAX_MAIL_BOX_CNT; mailboxIndex++) {
          fun4~8()// 20行代码
      }
      return TASK_SUCCESS;
  }
  
  ```

  例3：错误码

  ```
  
  ```

  

  

  例4：关注cte_task->out_merge_temp_dir_path的赋值情况，一大堆重复代码，可读性极差，基本记不住，没有一点重构意识，阅读和修改这样的代码简直是灾难

  ```C
  UINT32 mc_fill_cte_merge_task_info()
  {
      //若为纯加密
      if (...)
      {
          ret = fun1();
          return;
      }
  
      //obs纯抽帧场景
      if (...) {
          (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path, sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
      }
  
      // 如果存在转码且配置+消息传递的加密开关均为开，则创建本地目录(抽帧截图不需要本地目录)
      if (...)
      {
          fun2();
      }
  }	
  
  UINT32 fun1()
  {
      //NFS+OBS+ENCRYPT 场景
      if (...)
      {
          (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                                sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
      }
      //NFS+ENCRYPT 场景
      else
      {
          (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                                sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
      }
  
      return;
  }
  
  VOID fun2()
  {
      //NFS+OBS+ENCRYPT 场景
      if (...)
      {
          (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                                sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
      }
      //NFS+OBS 场景
      else if (...)
      {
          (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                                sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
      }
      //NFS+ENCRYPT 场景
      else if (...)
      {
          (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                                sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
      }
      //NFS 场景
      else
      {
          //如果是数字水印，则不能取最终的输出目录
          if (...)
          {
              (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                  sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
          }
          else
          {
              (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                  sizeof(cte_task->out_merge_temp_dir_path), "%s", cte_task->out_merge_dir_path);
          }
      }
  }
  ```

  按代码逻辑重构：（目前未重构）

  ```c
  
  UINT32 mc_fill_cte_merge_task_info()
  {
  	set_out_merge_temp_dir_path();
  }
  
  void out_merge_temp_dir_path()
  {
  	//NFS 场景&&非数字水印
  	if(...) {
  		(VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                  sizeof(cte_task->out_merge_temp_dir_path), "%s", cte_task->out_merge_dir_path);
  	} else{
           (VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                  sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
      }
  }
  ```

  了解业务后重构：(只是猜想，不了解业务)

  ```C
  
  UINT32 mc_fill_cte_merge_task_info()
  {
  	(VOID)CTE_STR_SPRINTF(cte_task->out_merge_temp_dir_path,
                  sizeof(cte_task->out_merge_temp_dir_path), "%s/%u/", g_tmp_media_dir, cte_task->unique_id);
  }
  ```

  例4：merge拼接文件名（大量重复代码、没有抽取函数的极致，无法阅读，无法修改）

  ```
  
  ```

  

## 无效代码

- 头文件
- 打印
- tagMC_DP_MSG_TYPE_EN
- 

## 类型转换

## ctm->cte->imeda 

- 建议cte尽量用imedia枚举，ctm不能统一则在cte做转换
- ctm下发模板参数已做保证的逻辑，cte不做复杂的校验，用例保障
- 相关代码
  - xcode_common.h  
  - conver_struct.c  
  - tc_enum.h

## 抽出业务无关的公共代码->utils

- 字符串操作

## 邮箱

- index

## 临时目录混乱

## 任务ID（问题定位）

1. 能表示分片转码合并
2. 易搜索不要中括号，例如ID=11111
3. 保证每条日志都带uniqueid，能提供统一接口方便编码
4. 能否实现withfield，带上基本的信息，也不用每个函数传taskccb

## 其他待优化

- obs并行上传
- task remove 关掉后，tmp_media 会有重复，obs会上传老文件
- 没有删除字幕与水印的临时文件

## 错误处理

- 考虑使用goto简化代码
- 规划化设置错误码

## 统一代码规范（参考公司最新规范）

- 头文件包含
  - 在头文件里包含，不要在c文件里依赖顺序
- if else

# C语言代码规范

建议5.5