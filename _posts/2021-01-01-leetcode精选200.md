目标：1.算法，2.技巧   3. 手写  4.总结（在一年后也能快速捡起来）

难点：1.算法想不到 2.技巧记不住  3.手写细节很多，容易遗漏 

切记避免：记不住的硬想，浪费很多时间，不熟练写代码浪费很多时间

方法：第一阶段：快速，多遍过算法 ，过三遍，不写代码，只看代码，写总结，1个月

		   第二阶段：手写，三遍，15天

为什么一道题可以用两三个小时？时间都花在哪里了？

	1，理解各种方法，找到最简洁，通用，便于总结和记忆的方法

2. 总结
3. 手写
如何改进？比如297花了花了3个小时

计划：工作日每天3~4道题。周末每天10~15道题。一个月150~200道题。
日期	计划	题目数	
0103		9道	
0106		6道	
0113		7道	
0117		7道	
0121		3道	
0124			
计划：工作日每天3~4道题。周末每天10~15道题。一个月150~200道题。
记录
精选200
1. 字符串
1.1 字符串循环移位包含
1.2 字符串循环位移
1.3 字符串中单词的翻转
1.4 242.两个字符串包含的字符是否完全相同(Hard)
1.5 409.计算一组字符集合可以组成的回文字符串的最大长度 (Easy)
1.6 205.字符串同构(Easy)
1.7 647.回文子字符串个数 (Medium)
1.8 9.判断一个整数是否是回文数 (Easy)
1.9 696.统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数(Easy)
1.10 5.最长 回文子串(Medium)
1.11 14.最长公共前缀(easy)
1.12 17.电话号码的字母组合(Medium)
1.13 344. 反转字符串(Easy)
1.14 38. 外观数列(Easy)
1.15 125. 验证回文串(Easy)
1.16 387. 字符串中的第一个唯一字符(Easy)
1.17 7. 整数反转 gzl
1.18 151. 翻转字符串里的单词 gzl
1.19 179. 最大数 gzl
2. 哈希表
2.1 1.数组中两个数的和为给定值(Easy)
2.2 217.判断数组是否含有重复元素(Easy)
2.3 594.最长和谐序列(Easy)
2.4 128.最长连续序列(Hard)
2.5 49. 字母异位词分组(Medium)
3. 链表
3.1 链表相交
3.1.1 160.找出两个链表的交点(Easy)
3.1.2 面试题 02.08. 环路检测          gzl
3.2 链表倒数节点
3.2.1 面试题 02.02. 返回倒数第 k 个节点 gzl
3.3 链表翻转
3.3.1 206.链表反转(Easy)
3.3.2 24.交换链表中的相邻结点(Medium)
3.3.3 234.回文链表(Easy)
3.3.4 92. 反转链表 II gzl
3.3.5 25. K 个一组翻转链表(Hard) gzl
3.3.6 143. 重排链表gzl
3.4 合并有序链表
3.4.1 21.归并两个有序的链表(Easy)
3.4.2 23. 合并K个升序链表(Hard) gzlwg
3.5 删除链表节点
3.5.1 83.从有序链表中删除重复节点(Easy)
3.5.2 82. 删除排序链表中的重复元素 II(Medium) gzl
3.5.3 19.删除链表的倒数第 n 个节点(Medium)
3.5.4 剑指 Offer 18. 删除链表的节点gzl
3.6 链表排序
3.6.1 148. 排序链表gzl
3.7 链表求和
3.7.1 2. 两数相加
3.7.2 445.链表求和(Medium)
3.10 725.分隔链表(Medium)
3.11 328.链表元素按奇偶聚集(Medium)
4. 数组与矩阵
4.1 283.把数组中的 0 移到末尾(Easy)
4.2 566.改变矩阵维度(Easy)
4.3 485.找出数组中最长的连续1(Easy)
4.4 240.有序矩阵查找(Medium)
4.5 378.有序矩阵的 Kth Element(Medium)
4.6 645.一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数（重复一次）(Easy)
4.7 287.找出数组中重复的数，数组值在 [1, n] 之间（可重复多次）(Medium)
4.9 697.数组的度(Easy)
4.10 766.对角元素相等的矩阵(Easy)
4.11 565.嵌套数组(Medium)
4.12 769. 最多能完成排序的块(Medium) 频率低
4.13 面试题 10.01. 合并排序的数组
4.14 54. 螺旋矩阵 gzl 
4.15 59. 螺旋矩阵 II gzl
4.17 48. 旋转图像 gzl
4.20 剑指 Offer 51. 数组中的逆序对 gzl  hard 先放弃
4.20 31. 下一个排列 gzl  0405 17:18  32分钟
4.21 560. 和为K的子数组 gzlkl 0405 17:54
5. 栈与队列
5.1 232. 用栈实现队列(Easy)
5.2 225. 用队列实现栈(Easy)
5.3 252. 会议室(Easy)低频
5.4 155. 最小栈(Easy)
5.5 20. 有效的括号(Easy)
5.6 739. 每日温度(Medium)：数组中元素与下一个比它大的元素之间
5.7 227. 基本计算器 II(Easy)
6. 树
6.1 递归
6.1.1104. 二叉树的最大深度(Easy)
6.1.2 110. 平衡二叉树(Easy)
6.1.3 543. 二叉树的直径(Easy)(节点最大长度)
6.1.4 226. 翻转二叉树(Easy)
6.1.5 617. 合并二叉树(Easy)
6.1.6 112. 路径总和(Easy)
6.1.7 113. 路径总和 II gzl
6.1.7 437. 路径总和 III(Medium)（看不懂）
6.1.8 572. 另一个树的子树(Easy)
6.1.9 101. 对称二叉树(Easy)
6.1.10 111. 二叉树的最小深度(Easy)
6.1.11 404. 左叶子之和(Easy)
6.1.12 687. 最长同值路径(Medium)
6.1.13 337. 打家劫舍 III(Medium)-间隔遍历-todo动态规划
6.1.14 671. 二叉树中第二小的节点(Easy)
6.1.15 114. 二叉树展开为链表 gzl
6.1.16 105. 从前序与中序遍历序列构造二叉树 gzl
6.1.17 222. 完全二叉树的节点个数 gzl
6.1.18 剑指 Offer 36. 二叉搜索树与双向链表 gzl
6.2 层次遍历 
6.2.1 637. 二叉树的层平均值(Easy)
6.2.2 513. 找树左下角的值(Easy)
6.2.3 102. 二叉树的层序遍历 gzl
6.2.4 103. 二叉树的锯齿形层序遍历 gzl
6.2.5 104. 二叉树的最大深度 gzl
6.2.6 199. 二叉树的右视图 gzlkl
6.2.7 297. 二叉树的序列化与反序列化 gzl
6.2.8 449. 序列化和反序列化二叉搜索树  gzl
6.2.9863. 二叉树中所有距离为 K 的结点 gzlkl
6.2.10 124. 二叉树中的最大路径和 gzl
6.2.11 590. N 叉树的后序遍历 gzlkl
6.2.12 98. 验证二叉搜索树 gzl
6.2.13 450. 删除二叉搜索树中的节点 gzl
6.3 前中后序遍历
6.3.1 144. 二叉树的前序遍历(Medium)
6.3.2 145. 二叉树的后序遍历(Medium)
6.3.3 94. 二叉树的中序遍历(Medium)
6.4 二叉查找树（BST）
6.4.1 669. 修剪二叉搜索树(Medium)
6.4.2 230. 二叉搜索树中第K小的元素(Medium)
6.4.3 538. 把二叉搜索树转换为累加树(Medium)
6.4.4 235. 二叉搜索树的最近公共祖先(Easy)
6.4.5 236. 二叉树的最近公共祖先(Medium)
6.4.6 108. 将有序数组转换为二叉搜索树(Easy)
6.4.7 109. 有序链表转换二叉搜索树(Medium)
6.4.8 653. 两数之和 IV - 输入 BST(Easy)
6.4.9 530. 二叉搜索树的最小绝对差(Easy)
6.4.10 501. 二叉搜索树中的众数(Easy)
6.4.1196. 不同的二叉搜索树gzl
6.5 Trie
6.5.1 208. 实现 Trie (前缀树)(Medium)
6.5.2 677. 键值映射(Medium)
7.图
7.1 二分图
7.1.1 785. 判断二分图(Medium)
7.2 拓扑排序
7.2.1 207. 课程表(Medium)
7.2.2 210. 课程表 II(Medium)
7.3 并查集 
7.3.1 684. 冗余连接(Medium)
8.位运算
8.0 基本原理 
8.1 461. 汉明距离(Easy)(二进制不同位数)
8.2 136. 只出现一次的数字(Easy)
8.3 268. 丢失的数字(Easy)
8.4 260. 只出现一次的数字 III(Medium)
8.5 190. 颠倒二进制位(Easy)
8.6 不用额外变量交换两个整数(程序员代码面试指南P317)
8.7 231. 2的幂(Easy)
8.8 342. 4的幂(Easy)
8.9 693. 交替位二进制数(Easy)
8.10 476. 数字的补数(Easy)(看不懂，出现频率很低)
9. 双指针
9.1 167. 两数之和 II - 输入有序数组(Easy)
9.2 633. 平方数之和(Medium)
9.3 345. 反转字符串中的元音字母(Easy)
9.4 680. 验证回文字符串 Ⅱ(Easy)
9.5 88. 合并两个有序数组(Easy)
9.6 141. 环形链表(Easy)
9.7 524. 通过删除字母匹配到字典里最长单词(Medium)
9.8 15. 三数之和
9.9 16. 最接近的三数之和 gzl
9.10 18. 四数之和 gzl
9.11 4. 寻找两个正序数组的中位数 gzl tx
9.12 42. 接雨水 gzl
9.13 43. 字符串相乘 gzlkl
9.20 滑动窗口
9.20.1 28. 实现 strStr()(Easy)
9.20.2 340. 至多包含 K 个不同字符的最长子串(Medium)
9.20.3 3.无重复字符的最长字串(Medium)
9.20.4 30. 串联所有单词的子串(Hard)
9.20.5 76.最小覆盖子串(Hard)
9.20.6 159. 至多包含两个不同字符的最长子串(Medium)
9.20.7 209. 长度最小的子数组(Medium)
9.20.8 239. 滑动窗口最大值(Hard)
9.20.9 567. 字符串的排列(Medium)
9.20.10 395. 至少有 K 个重复字符的最长子串gzlkl
10.排序
10.1 快速排序 215. 数组中的第K个最大元素(Medium)
10.3 桶排序
10.3.1 347. 前 K 个高频元素(Meidum)
10.3.2 451. 根据字符出现频率排序(Medium)
10.4 荷兰国旗问题
10.4.1 75. 颜色分类(Medium)
11. 二分查找
11.1 69. x 的平方根(Easy)
11.2 744. 寻找比目标字母大的最小字母(Easy)
11.3 540. 有序数组中的单一元素(Medium)
11.4 278. 第一个错误的版本(Easy)
11.5 153. 寻找旋转排序数组中的最小值(Medium)
11.6 34. 在排序数组中查找元素的第一个和最后一个位置(Medium) 0222
11.7 704. 二分查找(Easy)
11.8 35. 搜索插入位置(Easy)
11.9 33. 搜索旋转排序数组(Medium)
11.10 剑指 Offer 53 - II. 0～n-1中缺失的数字 gzl
12. 搜索
12.1 BFS
12.1.1 1091. 二进制矩阵中的最短路径(Medium)
12.1.2 279. 完全平方数(Medium)
12.1.3 127. 单词接龙(Hard)
12.2 DFS
12.2.1 695. 岛屿的最大面积(Medium)
12.2.2 200. 岛屿数量(Medium)  0223
12.2.3 463. 岛屿的周长 gzl
12.2.3 547. 省份数量(Medium)
12.2.4 130. 被围绕的区域(Medium) 0223
12.2.5 417. 太平洋大西洋水流问题(Medium)
12.3 Backtracking
12.3.1 17. 电话号码的字母组合(Medium)
12.3.2 93. 复原IP地址(Medium)
12.3.3 79. 单词搜索(Medium)
12.3.4 257. 二叉树的所有路径(Easy)
12.3.5 46. 全排列(Medium) 0224
12.3.6 47. 全排列 II(Medium)
12.3.7 77. 组合(Medium)
12.3.8  39. 组合总和(Medium)
12.3.9 40. 组合总和 II(Medium) todo
12.3.10 216. 组合总和 III(Medium) 0227
12.3.11 78. 子集(Medium) 0227
12.3.12 90. 子集 II(Medium)
12.3.13 131. 分割回文串(Medium)
12.3.14 37. 解数独(Hard) 0228
12.3.15 51. N 皇后(Hard)
13. 分治
13.1 241. 为运算表达式设计优先级(Medium) 0226delay0228
13.2 95. 不同的二叉搜索树 II(Medium) 0226 delay 0301
14. 贪心思想
14.1 455. 分发饼干(Easy)
14.2 435. 无重叠区间(Medium)
14.2.2 56. 合并区间 gzl
14.2.357. 插入区间 gzl
14.3 452. 用最少数量的箭引爆气球(Medium) 
14.4 406. 根据身高重建队列(Medium)
14.5 121. 买卖股票的最佳时机(Easy)
14.6  122. 买卖股票的最佳时机 II(Easy) 0227 0302
14.7 605. 种花问题(Easy)
14.8 392. 判断子序列(Easy)
14.9 665. 非递减数列(Easy) 0302
14.10 53. 最大子序和(Easy) 0303
14.11 763. 划分字母区间(Medium)
14.12 45. 跳跃游戏 II gzlkl
15. 动态规划
15.1 斐波那契数列
15.1.1 70. 爬楼梯
15.1.2 198. 打家劫舍(Medium)
15.1.3 213. 打家劫舍 II(Medium)
15.1.4 信件错排
15.1.5 母牛生产（程序员代码面试指南-P181）
15.1.6 55. 跳跃游戏 gzlkl 
15.2 矩阵路径
15.2.1 64. 最小路径和(Medium)
15.2.2 62. 不同路径(Medium)
15.2.3 63. 不同路径 II gzl
15.3 数据区间
15.3.1 303. 区域和检索 - 数组不可变(Easy)
15.3.2 413. 等差数列划分(Medium)
15.3.3 1191. K 次串联后最大子数组之和 gzl
15.4 分割整数
15.4.1 343. 整数拆分(Medium) 0306
15.4.2 279. 完全平方数(Medium)
15.3.4 152. 乘积最大子数组 gzl
15.3.5 264. 丑数 II gzl
15.4.3 91. 解码方法(Medium)
15.5 最长递增子序列
15.5.1 300. 最长递增子序列(Medium)
15.5.2 646. 最长数对链(Medium) 
15.5.3 376. 摆动序列(Medium)
15.6 最长公共子序列
15.6.1 1143. 最长公共子序列(Medium) 
15.6.2 516. 最长回文子序列 gzlkl
15.6.3 剑指 Offer 14- I. 剪绳子 gzl
15.7 0-1背包
15.7.1 416. 分割等和子集(Medium)
15.7.2 494. 目标和(Medium)
15.7.3 474. 一和零(Medium) 
15.7.4 322. 零钱兑换(Medium) 
15.7.5 518. 零钱兑换 II(Medium)
15.7.6 139. 单词拆分(Medium)
15.7.7 377. 组合总和 Ⅳ(Medium) 0306
15.8 股票交易
15.8.1 309. 最佳买卖股票时机含冷冻期(Medium)
15.8.2 714. 买卖股票的最佳时机含手续费(medium)
15.8.3 123. 买卖股票的最佳时机 III(Hard)
15.8.4 188. 买卖股票的最佳时机 IV(Hard) 
15.9 字符串编辑
15.9.1 583. 两个字符串的删除操作(Medium)
15.9.2 72. 编辑距离(Hard)
15.9.3 650. 只有两个键的键盘(Medium) TODO 中高频，难想
15.9.4 10.正则表达式匹配(Hard) 0321
15.9.5 44. 通配符匹配(Hard)0307 0321done
15.10 括号问题
15.10.0  5.5 [20. 有效的括号(Easy)]
15.10.1 22.括号生成(Medium) 
15.10.2 32. 最长有效括号
16. 数学
16.1 素数分解
16.1.1 204. 计数质数(Easy)
16.1.2 最大公约数（貌似不考）
16.1.3 使用位操作和减法求解最大公约数 编程之美2.7（貌似不考）
16.2 进制转换
16.2.1 504. 七进制数(Easy)
16.2.2 405. 数字转换为十六进制数(Easy)
16.2.3 168. Excel表列名称(Easy) 0308
16.3 阶乘
16.3.1 172. 阶乘后的零(Easy)
16.4 字符串加法减法
16.4.1 67. 二进制求和(Easy)
16.4.2 415. 字符串相加(Easy)
16.5 相遇问题
16.5.1 462. 最少移动次数使数组元素相等 II(Medium)
16.6 多数投票问题
16.6.1 169. 多数元素(Easy) 0309 
16.7 其他
16.7.1 367. 有效的完全平方数(Easy)
16.7.2 326. 3的幂(Easy)(放弃，难记，频率低)
16.7.3 238. 除自身以外数组的乘积(Medium)
16.7.4 628. 三个数的最大乘积(Easy)
16.7.5 50. Pow(x, n) gzl
16.7.6 202. 快乐数 gzl
16.7.7 470. 用 Rand7() 实现 Rand10() gzl
16.7.8 263. 丑数 gzlkl
16.7.9 365. 水壶问题  gzl
16.13 8.字符串转换整数 (atoi)(Medium)
16.13 13. 罗马数字转整数(Easy) 0310 0323
17. 设计数据结构
17.1 146. LRU 缓存机制 gzl
17.2 460. LFU 缓存 gzl
17.3 剑指 Offer 09. 用两个栈实现队列 gzl
18. 多线程
18.1 1114. 按序打印 gzl
18.2 1116. 打印零与奇偶数gzl
19. 字节Hard
1259. 不相交的握手 卡特兰数
1044. 最长重复子串
30. 串联所有单词的子串
681. 最近时刻
440. 字典序的第K小数字
726. 原子的数量  看懂了没有写
135. 分发糖果  很牛逼
460. LFU缓存
1172. 餐盘栈
465. 最优账单平衡 dfs
407. 接雨水 II  Python默认是最小堆
786. 第 K 个最小的素数分数  与378很像
1274. 矩形内船只的数目
1012. 至少有 1 位重复的数字  数学问题，排列组合
317. 离建筑物最近的距离  BFS
862. 和至少为 K 的最短子数组  超时

记录
*：没有头绪<br />?：不是最优解<br />Y：过关	title	tag	note
？2021/1/3	1.1 字符串循环移位包含	字符串	
*2021/1/3	1.2 字符串循环位移	字符串	
?2021/1/3	1.3 字符串中单词的翻转	字符串	
?2020/9/3<br />?2021/1/3	1.4 两个字符串包含的字符是否完全相同	字符串	一开始判断长度不等则返回，可以省略最后遍历哈希表
?	1.5 计算一组字符集合可以组成的回文字符串的最大长度	字符串	
*2021/1/3	1.6 字符串同构	字符串	判断两个字符串的同一位置的字符上一个位置是否相同
*2021/1/3	1.7 回文子字符串个数	字符串	枚举每一个可能的回文中心，两个指针向两边拓展
*2021/1/3	1.8  判断回文数	字符串	
*2021/1/6	1.9 连续0，1组合子串个数	字符串	划分区间，记录每个区间长度，相邻区间长度最小值为子字符串连续01子字符串个数
21/1/24	1.10 最长回文子串	字符串	
21/1/24	1.11 最长公共前缀	字符串	
21/1/24	1.12 电话号码的字母组合	字符串	
21/1/25	1.12 电话号码的字母组合(Medium)]	字符串	
21/1/25	1.13 反转字符串	字符串	
21/1/25	1.14 外观数列	字符串	
21/1/25	1.15 验证回文串	字符串	
21/1/25	1.16 字符串的第一个唯一字符	字符串	
Y	2.1 数组中两个数的和为给定值	哈希表	
Y	2.2 判断数组是否含有重复元素	哈希表	
Y*2021/1/6	2.3 最长和谐序列	哈希表	
*2021/1/6	2.4 最长连续序列	哈希表	注意要求O(N)时间复杂度
*Y 2021/1/6	3.1 找出两个链表的交点	链表	a+c+b=b+c+a , a+b=b+a => null
*Y 2021/1/13	3.2 链表反转	链表	方法一头插法：两个指针即可；<br />方法二递归：反复思考，比较难掌握
？	3.3 归并两个有序的链表	链表	
？	3.4 从有序链表中删除重复节点	链表	注意：考虑到有3个以上等值，所以相等后不能直接移动cur指针；<br />递归：上一级已经返回去重的链表，想想这一级递归要干啥
*	3.5 删除链表的倒数第 n 个节点	链表	要注意删除的是第一个元素时的情况。快指针指向空
*2021/1/13	3.6 交换链表中的相邻结点	链表	利用头结点让代码没那么丑，网上很多用了4个指针，其实3个指针也可以
*2021/1/13	3.7 链表求和	链表	0113：算法简单，实现细节多
？2021/1/13	3.8 回文链表	链表	注意当结点总数为偶数是，中点是要下中点在翻转<br />0113：考虑O(1)空间复杂度，实现细节多
？2021/1/16	3.9 分割	链表	0116：关键是这里的商和余数是怎么用，想想这道题与除法的关系<br />
？2021/1/17	3.10 链表元素按奇偶聚集	链表	可以不需要判断奇偶，但是要注意循环边界<br />0116：每次循环就把改变两个指针，时间复杂度可以降低一半。另外注意循环结束第二个节点已经改变，不能用head.next表示第一个偶数节点
*2021/1/17	4.1 把数组中的 0 移到末尾	数组与矩阵	参考快排
?2021/1/17	4.2 改变矩阵维度	数组与矩阵	不难，多做几次
*2021/1/17	4.3 找出数组中最长的连续1	数组与矩阵	
y2021/1/17	4.4 有序矩阵查找	数组与矩阵	从左下或者右上开始都可以，因为左上/右下都是比当前元素都大/小，没法确定下一步如何走
*2021/1/17	4.5 有序矩阵的 Kth Element	数组与矩阵	（看不懂，先跳过）
*21/1/17	4.6 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数	数组与矩阵	数据是1~n，放到其下标位则可排序。。
*21/1/21	4.7 找出数组中重复的数，数组值在 [1, n] 之间（可重复多次）	数组与矩阵	（看不懂，先跳过）
4.8	数组与矩阵	没有看懂思路
*21/1/21	4.9 数组的度	数组与矩阵	没有想象中easy，需要考虑存在“度”相同的两个数，取最短的子串
*21/1/21	4.10 对角元素相等的矩阵		
21/1/25	5.10 基本计算器 II(Easy)		
21/12/18	9.6		
精选200
1. 字符串
1.1 字符串循环移位包含
题目：编程之美 3.1

	s1 = AABCD, s2 = CDAA
​	Return : true
​	给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。

解答：

	s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串
​	即可。

# 
str1 = 'AABCD'
str2 = 'CDAA'
str11 = 'AABCD' * 2
if str2 in str11:
    print("true")
else:
    print("false")
​
# 20210921：想不到，死记
1.2 字符串循环位移
题目：编程之美 2.17

	s = "abcd123" k = 3
​	Return "123abcd"
​	将字符串向右循环移动 k 位。

解答：

	将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。

读
str1 = 'abcd123'
reverse_last_index = 3
str11 = str1[-(reverse_last_index+1)::-1] # ？？如何读
str12 = str1[:-(reverse_last_index+1):-1]
ret = (str11+str12)[::-1]
print('ret:', ret)
​
# 2021901：右循环移动意思是右移
1.3 字符串中单词的翻转
程序员代码面试指南，题目：

	s = "I am a student"
​	Return "student a am I"

解答：

	将每个单词翻转，然后将整个字符串翻转。

"""
s = "I am a student"
Return "student a am I"
"""
str1 = "I am a student"
str_split = str1.split(' ')
for index, word in enumerate(str_split):
    str_split[index] = word[::-1] # 1：反转每个单词
ret = ' '.join(str_split)
print('ret:', ret[::-1]) # 2：反转整个句子
​
output:
ret: student a am I
1.4 242.两个字符串包含的字符是否完全相同(Hard)
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
​
        dict1 = {}
        for k,v in enumerate(s):
            if dict1.getOrElse(v) +=1 # ?
        for k,v in enumerate(t):
            if dict1.hasKey(v) = False:
                return False
            dict1[v] -= 1
        return True
    
"""
1.一开始判断长度不等则返回，可以省略最后遍历哈希表  
2.用fromKeys初始化哈希表可以省去判断in，但需要用ord得到字符哈希值 
3.由于保证了长度相等，若s和t不是字母异或词，则肯定出现t有的字母s没有，因此一定会出现哈希表count数值小于0情况，可以省略最后遍历哈希表count是否全为0的这一步骤
"""
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
​
        dict1 = dict.fromkeys(range(26), 0)
        for k,v in enumerate(s):
            dict1[ord(v) - ord('a')] += 1
        for k,v in enumerate(t):
            dict1[ord(v) - ord('a')] -= 1
            if dict1[ord(v) - ord('a')] < 0:
                return False
​
        return True
1.5 409.计算一组字符集合可以组成的回文字符串的最大长度 (Easy)
Input : "abccccdd"
Output : 7
Explanation : One longest palindrome that can be built is "dccaccd", whose length

class Solution:
    def longestPalindrome(self, s: str) -> int:
        wordCnt = dict.fromkeys(range(256), 0)

        for k,v in enumerate(s):
            wordCnt[ord(v)] += 1

        hasOdd = False
        len = 0
        for v in wordCnt.values():
            num = v // 2
            mod = v % 2

            len += num * 2
            if mod > 0:
                hasOdd = True

        return len + (1 if hasOdd else 0)
class Solution:
    def longestPalindrome(self, s: str) -> int:
        wordCnt = dict.fromkeys(range(256), 0)
​
        for k,v in enumerate(s):
            wordCnt[ord(v)] += 1
​
        hasOdd = False
        len = 0
        for v in wordCnt.values():
            num = v // 2
            mod = v % 2
​
            len += num * 2
            if mod > 0:
                hasOdd = True
​
        return len + (1 if hasOdd else 0)
1.6 205.字符串同构(Easy)
给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

示例 1:

输入：s = "egg", t = "add"
输出：true
示例 2：

输入：s = "foo", t = "bar"
输出：false
示例 3：

输入：s = "paper", t = "title"
输出：true

"""
记录映射关系代码不好写，就死记这种方法。
记住：字符串同构：同一位置上的字符上次出现为位置相同。
"""
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
​
        preIndex1 = dict.fromkeys(range(256), -1)
        preIndex2 = dict.fromkeys(range(256), -1)
​
        for i in range(len(s)):
            if preIndex1[ord(s[i])] != preIndex2[ord(t[i])]:
                return False
            preIndex1[ord(s[i])] = i
            preIndex2[ord(t[i])] = i
        return True
1.7 647.回文子字符串个数 (Medium)
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例 1：

输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"

示例 2：

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

"""
中心拓展法：
时间复杂度：O(n^2)
空间复杂度：O(1)
"""
class Solution:
    def countSubstrings(self, s: str) -> int:
        cnt = 0
        for i in range(len(s)):
            cnt += self.extendCountSubString(s, i, i)
            cnt += self.extendCountSubString(s, i, i+1)
        return cnt
​
    def extendCountSubString(self, s:str, start:int, end:int)-> int:
        cnt = 0
        while start >= 0 and end < len(s) and s[start] == s[end]:
            cnt += 1
            start -= 1
            end += 1
        return cnt
"""
Manacher 算法：
时间复杂度：O(n)
空间复杂度：O(n)
todo：
"""
​
1.8 9.判断一个整数是否是回文数 (Easy)
示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。

# 方法一：python语法糖
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 :
            return False
        l1 = list(str(x))
        f, b = 0, len(l1) - 1
        while f < b and l1[f] == l1[b]:
            f += 1
            b -= 1 
        return True if f >=b else False
"""
方法二：传统方法
1.想想如何翻转一个数
"""
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x == 0:
            return True
        if x < 0 or x % 10 == 0:
            return False

        right = 0
        while x > right:
            right = right * 10 + x % 10
            x = x // 10

        return  x == right or x == right // 10
1.9 696.统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数(Easy)
给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

示例 1 :

输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
示例 2 :

输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

# 方法一：思路：划分区间，记录每个区间长度，相邻区间长度最小值则为这两个区间组成的字符串连续1,0数量相同的子字符串个数。
#       举例：00111
#				相同数量子串有2个：0011,01
#				也就是两个区间长度{2,3}的最小值2
# 		实现技巧，只用 lastLen 保留上一个区间的长度，得到当前区间长度 curLen，ans += min(lastLen,curLen)
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        i, n, ret, lastLen = 0, len(s), 0, 0
        while i < n:
            curLen = 0
            c = s[i]
            while i < n and s[i] == c:
                curLen += 1
                i += 1
            ret += min(lastLen, curLen)
            last = curLen
        return ret
1.10 5.最长 回文子串(Medium)
给你一个字符串 s，找到 s 中最长的回文子串。

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
示例 3：

输入：s = "a"
输出："a"
示例 4：

输入：s = "ac"
输出："a"

"""
与《1.7 647 回文子字符串个数》 的回文判断一样，只是结果输出不一样，一个数输出个数，一个是输出最长回文串。
回文判断：中间

"""
1.11 14.最长公共前缀(easy)
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1：

输入：strs = ["flower","flow","flight"]
输出："fl"
示例 2：

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。

"""
官方提供了4种解答，没有特别优的方法。
就记住两种暴力法：

1. 横向扫描 
时间复杂度：O(mn)。其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。
空间复杂度：O(1) 使用的额外空间复杂度为常数。

2. 纵向扫描（复杂度与横向扫描一样）

"""
1.12 17.电话号码的字母组合(Medium)
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

image-20210124190603302

示例:

输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

"""
注意：输入字符串不限长度。可以时间复杂度是O(a^N)。这种复杂度用回溯法穷尽，具体用递归实现。
"""
TODO

1.13 344. 反转字符串(Easy)
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

"""太简单了吧。。"""
1.14 38. 外观数列(Easy)
1

11

21

1211

111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"

示例 1：

输入：n = 1
输出："1"
解释：这是一个基本样例。
示例 2：

输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"

"""
todo
"""
1.15 125. 验证回文串(Easy)
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

输入: "A man, a plan, a canal: Panama"
输出: true

"""
todo
"""
1.16 387. 字符串中的第一个唯一字符(Easy)
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

示例：

s = "leetcode"
返回 0

s = "loveleetcode"
返回 2

"""
todo
"""
1.17 7. 整数反转 gzl
class Solution:
    def reverse(self, x: int) -> int:
        max= math.pow(2,31)-1
        min =-math.pow(2,31)

        ans = 0
        while x!=0 :
            tmp = x % 10 if x >= 0 else x % (-10)	# python 没有溢出，需要取余需要判断正负
            x = x // 10 if x >= 0 else int(x / 10) # 除以10。负数向上取整，正数向下取整
            if max-tmp < ans*10 or ans*10 < min-tmp:
                return 0
            ans = ans*10+tmp
        return ans
1.18 151. 翻转字符串里的单词 gzl
class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.strip() # 删除首尾空格
        strs = s.split() # 分割字符串
        strs.reverse() # 翻转单词列表
        return ' '.join(strs) # 拼接为字符串并返回
1.19 179. 最大数 gzl
2. 哈希表
2.1 1.数组中两个数的和为给定值(Easy)
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dict1 = {}
        for k,v in enumerate(nums):
            if target - v not in dict1:
                dict1[v] = k
            else:
                return [dict1[target - v], k]
        return None
2.2 217.判断数组是否含有重复元素(Easy)
示例 1:

输入: [1,2,3,1]
输出: true
示例 2:

输入: [1,2,3,4]
输出: false
示例 3:

输入: [1,1,1,3,3,4,3,2,4,2]
输出: true

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        dict1 = {}
        for k, v in enumerate(nums):
            if v in dict1:
                return True
            dict1[v] = 1
        return False
2.3 594.最长和谐序列(Easy)
和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1

示例 1:

输入: [1,3,2,2,5,2,3,7]
输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        dicts = {}
        for v in nums:
            dicts[v] = dicts.get(v, 0) + 1

        ret = 0
        for key, value in dicts.items():
            if key + 1 in dicts:
                ret = max(dicts[key + 1] + value, ret)
        return ret
2.4 128.最长连续序列(Hard)
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

要求：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？

示例 1： 

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums = [0,3,7,2,5,8,4,6,0,1] 
输出：9

# 注意要求O(N)
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums_set = set(nums)
        ret = 0
        for v in nums_set:
            if v - 1 not in nums_set: # 最长序列的第一个值v，v-1必定不存，因此检查是否存在v-1即可判断是否跳过
                count = 1
