目标：1.算法，2.技巧   3. 手写  4.总结（在一年后也能快速捡起来）

难点：1.算法想不到 2.技巧记不住  3.手写细节很多，容易遗漏 

切记避免：记不住的硬想，浪费很多时间，不熟练写代码浪费很多时间

方法：第一阶段：快速，多遍过算法 ，过三遍，不写代码，只看代码，写总结，1个月

​		   第二阶段：手写，三遍，15天



为什么一道题可以用两三个小时？时间都花在哪里了？

​	1，理解各种方法，找到最简洁，通用，便于总结和记忆的方法

	2. 总结
	3. 手写

如何改进？比如297花了花了3个小时



#  计划：工作日每天3~4道题。周末每天10~15道题。一个月150~200道题。



| 日期 | 计划 | 题目数 |      |
| ---- | ---- | ------ | ---- |
| 0103 |      | 9道    |      |
| 0106 |      | 6道    |      |
| 0113 |      | 7道    |      |
| 0117 |      | 7道    |      |
| 0121 |      | 3道    |      |
| 0124 |      |        |      |
|      |      |        |      |
|      |      |        |      |
|      |      |        |      |





[TOC]



# 记录

| *：没有头绪<br />?：不是最优解<br />Y：过关 | title                                                        | tag        | note                                                         |
| ------------------------------------------- | :----------------------------------------------------------- | ---------- | ------------------------------------------------------------ |
| ？2021/1/3                                  | 1.1 字符串循环移位包含                                       | 字符串     |                                                              |
| *2021/1/3                                   | 1.2 字符串循环位移                                           | 字符串     |                                                              |
| ?2021/1/3                                   | 1.3 字符串中单词的翻转                                       | 字符串     |                                                              |
| ?2020/9/3<br />?2021/1/3                    | 1.4 两个字符串包含的字符是否完全相同                         | 字符串     | 一开始判断长度不等则返回，可以省略最后遍历哈希表             |
| ?                                           | 1.5 计算一组字符集合可以组成的回文字符串的最大长度           | 字符串     |                                                              |
| *2021/1/3                                   | 1.6 字符串同构                                               | 字符串     | 判断两个字符串的同一位置的字符上一个位置是否相同             |
| *2021/1/3                                   | 1.7 回文子字符串个数                                         | 字符串     | 枚举每一个可能的回文中心，两个指针向两边拓展                 |
| *2021/1/3                                   | 1.8  判断回文数                                              | 字符串     |                                                              |
| *2021/1/6                                   | 1.9 连续0，1组合子串个数                                     | 字符串     | 划分区间，记录每个区间长度，相邻区间长度最小值为子字符串连续01子字符串个数 |
| 21/1/24                                     | 1.10 最长回文子串                                            | 字符串     |                                                              |
| 21/1/24                                     | 1.11 最长公共前缀                                            | 字符串     |                                                              |
| 21/1/24                                     | 1.12 电话号码的字母组合                                      | 字符串     |                                                              |
| 21/1/25                                     | 1.12 电话号码的字母组合(Medium)]                             | 字符串     |                                                              |
| 21/1/25                                     | 1.13 反转字符串                                              | 字符串     |                                                              |
| 21/1/25                                     | 1.14 外观数列                                                | 字符串     |                                                              |
| 21/1/25                                     | 1.15 验证回文串                                              | 字符串     |                                                              |
| 21/1/25                                     | 1.16 字符串的第一个唯一字符                                  | 字符串     |                                                              |
| Y                                           | 2.1 数组中两个数的和为给定值                                 | 哈希表     |                                                              |
| Y                                           | 2.2 判断数组是否含有重复元素                                 | 哈希表     |                                                              |
| Y*2021/1/6                                  | 2.3 最长和谐序列                                             | 哈希表     |                                                              |
| *2021/1/6                                   | 2.4 最长连续序列                                             | 哈希表     | 注意要求O(N)时间复杂度                                       |
| *Y 2021/1/6                                 | 3.1 找出两个链表的交点                                       | 链表       | a+c+b=b+c+a , a+b=b+a => null                                |
| *Y 2021/1/13                                | 3.2 链表反转                                                 | 链表       | 方法一头插法：两个指针即可；<br />方法二递归：反复思考，比较难掌握 |
| ？                                          | 3.3 归并两个有序的链表                                       | 链表       |                                                              |
| ？                                          | 3.4 从有序链表中删除重复节点                                 | 链表       | 注意：考虑到有3个以上等值，所以相等后不能直接移动cur指针；<br />递归：上一级已经返回去重的链表，想想这一级递归要干啥 |
| *                                           | 3.5 删除链表的倒数第 n 个节点                                | 链表       | 要注意删除的是第一个元素时的情况。快指针指向空               |
| *2021/1/13                                  | 3.6 交换链表中的相邻结点                                     | 链表       | 利用头结点让代码没那么丑，网上很多用了4个指针，其实3个指针也可以 |
| *2021/1/13                                  | 3.7 链表求和                                                 | 链表       | 0113：算法简单，实现细节多                                   |
| ？2021/1/13                                 | 3.8 回文链表                                                 | 链表       | 注意当结点总数为偶数是，中点是要下中点在翻转<br />0113：考虑O(1)空间复杂度，实现细节多 |
| ？2021/1/16                                 | 3.9 分割                                                     | 链表       | 0116：关键是这里的商和余数是怎么用，想想这道题与除法的关系<br /> |
| ？2021/1/17                                 | 3.10 链表元素按奇偶聚集                                      | 链表       | 可以不需要判断奇偶，但是要注意循环边界<br />0116：每次循环就把改变两个指针，时间复杂度可以降低一半。另外注意循环结束第二个节点已经改变，不能用head.next表示第一个偶数节点 |
| *2021/1/17                                  | 4.1 把数组中的 0 移到末尾                                    | 数组与矩阵 | 参考快排                                                     |
| ?2021/1/17                                  | 4.2 改变矩阵维度                                             | 数组与矩阵 | 不难，多做几次                                               |
| *2021/1/17                                  | 4.3 找出数组中最长的连续1                                    | 数组与矩阵 |                                                              |
| y2021/1/17                                  | 4.4 有序矩阵查找                                             | 数组与矩阵 | 从左下或者右上开始都可以，因为左上/右下都是比当前元素都大/小，没法确定下一步如何走 |
| *2021/1/17                                  | 4.5 有序矩阵的 Kth Element                                   | 数组与矩阵 | （看不懂，先跳过）                                           |
| *21/1/17                                    | 4.6 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数 | 数组与矩阵 | 数据是1~n，放到其下标位则可排序。。                          |
| *21/1/21                                    | 4.7 找出数组中重复的数，数组值在 [1, n] 之间（可重复多次）   | 数组与矩阵 | （看不懂，先跳过）                                           |
|                                             | 4.8                                                          | 数组与矩阵 | 没有看懂思路                                                 |
| *21/1/21                                    | 4.9 数组的度                                                 | 数组与矩阵 | 没有想象中easy，需要考虑存在“度”相同的两个数，取最短的子串   |
| *21/1/21                                    | 4.10 对角元素相等的矩阵                                      |            |                                                              |
| 21/1/25                                     | 5.10 基本计算器 II(Easy)                                     |            |                                                              |
|                                             |                                                              |            |                                                              |
| 21/12/18                                    | 9.6                                                          |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |
|                                             |                                                              |            |                                                              |





# 精选200

# 1. 字符串

## 1.1 字符串循环移位包含



>题目：编程之美 3.1
>
>​	s1 = AABCD, s2 = CDAA
>​	Return : true
>​	给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。
>
>解答：
>
>​	s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串
>​	即可。

```PYTHON
str1 = 'AABCD'
str2 = 'CDAA'
str11 = 'AABCD' * 2
if str2 in str11:
    print("true")
else:
    print("false")

# 20210921：想不到，死记
```



## 1.2 字符串循环位移

>题目：编程之美 2.17
>
>​	s = "abcd123" k = 3
>​	Return "123abcd"
>​	将字符串向右循环移动 k 位。
>
>解答：
>
>​	将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。

```PYTHON
str1 = 'abcd123'
reverse_last_index = 3
str11 = str1[-(reverse_last_index+1)::-1] # ？？如何读
str12 = str1[:-(reverse_last_index+1):-1]
ret = (str11+str12)[::-1]
print('ret:', ret)

# 2021901：右循环移动意思是右移
```



## 1.3 字符串中单词的翻转

>程序员代码面试指南，题目：
>
>​	s = "I am a student"
>​	Return "student a am I"
>
>解答：
>
>​	将每个单词翻转，然后将整个字符串翻转。

```python
"""
s = "I am a student"
Return "student a am I"
"""
str1 = "I am a student"
str_split = str1.split(' ')
for index, word in enumerate(str_split):
    str_split[index] = word[::-1] # 1：反转每个单词
ret = ' '.join(str_split)
print('ret:', ret[::-1]) # 2：反转整个句子

output:
ret: student a am I
```



## 1.4 [242.两个字符串包含的字符是否完全相同(Hard)](https://leetcode-cn.com/problems/valid-anagram/)

>给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。
>
>s = "anagram", t = "nagaram", return true.
>s = "rat", t = "car", return false.

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        dict1 = {}
        for k,v in enumerate(s):
            if dict1.getOrElse(v) +=1 # ?
        for k,v in enumerate(t):
            if dict1.hasKey(v) = False:
                return False
            dict1[v] -= 1
        return True
    
"""
1.一开始判断长度不等则返回，可以省略最后遍历哈希表  
2.用fromKeys初始化哈希表可以省去判断in，但需要用ord得到字符哈希值 
3.由于保证了长度相等，若s和t不是字母异或词，则肯定出现t有的字母s没有，因此一定会出现哈希表count数值小于0情况，可以省略最后遍历哈希表count是否全为0的这一步骤
"""
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        dict1 = dict.fromkeys(range(26), 0)
        for k,v in enumerate(s):
            dict1[ord(v) - ord('a')] += 1
        for k,v in enumerate(t):
            dict1[ord(v) - ord('a')] -= 1
            if dict1[ord(v) - ord('a')] < 0:
                return False

        return True
```

## 1.5 [409.计算一组字符集合可以组成的回文字符串的最大长度 (Easy)](https://leetcode-cn.com/problems/longest-palindrome/description/)

>Input : "abccccdd"
>Output : 7
>Explanation : One longest palindrome that can be built is "dccaccd", whose length

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        wordCnt = dict.fromkeys(range(256), 0)

        for k,v in enumerate(s):
            wordCnt[ord(v)] += 1

        hasOdd = False
        len = 0
        for v in wordCnt.values():
            num = v // 2
            mod = v % 2

            len += num * 2
            if mod > 0:
                hasOdd = True

        return len + (1 if hasOdd else 0)
```



## 1.6 [205.字符串同构(Easy)](https://leetcode-cn.com/problems/isomorphic-strings/description/)

>给定两个字符串 s 和 t，判断它们是否是同构的。
>
>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
>
>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
>
>**示例 1:**
>
>输入：s = "egg", t = "add"
>输出：true
>**示例 2：**
>
>输入：s = "foo", t = "bar"
>输出：false
>**示例 3：**
>
>输入：s = "paper", t = "title"
>输出：true

```PYTHON
"""
记录映射关系代码不好写，就死记这种方法。
记住：字符串同构：同一位置上的字符上次出现为位置相同。
"""
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        preIndex1 = dict.fromkeys(range(256), -1)
        preIndex2 = dict.fromkeys(range(256), -1)

        for i in range(len(s)):
            if preIndex1[ord(s[i])] != preIndex2[ord(t[i])]:
                return False
            preIndex1[ord(s[i])] = i
            preIndex2[ord(t[i])] = i
        return True
```

## 1.7 [647.回文子字符串个数 (Medium)](https://leetcode-cn.com/problems/palindromic-substrings/description/)

>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
>
>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
>
>
>
>**示例 1：**
>
>输入："abc"
>输出：3
>解释：三个回文子串: "a", "b", "c"
>
>
>
>**示例 2：**
>
>输入："aaa"
>输出：6
>解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

```python
"""
中心拓展法：
时间复杂度：O(n^2)
空间复杂度：O(1)
"""
class Solution:
    def countSubstrings(self, s: str) -> int:
        cnt = 0
        for i in range(len(s)):
            cnt += self.extendCountSubString(s, i, i)
            cnt += self.extendCountSubString(s, i, i+1)
        return cnt

    def extendCountSubString(self, s:str, start:int, end:int)-> int:
        cnt = 0
        while start >= 0 and end < len(s) and s[start] == s[end]:
            cnt += 1
            start -= 1
            end += 1
        return cnt
"""
Manacher 算法：
时间复杂度：O(n)
空间复杂度：O(n)
todo：
"""

```

## 1.8 [9.判断一个整数是否是回文数 (Easy)](https://leetcode-cn.com/problems/palindrome-number/description/)

>**示例 1:**
>
>输入: 121
>输出: true
>**示例 2:**
>
>输入: -121
>输出: false
>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
>**示例 3:**
>
>输入: 10
>输出: false
>解释: 从右向左读, 为 01 。因此它不是一个回文数。

```python
# 方法一：python语法糖
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 :
            return False
        l1 = list(str(x))
        f, b = 0, len(l1) - 1
        while f < b and l1[f] == l1[b]:
            f += 1
            b -= 1 
        return True if f >=b else False
"""
方法二：传统方法
1.想想如何翻转一个数
"""
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x == 0:
            return True
        if x < 0 or x % 10 == 0:
            return False

        right = 0
        while x > right:
            right = right * 10 + x % 10
            x = x // 10

        return  x == right or x == right // 10
```

## 1.9 [696.统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数(Easy)](https://leetcode-cn.com/problems/count-binary-substrings/description/)

>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
>
>重复出现的子串要计算它们出现的次数。
>
>**示例 1 :**
>
>输入: "00110011"
>输出: 6
>解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
>
>请注意，一些重复出现的子串要计算它们出现的次数。
>
>另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
>**示例 2 :**
>
>输入: "10101"
>输出: 4
>解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

```PYTHON
# 方法一：思路：划分区间，记录每个区间长度，相邻区间长度最小值则为这两个区间组成的字符串连续1,0数量相同的子字符串个数。
#       举例：00111
#				相同数量子串有2个：0011,01
#				也就是两个区间长度{2,3}的最小值2
# 		实现技巧，只用 lastLen 保留上一个区间的长度，得到当前区间长度 curLen，ans += min(lastLen,curLen)
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        i, n, ret, lastLen = 0, len(s), 0, 0
        while i < n:
            curLen = 0
            c = s[i]
            while i < n and s[i] == c:
                curLen += 1
                i += 1
            ret += min(lastLen, curLen)
            last = curLen
        return ret
```



## 1.10 [5.最长 回文子串(Medium)](https://leetcode-cn.com/problems/longest-palindromic-substring/)

>给你一个字符串 s，找到 s 中最长的回文子串。
>
>
>
>示例 1：
>
>输入：s = "babad"
>输出："bab"
>解释："aba" 同样是符合题意的答案。
>示例 2：
>
>输入：s = "cbbd"
>输出："bb"
>示例 3：
>
>输入：s = "a"
>输出："a"
>示例 4：
>
>输入：s = "ac"
>输出："a"

```PYTHON
"""
与《1.7 647 回文子字符串个数》 的回文判断一样，只是结果输出不一样，一个数输出个数，一个是输出最长回文串。
回文判断：中间

"""
```



## 1.11 [14.最长公共前缀(easy)](https://leetcode-cn.com/problems/longest-common-prefix/)

> 编写一个函数来查找字符串数组中的最长公共前缀。
>
> 如果不存在公共前缀，返回空字符串 ""。
>
> 
>
> 示例 1：
>
> 输入：strs = ["flower","flow","flight"]
> 输出："fl"
> 示例 2：
>
> 输入：strs = ["dog","racecar","car"]
> 输出：""
> 解释：输入不存在公共前缀。

```python
"""
官方提供了4种解答，没有特别优的方法。
就记住两种暴力法：

1. 横向扫描 
时间复杂度：O(mn)。其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。
空间复杂度：O(1) 使用的额外空间复杂度为常数。

2. 纵向扫描（复杂度与横向扫描一样）

"""
```



## 1.12 [17.电话号码的字母组合(Medium)](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![image-20210124190603302](image-20210124190603302.png)
>
> 示例:
>
> 输入："23"
> 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].



```python
"""
注意：输入字符串不限长度。可以时间复杂度是O(a^N)。这种复杂度用回溯法穷尽，具体用递归实现。
"""
```

[TODO](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/)



## 1.13 [344. 反转字符串(Easy)](https://leetcode-cn.com/problems/reverse-string/)

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
>
> 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
>
> 
>
> **示例 1：**
>
> 输入：["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]
> **示例 2：**
>
> 输入：["H","a","n","n","a","h"]
> 输出：["h","a","n","n","a","H"]

```python
"""太简单了吧。。"""
```

## 1.14 [38. 外观数列(Easy)](https://leetcode-cn.com/problems/count-and-say/)

> 1.     1
> 2.     11
> 3.     21
> 4.     1211
> 5.     111221
>        第一项是数字 1 
>        描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
>        描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
>        描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
>        描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
>
> **示例 1：**
>
> 输入：n = 1
> 输出："1"
> 解释：这是一个基本样例。
> **示例 2：**
>
> 输入：n = 4
> 输出："1211"
> 解释：
> countAndSay(1) = "1"
> countAndSay(2) = 读 "1" = 一 个 1 = "11"
> countAndSay(3) = 读 "11" = 二 个 1 = "21"
> countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"

```python
"""
todo
"""
```



## 1.15 [125. 验证回文串(Easy)](https://leetcode-cn.com/problems/valid-palindrome/)

> 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
>
> 说明：本题中，我们将空字符串定义为有效的回文串。
>
> 示例 1:
>
> 输入: "A man, a plan, a canal: Panama"
> 输出: true

```python
"""
todo
"""
```



## 1.16 [387. 字符串中的第一个唯一字符(Easy)](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

> 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
>
> **示例：**
>
> s = "leetcode"
> 返回 0
>
> s = "loveleetcode"
> 返回 2

```python
"""
todo
"""
```

## 1.17 [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/) gzl

```python
class Solution:
    def reverse(self, x: int) -> int:
        max= math.pow(2,31)-1
        min =-math.pow(2,31)

        ans = 0
        while x!=0 :
            tmp = x % 10 if x >= 0 else x % (-10)	# python 没有溢出，需要取余需要判断正负
            x = x // 10 if x >= 0 else int(x / 10) # 除以10。负数向上取整，正数向下取整
            if max-tmp < ans*10 or ans*10 < min-tmp:
                return 0
            ans = ans*10+tmp
        return ans
```



## 1.18 [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/) gzl

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.strip() # 删除首尾空格
        strs = s.split() # 分割字符串
        strs.reverse() # 翻转单词列表
        return ' '.join(strs) # 拼接为字符串并返回
```



## 1.19 [179. 最大数](https://leetcode-cn.com/problems/largest-number/) gzl

# 2. 哈希表

## 2.1 [1.数组中两个数的和为给定值(Easy)](https://leetcode-cn.com/problems/two-sum/description/)

>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
>
>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
>
>**示例 1：**
>
>输入：nums = [2,7,11,15], target = 9
>输出：[0,1]
>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
>**示例 2：**
>
>输入：nums = [3,2,4], target = 6
>输出：[1,2]
>**示例 3：**
>
>输入：nums = [3,3], target = 6
>输出：[0,1]

```PYTHON
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dict1 = {}
        for k,v in enumerate(nums):
            if target - v not in dict1:
                dict1[v] = k
            else:
                return [dict1[target - v], k]
        return None
```

## 2.2 [217.判断数组是否含有重复元素(Easy)](https://leetcode-cn.com/problems/contains-duplicate/description/)

>**示例 1:**
>
>输入: [1,2,3,1]
>输出: true
>**示例 2:**
>
>输入: [1,2,3,4]
>输出: false
>**示例 3:**
>
>输入: [1,1,1,3,3,4,3,2,4,2]
>输出: true

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        dict1 = {}
        for k, v in enumerate(nums):
            if v in dict1:
                return True
            dict1[v] = 1
        return False
```

## 2.3 [594.最长和谐序列(Easy)](https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/)

> 和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1
>
> **示例 1:**
>
> ```
> 输入: [1,3,2,2,5,2,3,7]
> 输出: 5
> 原因: 最长的和谐数组是：[3,2,2,2,3].
> ```

```PYTHON
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        dicts = {}
        for v in nums:
            dicts[v] = dicts.get(v, 0) + 1

        ret = 0
        for key, value in dicts.items():
            if key + 1 in dicts:
                ret = max(dicts[key + 1] + value, ret)
        return ret
```



## 2.4 [128.最长连续序列(Hard)](https://leetcode-cn.com/problems/longest-consecutive-sequence/description/)

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> **要求：**你可以设计并实现时间复杂度为 `O(n)` 的解决方案吗？
>
> **示例 1：** 
>
> 输入：nums = [100,4,200,1,3,2]
> 输出：4
> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
> **示例 2：**
>
> 输入：nums = [0,3,7,2,5,8,4,6,0,1] 
> 输出：9

```PYTHON
# 注意要求O(N)
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums_set = set(nums)
        ret = 0
        for v in nums_set:
            if v - 1 not in nums_set: # 最长序列的第一个值v，v-1必定不存，因此检查是否存在v-1即可判断是否跳过
                count = 1

                while v + 1 in nums_set:
                    v += 1
                    count += 1
                ret = max(ret, count)
        return ret
"""
如何分析这段代码的时间复杂度？
	每个数只会进入内层循环一次，所以是O（N）。
	比如有【1，2，3，11，12，13】
		v=1，进入内循环：
			2，3
      v=11，进入内循环：
      	 12，13
  	end
"""
```



## 2.5 [49. 字母异位词分组(Medium)](https://leetcode-cn.com/problems/group-anagrams/)

> 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
>
> **示例:**
>
> 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
> 输出:
> [
> ["ate","eat","tea"],
> ["nat","tan"],
> ["bat"]
> ]

```python
"""
疑问：相同怎么样？ ----也看作时异或词
两种方法都是利用哈希表，其实都不太好想到：
方法一：先排序，用排序后的字符串作为key，
方法二：计数法，用26个字母出现次数拼接的字符串作为key，
复杂度分析：https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/
"""
```



# 3. 链表

## 3.1 链表相交

### 3.1.1 [160.找出两个链表的交点(Easy)](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

---

[160. Intersection of Two Linked Lists (Easy)](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

> **注意**：
>
> 如果两个链表没有交点，返回 null.
> 在返回结果后，两个链表仍须保持原有的结构。
> 可假定整个链表结构中没有循环。
> 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

``` PYTHON
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        l1, l2 = headA, headB
        # 因为一个节点只有一个next指针，因此当两链表相交，两链表交点以后也都是公共节点。 
        # 定义：A/B分别为两链表非公共部分，C为公共部分
        # 情况1：有交点：A+C+B = B+C+A，以下实现最终l1,l2 指向第一次公共节点也即是交点，终止循环并最终返回交点
        # 情况2：没有交点：A+B = B+A， 以下实现最终l1,l2 都为null，也即相等，终止循环并最终返回null
        while l1 is not l2:
            l1 = l1.next if l1 else headB
            l2 = l2.next if l2 else headA
        return l1
```

### 3.1.2 [面试题 02.08. 环路检测](https://leetcode-cn.com/problems/linked-list-cycle-lcci/)          gzl



## 3.2 链表倒数节点

### 3.2.1 [面试题 02.02. 返回倒数第 k 个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/) gzl



## 3.3 链表翻转

> 套模板：
>
> 一、翻转整个链表  
>
> ​	1. **两指针：pre，tmp**
>
> ​	2. **return pre**
>
> 题目：
>
> [206.链表反转(Easy)](https://leetcode-cn.com/problems/reverse-linked-list/description/)
>
> 
>
> 二、翻转部分链表
>
> 1. **使用dummy**
> 2. **定义pre，cur，tmp**
> 3. **return dummy.next**
>
> 题目：
>
> [24.交换链表中的相邻结点(Medium)](https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/)
>
> [92. 反转链表 II(Medium)](https://leetcode-cn.com/problems/reverse-linked-list-ii/) 
>
> [25. K 个一组翻转链表(Hard)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) 



### 3.3.1 [206.链表反转(Easy)](https://leetcode-cn.com/problems/reverse-linked-list/description/)

```PYTHON
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
"""
1.头插法
	1.1 三指针法
"""
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre, cur = None, head
        while cur is not None:
            next = cur.next
            cur.next = pre
            pre, cur = cur, next
        return pre
    
"""
	1.2 优化：两指针法（指针pre和temp）：利用head作为cur指针遍历
"""
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 1.init
        pre = None
        while head is not None:
            # 1. init
            next = head.next
            # 2. excute step 1
            head.next = pre
            # 3. prepare next loop
            pre, head = head, next
        return pre
"""
2.递归法
    #######################################################
    # 1.本级递归应该做什么：在这一级递归中，应该完成什么任务？
    	方案1：修改当前节点next指针，指向前驱节点？这样要head和pre都传参，不太好。
    	更好的方案：修改当前节的下一个节点的next指针，指向当前节点：
    	head->next->next = head; head->next = 0
    # 2 找整个递归的终止条件：递归应该在什么时候结束？	根据1可知终止条件: head==0 or head->next==0
    # 3.找返回值：应该给上一级返回什么信息？	最终返回的是最后一个节点，因此 当 head==0 or head->next==0 return head 否则 返回上级递归函数返回的结果last（也即最后一个节点），但是本级递归（head->next->next = next; head->next = 0）又只能在递归函数后执行，因此要把上级递归返回last保存起来，在最后返回。
    
   tips： 递归可以说是走到链表末，从后往前的，与一般的循环的方法比较，递归法无需保存next节点，是需要保存pre节点，而递归法特点已经在每层递归中保存了前驱节点，也即上层递归的head。
    #######################################################
"""
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 2. 整个递归终止条件
        if head is None or head.next is None:
            return head

        # 3.1 保存上级递归结果（也即最后一个节点）
        last = self.reverseList(head.next)
        # 1. 本级递归要做的
        head.next.next = head
        head.next = None

        # 3.2 给上级返回最后一个节点
        return last
```

### 3.3.2 [24.交换链表中的相邻结点(Medium)](https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/)

> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
>
> **你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

```PYTHON
# 如果不用头结点，保存第一个节点需要加判断条件，比较丑
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        cur = head
        pre = dummy
        while cur is not None and cur.next is not None:
            # prepare
            temp = cur.next

            # swap
            cur.next = cur.next.next
            temp.next = cur
            pre.next = temp
				
            # after
            pre = cur # 易错，不是pre=temp
            cur = cur.next

        return dummy.next # 易错，不能直接返回head
```

### 3.3.3 [234.回文链表(Easy)](https://leetcode-cn.com/problems/palindrome-linked-list/description/)

> 请判断一个链表是否为回文链表。
>
> 尝试O(1)空间复杂度完成。
>
> **示例 1:**
>
> 输入: 1->2
> 输出: false
>
> **示例 2:**
>
> 输入: 1->2->2->1
> 输出: true

```python
"""
最简单方法：copy到数组，再通过双指针法判断。空间复杂度O(N)
"""


"""
空间复杂度 O(1):
	快慢指针法：找中点，翻转，比较
 	主要难点是找中点。注意当结点偶数时，需要指向下中点再翻转
"""
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        # 1. 快慢指针找到中点，注意是偶数时是下中点
        # 2. 翻转
        # 3. 比较
       half = self.endOfHalf(head)
       return self.isEqual(head, self.reversedList(half))


    def endOfHalf(self, head:ListNode) -> ListNode:
        fast, slow = head, head
        while fast is not None and fast.next is not None:
            fast = fast.next.next
            slow = slow.next
        return slow

    def reversedList(self, head:ListNode) -> ListNode:
        pre = None
        while head is not None:
            nextNode = head.next
            head.next = pre
            pre, head = head, nextNode
        return pre

    def isEqual(self, head:ListNode, half:ListNode) -> bool:
        while head is not None and half is not None:
            if head.val != half.val:
                return False
            head = head.next
            half = half.next

        return True
```

### 3.3.4 [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) gzl

> 翻转中间某段【left，right】

```python
# 1. dummy  2.画图  3.空指针 4.边界处理：输入空，输入1个等
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        # 设置 dummyNode 是这一类问题的一般做法
        dummy = ListNode(-1)
        dummy.next = head
        pre = dummy
        for _ in range(left - 1):
            pre = pre.next

        cur = pre.next
        for _ in range(right - left):
            tmp = cur.next
            
            cur.next = cur.next.next
            tmp.next = pre.next
            pre.next = tmp
            
        return dummy.next
```

### 3.3.5 [25. K 个一组翻转链表(Hard)](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) gzl

```python
# 方法一：递归法（就记这个方法吧）
class Solution:
    # 翻转一个子链表，并且返回新的头
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        def reverse(head: ListNode, tail: ListNode):
            # 传入tail需要反转的后一位，也即需要反转 [head, tail)
            pre = None
            while head != tail:
                # 1. init
                tmp = head.next
                # 2. excute step 1
                head.next = pre
                # 3. prepare next loop
                pre, head = head, tmp
            return pre # 当前head==tail， pre==tail-1

        count = 0
        tail = head
        while count != k:
            if tail is None:
                return head
            tail_pre = tail
            tail = tail.next
            count +=1
        
        # head指向第一个待翻转节点
        new_head = reverse(head, tail) # 一般翻转一个链表是判断cur==None，也判断cur==末尾后一位位终止条件。 因此为了reverse 代码好写，传入末尾+1。
        # 调用reverse后，head就是翻转后的最后一个节点
        head.next = self.reverseKGroup(tail, k)
        return new_head
    
# 方法二：迭代法(两层循环)
class Solution:
    # 翻转一个子链表，并且返回新的头与尾
    def reverse(self, head: ListNode, tail: ListNode):
        prev = tail.next
        p = head
        while prev != tail:
            nex = p.next
            p.next = prev
            prev = p
            p = nex
        return tail, head

    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        hair = ListNode(0)
        hair.next = head
        pre = hair

        while head:
            tail = pre
            # 查看剩余部分长度是否大于等于 k
            for i in range(k):
                tail = tail.next
                if not tail:
                    return hair.next
            nex = tail.next
            head, tail = self.reverse(head, tail)
            # 把子链表重新接回原链表
            pre.next = head
            tail.next = nex
            pre = tail
            head = tail.next
        
        return hair.next    
```

### 3.3.6 [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)gzl

> 给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
> 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
>
> 例：给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.

```python
# 方法一：转数组，下标访问重建链表。时间复杂度O(N)，空间复杂度O(N)
class Solution:
    def reorderList(self, head: ListNode) -> None:
        if not head:
            return
        
        vec = list()
        node = head
        while node:
            vec.append(node)
            node = node.next
        
        i, j = 0, len(vec) - 1
        while i < j:
            vec[i].next = vec[j]
            i += 1
            if i == j:
                break
            vec[j].next = vec[i]
            j -= 1
        
        vec[i].next = None

# 方法二：找中点 + 翻转半条链表 + 合并链表。时间复杂度O(N)，空间复杂度O(1)
# 太复杂了，知道方法就好，不写。
class Solution:
    def reorderList(self, head: ListNode) -> None:
        if not head:
            return
        
        mid = self.middleNode(head)
        l1 = head
        l2 = mid.next
        mid.next = None
        l2 = self.reverseList(l2)
        self.mergeList(l1, l2)
    
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        return slow
    
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        curr = head
        while curr:
            nextTemp = curr.next
            curr.next = prev
            prev = curr
            curr = nextTemp
        return prev

    def mergeList(self, l1: ListNode, l2: ListNode):
        while l1 and l2:
            l1_tmp = l1.next
            l2_tmp = l2.next

            l1.next = l2
            l1 = l1_tmp

            l2.next = l1
            l2 = l2_tmp
```



## 3.4 合并有序链表

### 3.4.1 [21.归并两个有序的链表(Easy)](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/)

```python
# 方法一迭代法：
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = ListNode(-1)

        pre = head
        while l1 is None and l2 is None:
            if l1.val <= l2.val:
                pre.next = l1
                l1 = l1.next
            else:
                pre.next = l2
                l2 = l2.next
            pre = pre.next

        pre.next = l1 if l1 is None else l2

        return head
# 方法二递归法：
####### 思考过程
# 1.终止条件：l1 为空 or l2 为空
# 2.本级递归要做什么：1.获取更小的节点作为min 2.min.next指向递归返回（其余节点合并后的结果）
# 3.返回什么：返回更小节点
# 总结 ：本级要做什么和返回并不是分开思考的，本级迭代的要做的是“得到更小的节点”
######
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        if l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

### 3.4.2 [23. 合并K个升序链表(Hard)](https://leetcode-cn.com/problems/merge-k-sorted-lists/) gzlwg

![img](https://pic.leetcode-cn.com/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png)![image-20210325233613948](image-20210325233613948.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:return 
        n = len(lists)
        return self.merge(lists, 0, n-1)
    def merge(self,lists, left, right):
        if left == right:
            return lists[left]
        mid = left + (right - left) // 2
        l1 = self.merge(lists, left, mid)
        l2 = self.merge(lists, mid+1, right)
        return self.mergeTwoLists(l1, l2)
    def mergeTwoLists(self,l1, l2):
        if not l1:return l2
        if not l2:return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

## 3.5 删除链表节点

### 3.5.1 [83.从有序链表中删除重复节点(Easy)](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

> 无需考虑删除节点的next。。

```python
# 直接法
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        cur = head
        while cur is not None and cur.next is not None:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
```

### 3.5.2 [82. 删除排序链表中的重复元素 II(Medium)](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) gzl

```python
# 1. dummy  2.画图  3.空指针 4.边界处理：输入空，输入1个等
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if head is None:
            return None
        dummy = ListNode(-1)
        dummy.next = head
        a = dummy
        b = head

        while b and b.next:
            if a.next.val != b.next.val:
                a = a.next
                b = b.next
            else:
                while b.next and a.next.val == b.next.val:
                    b = b.next
                a.next = b.next
                b = b.next
        return dummy.next
```

### 3.5.3 [19.删除链表的倒数第 n 个节点(Medium)](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/)

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast, slow = head, head
        while n > 0:
            fast = fast.next
            n = n - 1
        if fast is None: # 当删除倒数第一个节点时，出现该情况，容易遗漏
            return slow.next 
        while fast.next is not None:
            slow = slow.next
            fast = fast.next
        slow.next = slow.next.next
        return head
```

### 3.5.4 [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)gzl

```python
class Solution:
    def deleteNode(self, head: ListNode, val: int) -> ListNode:
        if head.val == val: return head.next
        pre, cur = head, head.next
        while cur and cur.val != val:
            pre, cur = cur, cur.next
        if cur: pre.next = cur.next
        return head
```



## 3.6 链表排序

### 3.6.1 [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)gzl

```python
"""
题目要求：时间复杂度O(nlogN)，空间复杂度O(1)
O(nlogN)时间复杂度的排序算法：快排，堆排序，归并排序。其中归并排序适合链表。
关于归并排序：
	自顶向下的递归,栈空间复杂度O(logn)，不符合要求
    需要自底向上的迭代实现，空间复杂度O(1)
"""
# 递归实现（自顶向上），空间复杂度O(logn)
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        def sortFunc(head: ListNode, tail: ListNode) -> ListNode:
            if not head:
                return head
            if head.next == tail:
                head.next = None
                return head
            slow = fast = head
            while fast != tail:
                slow = slow.next
                fast = fast.next
                if fast != tail:
                    fast = fast.next
            mid = slow
            return merge(sortFunc(head, mid), sortFunc(mid, tail))
            
        def merge(head1: ListNode, head2: ListNode) -> ListNode:
            dummyHead = ListNode(0)
            temp, temp1, temp2 = dummyHead, head1, head2
            while temp1 and temp2:
                if temp1.val <= temp2.val:
                    temp.next = temp1
                    temp1 = temp1.next
                else:
                    temp.next = temp2
                    temp2 = temp2.next
                temp = temp.next
            if temp1:
                temp.next = temp1
            elif temp2:
                temp.next = temp2
            return dummyHead.next
        
        return sortFunc(head, None)

# 迭代法（自底向上），空间复杂度O(1)
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        def merge(head1: ListNode, head2: ListNode) -> ListNode:
            dummyHead = ListNode(0)
            temp, temp1, temp2 = dummyHead, head1, head2
            while temp1 and temp2:
                if temp1.val <= temp2.val:
                    temp.next = temp1
                    temp1 = temp1.next
                else:
                    temp.next = temp2
                    temp2 = temp2.next
                temp = temp.next
            if temp1:
                temp.next = temp1
            elif temp2:
                temp.next = temp2
            return dummyHead.next
        
        if not head:
            return head
        
        length = 0
        node = head
        while node:
            length += 1
            node = node.next
        
        dummyHead = ListNode(0, head)
        subLength = 1
        while subLength < length:
            prev, curr = dummyHead, dummyHead.next
            while curr:
                head1 = curr
                for i in range(1, subLength):
                    if curr.next:
                        curr = curr.next
                    else:
                        break
                head2 = curr.next
                curr.next = None
                curr = head2
                for i in range(1, subLength):
                    if curr and curr.next:
                        curr = curr.next
                    else:
                        break
                
                succ = None
                if curr:
                    succ = curr.next
                    curr.next = None
                
                merged = merge(head1, head2)
                prev.next = merged
                while prev.next:
                    prev = prev.next
                curr = succ
            subLength <<= 1
        
        return dummyHead.next
    
# 迭代二：
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        h, length, intv = head, 0, 1
        while h: h, length = h.next, length + 1
        res = ListNode(0)
        res.next = head
        # merge the list in different intv.
        while intv < length:
            pre, h = res, res.next
            while h:
                # get the two merge head `h1`, `h2`
                h1, i = h, intv
                while i and h: h, i = h.next, i - 1
                if i: break # no need to merge because the `h2` is None.
                h2, i = h, intv
                while i and h: h, i = h.next, i - 1
                c1, c2 = intv, intv - i # the `c2`: length of `h2` can be small than the `intv`.
                # merge the `h1` and `h2`.
                while c1 and c2:
                    if h1.val < h2.val: pre.next, h1, c1 = h1, h1.next, c1 - 1
                    else: pre.next, h2, c2 = h2, h2.next, c2 - 1
                    pre = pre.next
                pre.next = h1 if c1 else h2
                while c1 > 0 or c2 > 0: pre, c1, c2 = pre.next, c1 - 1, c2 - 1
                pre.next = h 
            intv *= 2
        return res.next
```



## 3.7 链表求和

### 3.7.1 [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

> 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> ```

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = ListNode(l1.val + l2.val)
        cur = head
        while l1.next or l2.next:
            l1 = l1.next if l1.next else ListNode()
            l2 = l2.next if l2.next else ListNode()
            cur.next = ListNode(l1.val + l2.val + cur.val // 10)
            cur.val = cur.val % 10
            cur = cur.next
        if cur.val >= 10:
            cur.next = ListNode(cur.val // 10)
            cur.val = cur.val % 10
        return head
```

### 3.7.2 [445.链表求和(Medium)](https://leetcode-cn.com/problems/add-two-numbers-ii/description/)

> 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>
> **示例：**
>
> ```
> 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 8 -> 0 -> 7
> ```

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1 = self.buildStack(l1)
        s2 = self.buildStack(l2)
        ans = None

        addFlag = 0
        while s1 or s2 or addFlag != 0:
            a = 0 if not s1 else s1.pop()
            b = 0 if not s2 else s2.pop()
            c = a + b + addFlag
            addFlag = c // 10
            curNode = ListNode(c%10)
            curNode.next = ans
            ans = curNode
        return ans

    def buildStack(self, l1: ListNode) -> list:
        list1 = []
        while l1:
            list1.append(l1.val)
            l1 = l1.next
        return list1
```







## 3.10 [725.分隔链表(Medium)](https://leetcode-cn.com/problems/split-linked-list-in-parts/description/)

> 输入：root = [1, 2, 3], k = 5
> 输出: [[1],[2],[3],[],[]]
>
> 输入: 
> root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
> 输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]

```python
class Solution:
    def splitListToParts(self, root: ListNode, k: int) -> List[ListNode]:
        head = root
        result = []
        len = 0
        while head is not None:
            head = head.next
            len += 1
·
        dummy = ListNode(-1)
        dummy.next = root
        size = len // k
        mod = len % k
        for i in range(k):
            cur = dummy
            result.append(dummy.next)
            for j in range(size):	# 对于每个槽，先放入商的部分
                cur = cur.next
            if mod > 0:				# 对于每个槽，都放入余数部分
                cur = cur.next
                mod -= 1

            dummy.next = cur.next
            cur.next = None

        return result
```

## 3.11 [328.链表元素按奇偶聚集(Medium)](https://leetcode-cn.com/problems/odd-even-linked-list/description/)

> 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
>
> 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
>
> **示例 1:**
>
> 输入: 1->2->3->4->5->NULL
> 输出: 1->3->5->2->4->NULL
> **示例 2:**
>
> 输入: 2->1->3->5->6->4->7->NULL 
> 输出: 2->3->6->7->1->5->4->NULL
> 说明:
>
> 应当保持奇数节点和偶数节点的相对顺序。
> 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

```PYTHON
# 方法二：无需判断奇偶，直接修改两个next，可以省一个判断和num变量，代码简洁很多，但要注意循环边界
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:return head
        odd = head
        even_head = even = head.next	# 注意必须保存第二个节点，因为后面head.next已经变了
        while odd.next and even.next:
            odd.next = odd.next.next
            even.next = even.next.next
            odd,even = odd.next,even.next
        odd.next = even_head
        return head
```



# 4. 数组与矩阵

## 4.1 [283.把数组中的 0 移到末尾(Easy)](https://leetcode-cn.com/problems/move-zeroes/description/)

>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
>**示例:**
>
>输入: [0,1,0,3,12]
>输出: [1,3,12,0,0]
>**说明:**
>
>必须在原数组上操作，不能拷贝额外的数组。
>尽量减少操作次数。

```PYTHON
# 方法一：两次遍历: 先把非零找出来，在补0在后面。操作次数：len(nums)次
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        j = 0
        for v in nums:
            if v != 0:
                nums[j] = v
                j += 1
        for i in range(j, len(nums)):
            nums[i] = 0

# 方法二：一次遍历。参考快排思想。快排思想就是确定一个待分割的元素做之中间点x，然后把所有小于x的元素放到x左边，大于x的元素放到x右边。这里我们可以用0当做这个中间点，把不等于0（注意题目没说不能有负数）的放到中间点左边，等于0的放到其右边。操作次数：len（nums）- 0的个数
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        index = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[index] = nums[index], nums[i]
                index += 1
        return nums
    
```



## 4.2 [566.改变矩阵维度(Easy)](https://leetcode-cn.com/problems/reshape-the-matrix/description/)

```PYTHON
# 方法二：不用额外空间
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        if len(nums) * len(nums[0]) != r * c:
            return nums

        retList, subList，nn = [], [], 0
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                if nn < c:
                    subList.append(nums[i][j])
                    nn += 1
                if nn == c:
                    retList.append(subList.copy())
                    subList.clear()
                    nn = 0
        return retList
```



## 4.3 [485.找出数组中最长的连续1(Easy)](https://leetcode-cn.com/problems/max-consecutive-ones/description/)

> 给定一个二进制数组， 计算其中最大连续1的个数。
>
> **示例 1:**
>
> 输入: [1,1,0,1,1,1]
> 输出: 3
> 解释: 开头的两位和最后的三位都是连续1，所以s最大连续1的个数是 3.
> **注意：**
>
> 输入的数组只包含 0 和1。
> 输入数组的长度是正整数，且不超过 10,000。

```PYTHON
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        ret, count = 0, 0
        for i in range(0, len(nums)):
            count = 0 if nums[i] == 0 else count + 1
            ret = max(ret, count)
        return ret
```



## 4.4 [240.有序矩阵查找(Medium)](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)

```python

```



## 4.5 [378.有序矩阵的 Kth Element(Medium)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

> 给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
> 请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
>
> 
>
> **示例：**
>
> matrix = [
> [ 1,  5,  9],
> [10, 11, 13],
> [12, 13, 15]
> ],
> k = 8,
>
> 返回 13。
>
> 提示：
> 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。

```python

```



## 4.6 [645.一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数（重复一次）(Easy)](https://leetcode-cn.com/problems/set-mismatch/)

> 集合 S 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。
>
> 给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
>
> 进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？
>
> 
>
> **示例：**
>
> 输入：nums = [1,2,2,4]
> 输出：[2,3]
>
> **提示：**
>
> 数组 nums 的长度范围是 [2, 10000] 。
> **给定的数组是无序的。**

```python
"""
直接法：先排序，再遍历。时间复杂度：O(NlogN + N)
"""

"""
交换法：利用条件元素在1~n之间，排序时间复杂度O(N)，再遍历找出缺的元素。总时间复杂度O(2N)
"""
```



## 4.7 [287.找出数组中重复的数，数组值在 [1, n] 之间（可重复多次）(Medium)](https://leetcode-cn.com/problems/find-the-duplicate-number/)

```python
不明白
```





## 4.9 [697.数组的度(Easy)](https://leetcode-cn.com/problems/degree-of-an-array/)

> 给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。
>
> 你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。
>
> **示例 1:**
>
> 输入: [1, 2, 2, 3, 1]
> **输出: 2**
> 解释: 
> 输入数组的度是2，因为元素1和2的出现频数最大，均为2.
> 连续子数组里面拥有相同度的有如下所示:
> [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
> 最短连续子数组[2, 2]的长度为2，所以返回2.
> **示例 2:**
>
> 输入: [1,2,2,3,1,4,2]
> **输出: 6**
> **注意:**
>
> nums.length 在1到50,000区间范围内。
> nums[i] 是一个在0到49,999范围内的整数。

```python
"""
没有想象中easy，需要考虑存在“度”相同的两个数，取最短的子串
"""
class Solution(object):
    def findShortestSubArray(self, nums):
        left, right, count = {}, {}, {}
        for i, x in enumerate(nums):
            if x not in left: left[x] = i
            right[x] = i
            count[x] = count.get(x, 0) + 1

        ans = len(nums)
        degree = max(count.values())
        for x in count:
            if count[x] == degree:
                ans = min(ans, right[x] - left[x] + 1)

        return ans
```



## 4.10 [766.对角元素相等的矩阵(Easy)](https://leetcode-cn.com/problems/toeplitz-matrix/)

```python
"""
左上邻居法：
"""
class Solution(object):
    def isToeplitzMatrix(self, matrix):
        return all(r == 0 or c == 0 or matrix[r-1][c-1] == val
                   for r, row in enumerate(matrix)
                   for c, val in enumerate(row))

```



## 4.11 [565.嵌套数组(Medium)](https://leetcode-cn.com/problems/array-nesting/)

> 索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。
>
> 假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。
>
> 
>
> **示例 1:**
>
> 输入: A = [5,4,0,3,1,6,2]
> 输出: 4
> **解释:** 
> A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.
>
> 其中一种最长的 S[K]:
> S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
>
>
> **提示：**
>
> N是[1, 20,000]之间的整数。
> A中不含有重复的元素。
> A中的元素大小在[0, N-1]之间。
>
> **【注意】**S[i] 的定义，因此要遍历数组A。例如：A=[0,1,2]。输出：2

```PYTHON
"""

"""
```



## 4.12 [769. 最多能完成排序的块(Medium)](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/) 频率低

>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：
>
>实现 MyQueue 类：
>
>void push(int x) 将元素 x 推到队列的末尾
>int pop() 从队列的开头移除并返回元素
>int peek() 返回队列开头的元素
>boolean empty() 如果队列为空，返回 true ；否则，返回 false
>
>
>说明：
>
>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
>
>
>进阶：
>
>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。

## 4.13 [面试题 10.01. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

```python
class Solution {
public:
    void merge(vector<int>& A, int m, vector<int>& B, int n) {
        int l=m+n-1;
        int a=m-1;
        int b=n-1;
        while(a>=0&&b>=0){
            if(A[a]>=B[b])
                A[l--]=A[a--];
            else
                A[l--]=B[b--];
        }
        while(b>=0)
            A[l--]=B[b--];
    }
};s
```



## 4.14 [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/) gzl 

> **示例 1：**
>
> <img src="image-20210328223933001.png" alt="image-20210328223933001" style="zoom:33%;" />
>
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,3,6,9,8,7,4,5]

```python
# 跟59不同的是，输入矩阵不是N*N矩阵， 需要在循环内判断
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if matrix is None or len(matrix) <=0:
            return []
        ans = []
        left = top = 0
        right = len(matrix[0]) -1
        bottom = len(matrix) - 1 
        elemNum = len(matrix[0])*len(matrix) 
        while elemNum>0:
            for col in range(left, right+1):
                ans.append(matrix[top][col])
                elemNum-=1
            if elemNum == 0:
                break
            top+=1
            for row in range(top, bottom+1):
                ans.append(matrix[row][right])
                elemNum-=1
            if elemNum == 0:
                break
            right-=1
            for col in range(right, left-1,-1):
                ans.append(matrix[bottom][col])
                elemNum-=1
            bottom -=1
            if elemNum == 0:
                break
            for row in range(bottom, top-1,-1):
                ans.append(matrix[row][left])
                elemNum-=1
            left += 1
        return ans
```



## 4.15 [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/) gzl

> <img src="image-20210405113738811.png" alt="image-20210405113738811" style="zoom:50%;" />
>
> 输入：n = 3，生成1~n^2 所有元素，并按顺时针排列。输出矩阵。
> 输出：[[1,2,3],[8,9,4],[7,6,5]]

```python
#跟54基本一样，一个取值，一个赋值。但由于是N*N矩阵，只需要在最外层判断边界 while left <= right and top <= bottom，里面不会出越界
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        ans = [[0] * n for _ in range(0,n) ]
        left = top = 0
        right = bottom = n - 1 
        x = 1
        while left <= right and top <= bottom:
            for i in range(left, right+1):
                ans[top][i] = x
                x += 1
            top+=1
            for i in range(top, bottom+1):
                ans[i][right] = x
                x += 1
            right-=1
            for i in range(right, left-1,-1):
                ans[bottom][i] = x
                x += 1
            bottom -= 1
            for i in range(bottom, top-1,-1):
                ans[i][left] = x
                x += 1
            left += 1
        return ans
```

## 4.17 [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/) gzl

> 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
>
> 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
>
> <img src="image-20210328224722057.png" alt="image-20210328224722057" style="zoom:33%;" />

```python
#思路一: 找规律: 图像旋转本质就是这4个数的相互交换:即:任意一个(i,j) , (j, n-i-1), (n-i-1, n-j-1), (n -j-1, i)就是这四个索引号上的数交换.
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix) 
        for i in range(n//2):
            for j in range(i, n - i - 1):
                matrix[i][j],matrix[j][n-i-1],matrix[n-i-1][n-j-1],matrix[n-j-1][i] = \
                matrix[n-j-1][i], matrix[i][j],matrix[j][n-i-1],matrix[n-i-1][n-j-1]
        #print(matrix)


#思路二: 翻转 :翻转整个数组,再按正对角线交换两边的数
  [1,2,3],             [7,8,9],            [7,4,1],
  [4,5,6],    ---->    	 [4,5,6], ----->       [8,5,2],
  [7,8,9]              [1,2,3]             [9,6,3] 
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        matrix[:] = matrix[::-1]
        #print(matrix)
        for i in range(0, n):
            for j in range(i+1, n):
                #print(i, j)
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```



## 4.20 [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) gzl  hard 先放弃

## 4.20 [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/) gzl  0405 17:18  32分钟

> 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须 原地 修改，只允许使用额外常数空间
>
> **示例 1：**输入：nums = [1,2,3]  输出：[1,3,2]
>
> **示例 2：**输入：nums = [3,2,1] 输出：[1,2,3]
>
> **示例 4：**输入：nums = [1] 输出：[1]

```python
# 1.从后往前，找到最后非降序列表【A，end】（因为降序列表不能更大）
# 2.降序列表第一个数必须交互 A(保证变化范围最小，就是下一个组合)，从（A，end】找与A交互的数。容易看出，A与（A,end]中比A大的最小数B交互，保证增加幅度最小 
# 3.确定B与A交互后（B位置已确定，剩下的【A，end】升序重排能保证增加幅度最小
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        i = len(nums) - 2
        # 从后往前，找到最后非降序列表的第一个数nums[i]
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
            
        if i >= 0: # 如果 i<0 说明原组合已最大
            j = len(nums) - 1
            while j >= 0 and nums[i] >= nums[j]: # 从（i，end】中找比nums[i]大的最小数
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]
        
        # i+1,end 升序重排
        left, right = i + 1, len(nums) - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```

## 4.21 [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/) gzlkl 0405 17:54

> 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
>
> 示例 1 :
>
> 输入:nums = [1,1,1], k = 2
> 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
>
> 输入:[2,3,3,3,4,5] k =9
>
> 输出:2, [3,3,3] 和[4,5]

<img src="image-20210405212640032.png" alt="image-20210405212640032" style="zoom: 80%;" />

```python
# 方法一：暴力法： O(n^2)  要想到
public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        int len = nums.length;
        for (int left = 0; left < len; left++) {
            int sum = 0;
            // 区间里可能会有一些互相抵销的元素
            for (int right = left; right < len; right++) {
                sum += nums[right];
                if (sum == k) {
                    count++;
                }
            }
        }
        return count;
    }
}
# 方法二：前缀和+哈希表
# 前缀和，nums 的第0项到当前x项的和，记为preSum[x]。第i到j项和：preSum[j]-preSum[i-1]
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        preSumCnt = {0:1}   # 相同前缀和计算。空数组前缀和为0，计数1
        cunPreSum = 0       # 记录当前前缀和
        ans = 0
        for i in range(0, len(nums)):
            cunPreSum += nums[i]   # 得到当前项前缀和

            # 由于子数组和等于某两项前缀和之差，我们要统计 和等于k的子数组个数，只需要统计前缀和相同的情况
            if cunPreSum-k in preSumCnt:
                ans += preSumCnt[cunPreSum-k]   
            preSumCnt[cunPreSum] = preSumCnt.get(cunPreSum,0) + 1
        return ans
```



# 5. 栈与队列

## 5.1 [232. 用栈实现队列(Easy)](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

> 实现 MyQueue 类：
>
> void push(int x) 将元素 x 推到队列的末尾
> int pop() 从队列的开头移除并返回元素
> int peek() 返回队列开头的元素
> boolean empty() 如果队列为空，返回 true ；否则，返回 false

```python

```



## 5.2 [225. 用队列实现栈(Easy)](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```python
# 一个队列，简单好理解。当入队时，直接入，原来队列内的逐个出队，重新入队。
```

## 5.3 [252. 会议室(Easy)](https://leetcode-cn.com/problems/meeting-rooms/)低频



## 5.4 [155. 最小栈(Easy)](https://leetcode-cn.com/problems/min-stack/)

> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
>
> push(x) —— 将元素 x 推入栈中。
> pop() —— 删除栈顶的元素。
> top() —— 获取栈顶元素。
> getMin() —— 检索栈中的最小元素。

```python
"""
不可行：只保存最小值和第2小值
"""
```



## 5.5 [20. 有效的括号(Easy)](https://leetcode-cn.com/problems/valid-parentheses/)





## 5.6 [739. 每日温度(Medium)](https://leetcode-cn.com/problems/daily-temperatures/)：数组中元素与下一个比它大的元素之间

的距离

> 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
>
> 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
>
> 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

```python
"""
暴力法：O(N^2)

方法二：单调栈，时间复杂度O(N)，空间复杂度(N)
"""
```



## 5.7 [227. 基本计算器 II(Easy)](https://leetcode-cn.com/problems/basic-calculator-ii/)

>[224.基本计算器](https://leetcode-cn.com/problems/basic-calculator)
>
>[227.基本计算器II](https://leetcode-cn.com/problems/basic-calculator-ii)
>
>[772.基本计算器III](https://leetcode-cn.com/problems/basic-calculator-iii)
>
>```
>输入: "3+2*2"
>输出: 7
>```
>
>**示例 2:**
>
>```
>输入: " 3/2 "
>输出: 1
>```
>
>**示例 3:**
>
>```
>输入: " 3+5 / 2 "
>输出: 5
>```

```python
"""
详细https://leetcode-cn.com/problems/basic-calculator-ii/solution/chai-jie-fu-za-wen-ti-shi-xian-yi-ge-wan-zheng-ji-/
1.栈
2.遇到乘、除，需要出栈
"""
class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        num = 0; sign = '+'
        for i in range(len(s)):
            if s[i].isdigit():
                num = num*10 + int(s[i])
            if s[i] in '+-*/' or i == len(s)-1:
                if sign == '+':
                    stack.append(num)
                elif sign == '-':
                    stack.append(-num)
                elif sign == '*':
                    stack.append(stack.pop() * num)
                else:
                    stack.append(int(stack.pop() / num))
                num = 0; sign = s[i]
        return sum(stack)
```



# 6. 树

## 6.1 递归

### 6.1.1[104. 二叉树的最大深度(Easy)](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)



### 6.1.2 [110. 平衡二叉树(Easy)](https://leetcode-cn.com/problems/balanced-binary-tree/)

> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：
>
> > 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

```python
"""
从底至顶（提前阻断）
时间复杂度 O(N)O(N)： NN 为树的节点数；最差情况下，需要递归遍历树的所有节点。
空间复杂度 O(N)O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N)O(N) 的栈空间。
"""
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        return self.recur(root) != -1

    def recur(self, root):
        if not root: return 0
        left = self.recur(root.left)
        if left == -1: return -1
        right = self.recur(root.right)
        if right == -1: return -1
        return max(left, right) + 1 if abs(left - right) < 2 else -1
```



### 6.1.3 [543. 二叉树的直径(Easy)(节点最大长度)](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
>
> **示例 :**
> 给定二叉树
>
>     1
>
>    / \
>   2   3
>  / \     
>
> 4   5    
> 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

```python
"""
tips：递归需要返回两个值的，考虑一个全局变量
深度优先遍历（后序遍历）
"""
```



### 6.1.4 [226. 翻转二叉树(Easy)](https://leetcode-cn.com/problems/invert-binary-tree/)

> 翻转一棵二叉树。
>
> 示例：
>
> 输入：
>
> ​	 4
>
> /   \
> 2     7
> / \   / \
> 1   3 6   9
> 输出：
>
> ​	 4
>
> /   \
> 7     2
> / \   / \
> 9   6 3   1

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```



### 6.1.5 [617. 合并二叉树(Easy)](https://leetcode-cn.com/problems/merge-two-binary-trees/)

> 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
>
> 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
>
> 示例 1:
>
> 输入: 
> 	Tree 1                     Tree 2                  
>     1                         2                             
>    / \                       / \                            
>   3   2                     1   3                        
>  /                           \   \                      
> 5                             4   7                  
> 输出: 
> 合并后的树:
> 	     3
> 	    / \
> 	   4   5
> 	  / \   \ 
> 	 5   4   7

```PYTHON
"""
第一想法是left1 = left1 + left2,right1=right1+right2
但可能为left1可能为空，加上很多非空判断。

本层就做本层的事。

"""
```



### 6.1.6 [112. 路径总和(Easy)](https://leetcode-cn.com/problems/path-sum/)

> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
> 输出：true

```python
"""
注意要求根节点到叶子节点长度符合target
"""
```

### 6.1.7 [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) gzl

> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> 输出：[[5,4,11,2],[5,8,4,5]]

```python
# todo
```



### 6.1.7 [437. 路径总和 III(Medium)](https://leetcode-cn.com/problems/path-sum-iii/)（看不懂）

```python
public int pathSum(TreeNode root, int sum) {
if (root == null) return 0;
int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum
return ret;
}
private int pathSumStartWithRoot(TreeNode root, int sum) {
if (root == null) return 0;
int ret = 0;
if (root.val == sum) ret++;
ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot
return ret;
}
```



### 6.1.8 [572. 另一个树的子树(Easy)](https://leetcode-cn.com/problems/subtree-of-another-tree/)

> 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
>
> 示例 1:
> 给定的树 s:
>
> ​	 3
> ​	/ \
>
> 4   5
> / \
> 1   2
> 给定的树 t：
>
> 4 
> / \
> 1   2
> 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
>
> 示例 2:
> 给定的树 s：
>
> ​	 3
> ​	/ \
>
> 4   5
> / \
> 1   2
> /
> 0
> 给定的树 t：
>
> 4
> / \
> 1   2
> 返回 false。
>
> **注意是某个节点直到叶子节点相同才算子树**

```python
"""
该双递归就双递归
"""
```



### 6.1.9 [101. 对称二叉树(Easy)](https://leetcode-cn.com/problems/symmetric-tree/)

> 给定一个二叉树，检查它是否是镜像对称的。
>
> 
>
> 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
>
> 
>
> 1 
>
> / \
> 2   2
> / \ / \
> 3  4 4  3
>
>
> 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
>
> ​	1
>
> / \
> 2   2
> \   \
> 3    3
>
>
> 进阶：
>
> 你可以运用递归和迭代两种方法解决这个问题吗？

```python
"""
todo迭代
"""
```



### 6.1.10 [111. 二叉树的最小深度(Easy)](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> 说明：叶子节点是指没有子节点的节点。
>
> **示例 1：**
>
> 输入：root = [3,9,20,null,null,15,7]
> 输出：2
> **示例 2：**
>
> 输入：root = [2,null,3,null,4,null,5,null,6]
> 输出：5

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        if not root.left and not root.right:
            return 1
        
        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth)
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth)
        
        return min_depth + 1
```



### 6.1.11 [404. 左叶子之和(Easy)](https://leetcode-cn.com/problems/sum-of-left-leaves/)

> 计算给定二叉树的所有左叶子之和。
>
> 示例：
>
> ​    3
>
> / \
> 9  20
> /  \
> 15   7
>
> 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

```python

```



### 6.1.12 [687. 最长同值路径(Medium)](https://leetcode-cn.com/problems/longest-univalue-path/)

> 给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
>
> 注意：两个节点之间的路径长度由它们之间的边数表示。
>
> **示例 1:**
>
> 输入:
>
>         5
>        / \
>       4   5
>      / \   \
>     1   1   5
>
> 输出:
>
> 2
> **示例 2:**
>
> 输入:
>
>         1
>        / \
>       4   5
>      / \   \
>     4   4   5
>
> 输出:
>
> 2

![](Image 20210131 171501.png)



### 6.1.13 [337. 打家劫舍 III(Medium)-间隔遍历](https://leetcode-cn.com/problems/house-robber-iii/)-todo动态规划

> 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
>
> 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
>
> 示例 1:
>
> 输入: [3,2,3,null,3,null,1]
>
> 	3
> 	/ \
>
> 2   3
> \   \ 
> 3   1
>
> 输出: 7 
> 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
> 示例 2:
>
> 输入: [3,4,5,1,3,null,1]
>
> ​	3
> ​	/ \
>
> 4   5
> / \   \ 
> 1   3   1
>
> 输出: 9
> 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

```python
""" 
参考：https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/
1. 暴力法：比较爷爷+四个孙子 vs 两个儿子
	重复计算，如下图。
2. 方法二：使用哈希表储存计算结果

3. 动态规划 
任何一个节点能偷到的最大钱的状态可以定义为

当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱
当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数
root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])
root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;
"""
```



![Nebo_Cu.nebo_Page_1](C:/Users/H00379~1/AppData/Local/Temp/Nebo_Cu.nebo_Page_1.png)



### 6.1.14 [671. 二叉树中第二小的节点(Easy)](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

> 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
>
> 更正式地说，root.val = min(root.left.val, root.right.val) 总成立。
>
> 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
>
> 
>
> **示例 1：**
>
> 输入：root = [2,2,5,null,null,5,7]
> 输出：5
> 解释：最小的值是 2 ，第二小的值是 5 。
> **示例 2：**
>
> 输入：root = [2,2,2]
> 输出：-1
> 解释：最小的值是 2, 但是不存在第二小的值。

```python
"""
第二种方法看不懂 ，出现概率低，暴力法吧
"""
```

### 6.1.15 [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) gzl

### 6.1.16 [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) gzl

### 6.1.17 [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/) gzl

### 6.1.18 [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) gzl



## 6.2 层次遍历 

### 6.2.1 [637. 二叉树的层平均值(Easy)](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

> 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
>
> 
>
> **示例 1：**
>
> 输入：
> 3
> / \
> 9  20
> /  \
> 15   7
> 输出：[3, 14.5, 11]
> 解释：
> 第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。

```python
"""
方法1：深度优先搜索（递归），通过传递层数记录在哪层

方法2（通用的树的层次遍历，主要掌握这种）：广度优先搜索，通过队列储存当前层的节点，
"""
```

### 6.2.2 [513. 找树左下角的值(Easy)](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

> 给定一个二叉树，在树的最后一行找到最左边的值。

```python
"""
广度优先搜索，只需要记录最后一层第一个元素
"""
```

### 6.2.3 [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) gzl

### 6.2.4 [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) gzl

### 6.2.5 [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) gzl

### 6.2.6 [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/) gzlkl

### 6.2.7 [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) gzl

### 6.2.8 [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)  gzl

### 6.2.9[863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/) gzlkl

### 6.2.10 [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) gzl

### 6.2.11 [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) gzlkl

### 6.2.12 [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/) gzl

### 6.2.13 [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/) gzl



## 6.3 前中后序遍历

##

>1
>/ \
>2 3
>/ \ \
>4 5 6
>层次遍历顺序：[1 2 3 4 5 6]
>前序遍历顺序：[1 2 4 5 3 6]
>中序遍历顺序：[4 2 5 1 3 6]
>后序遍历顺序：[4 5 2 6 3 1]
>
>
>
>① 前序
>void dfs(TreeNode root) {
>visit(root);
>dfs(root.left);
>dfs(root.right);
>}
>② 中序
>void dfs(TreeNode root) {
>dfs(root.left);
>visit(root);
>dfs(root.right);
>}
>③ 后序
>void dfs(TreeNode root) {
>dfs(root.left);
>dfs(root.right);
>visit(root);
>}
>
>
>
>[史上最全遍历二叉树详解](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/)



**一招解决迭代法**

![image-20210204082221959](image-20210204082221959.png)



### 6.3.1 [144. 二叉树的前序遍历(Medium)](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

> 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。
>
> **进阶：**递归算法很简单，你可以通过迭代算法完成吗？

```python
"""
递归法：

迭代法:

public static void preOrderIteration(TreeNode head) {
	if (head == null) {
		return;
	}
	Stack<TreeNode> stack = new Stack<>();
	stack.push(head);
	while (!stack.isEmpty()) {
		TreeNode node = stack.pop();
		System.out.print(node.value + " ");
		if (node.right != null) {
			stack.push(node.right);
		}
		if (node.left != null) {
			stack.push(node.left);
		}
	}
}

public List<Integer> preorderTraversal(TreeNode root) {
List<Integer> ret = new ArrayList<>();
Stack<TreeNode> stack = new Stack<>();
stack.push(root);
while (!stack.isEmpty()) {
TreeNode node = stack.pop();
if (node == null) continue;
ret.add(node.val);
stack.push(node.right); // 先右后左，保证左子树先遍历
stack.push(node.left);
}
return ret;
}

"""
```





### 6.3.2 [145. 二叉树的后序遍历(Medium)](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

> 给定一个二叉树，返回它的 *后序* 遍历。
>
> **进阶:** 递归算法很简单，你可以通过迭代算法完成吗？
>
> ![image-20210203221341421](image-20210203221341421.png)

```python
"""
递归法：

迭代法:
前序遍历为 root -> left -> right，后序遍历为 left -> right -> root。
可以通过前序遍历交互left right得到成为 root -> right -> left。最后再取reverse，得到后序遍历 left -> right -> root

"""
```



### 6.3.3 [94. 二叉树的中序遍历(Medium)](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。
>
> **进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

```python
"""
递归法：

迭代法:

"""
```



## 6.4 二叉查找树（BST）

> **记忆点：**
>
> 二叉查找树：中序遍历有序。！！！一看到二叉搜索树就要想起这个中序遍历有序！

### 6.4.1 [669. 修剪二叉搜索树(Medium)](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)



### 6.4.2 [230. 二叉搜索树中第K小的元素(Medium)](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```PYTHON
"""
递归法:必须遍历完整棵树，时间复杂度O(n),空间复杂度O(1)

迭代法：可以提前终止，时间复杂度O(H+k)，其中H是树的高度；空间复杂度O(H+k)
"""
```



### 6.4.3 [538. 把二叉搜索树转换为累加树(Medium)](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

> 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
>
> 提醒一下，二叉搜索树满足下列约束条件：
>
> 节点的左子树仅包含键 小于 节点键的节点。
> 节点的右子树仅包含键 大于 节点键的节点。
> 左右子树也必须是二叉搜索树。
> 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同
>
> 
>
> **示例 1：**
>
> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png)**
>
> 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
> 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
> 示例 2：
>
> 输入：root = [0,null,1]
> 输出：[1,null,1]
> 示例 3：
>
> 输入：root = [1,0,2]
> 输出：[3,3,2]
> 示例 4：
>
> 输入：root = [3,2,4,1]
> 输出：[7,9,4,10]

```python
"""
1. right->root->left 是中序遍历的逆序
2. ret是全部变量即可
"""
```



### 6.4.4 [235. 二叉搜索树的最近公共祖先(Easy)](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>
> 例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)
>
> **示例 1:**
>
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
> 输出: 6 
> 解释: 节点 2 和节点 8 的最近公共祖先是 6。

![image-20210205092155697](image-20210205092155697.png)



### 6.4.5 [236. 二叉树的最近公共祖先(Medium)](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>
> 例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
>
> ![image-20210204230232565](image-20210204230232565.png)
>
> 示例 1:
>
> 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
> 输出: 3
> 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

[题解](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)

```PYTHON
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        return self.find(root, p, q)


    def find(self, root: TreeNode, p:TreeNode, q:TreeNode) -> TreeNode:
        if root is None or root==p or root==q:
            return root
        rleft = self.find(root.left, p, q)
        rright = self.find(root.right, p, q)

        if rleft and rright:
            return root

        if rleft:
            return rleft
        elif rright:
            return rright
        else:
            return None
```



### 6.4.6 [108. 将有序数组转换为二叉搜索树(Easy)](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

> 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
>
> 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
>
> **示例:**
>
> 给定有序数组: [-10,-3,0,5,9],
>
> 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
>
> 	0
> 	/ \
>
> -3   9
> /   /
> -10  5

```PYTHON
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def s2(self, nums:List[int], left:int,right:int) -> TreeNode:
            '两个数分割：会产生两种区间：right=left的和left>right的，要分开处理
            if left > right: 
                return None

            mid = (left+right)//2
            root = TreeNode(nums[mid])
            root.left = s2(left , mid-1)
            root.right = s2(mid+1,right)
            return root
        return s2(nums,0,len(nums) - 1)
```



### 6.4.7 [109. 有序链表转换二叉搜索树(Medium)](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

> 给定的有序链表： [-10, -3, 0, 5, 9],
>
> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
>
> ​      0
> ​     / \
>
> -3   9
> /   /
> -10  5

```python
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getLength(head:ListNode) -> int:
            length = 0
            temp = head
            while temp is not None:
                length += 1
                temp = temp.next
            return length

        def s2(left:int,right:int)->TreeNode:
            if left > right: return None

            mid = (left+right) // 2
            root = TreeNode()
            root.left = s2(left,mid-1)
            nonlocal head 
            root.val = head.val
            head = head.next
            root.right = s2(mid+1,right)
            return root
      
        length = getLength(head)
        return s2(0, length - 1)
```



### 6.4.8 [653. 两数之和 IV - 输入 BST(Easy)](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

> 给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
>
> **案例 1:**
>
> 输入: 
>  5
> / \
> 3   6
> / \   \
> 2   4   7
>
> Target = 9
>
> 输出: True

```python
"""
时间复杂度ON
"""
```



### 6.4.9 [530. 二叉搜索树的最小绝对差(Easy)](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

> 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
>
> 
>
> 示例：
>
> 输入：
>
> 1
>  \
>   3
>  /
> 2
>
> 输出：
> 1
>
> 解释：
> 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。

![530.二叉搜索树的最小绝对差.png](https://pic.leetcode-cn.com/1602466619-nLWwGs-530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.png)

```python
"""
看着可以很简单，直接比较root与left，right，但其实是错的。二叉搜索树的root跟孩子不是相差最小的，比如上图，如果只比较root和左右孩子，结果是3。
"""
```



### 6.4.10 [501. 二叉搜索树中的众数(Easy)](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

> 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
>
> 例如：
> 给定 BST `[1,null,2,2]`,
>
> 1
>  \
>   2
>  /
> 2
>
> `返回[2]`.
>
> **提示**：如果众数超过1个，不需考虑输出顺序
>
> **进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

```PYTHON
"""
答案可能不止一个，也就是有多个值出现的次数一样多,返回的是数组
TOOD:方法二：Morris 中序遍历。空间复杂度O1
"""
```

### 6.4.11[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)gzl

## 6.5 Trie

> Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。
>
> 
>
> #### 应用
>
> Trie (发音为 "try") 或前缀树是一种树数据结构，用于检索字符串数据集中的键。这一高效的数据结构有多种应用：
>
> ##### 1. 自动补全
>
> ##### 2. 拼写检查
>
> ##### 3. IP 路由 (最长前缀匹配)
>
> ##### 4. T9 (九宫格) 打字预测
>
> ##### 5. 单词游戏
>
> 
>
> 还有其他的数据结构，如平衡树和哈希表，使我们能够在字符串数据集中搜索单词。为什么我们还需要 Trie 树呢？尽管哈希表可以在 O(1)O(1) 时间内寻找键值，却无法高效的完成以下操作：
>
> 找到具有同一前缀的全部键值。
> 按词典序枚举字符串的数据集。
> Trie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 O(n)O(n)，其中 nn 是插入的键的数量。与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要 O(m)O(m) 的时间复杂度，其中 mm 为键长。而在平衡树中查找键值需要 O(m \log n)O(mlogn) 时间复杂度。
>
> Trie 树的结点结构
> Trie 树是一个有根的树，其结点具有以下字段：。
>
> 最多 RR 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。
> 本文中假定 RR 为 26，小写拉丁字母的数量。
> 布尔字段，以指定节点是对应键的结尾还是只是键前缀。
>
> ![image-20210208220226538](image-20210208220226538.png)
>
> *图 6. 单词 "leet" 在 Trie 树中的表示*
>
> ```java
> class TrieNode {
>  // R links to node children
>  private TrieNode[] links;
>  private final int R = 26;
>  private boolean isEnd;
>  public TrieNode() {
>      links = new TrieNode[R]; // 初始化26个元素数组，套娃。。
>  }
>  public boolean containsKey(char ch) {
>      return links[ch -'a'] != null;
>  }
>  public TrieNode get(char ch) {
>      return links[ch -'a'];
>  }
>  public void put(char ch, TrieNode node) {
>      links[ch -'a'] = node;
>  }
>  public void setEnd() {
>      isEnd = true;
>  }
>  public boolean isEnd() {
>      return isEnd;
>  }
> }
> ```
>
> 向 Trie 树中插入键
> 我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：
>
> 链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。
> 链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。
> 重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。
>
> ![image-20210208221422131](image-20210208221422131.png)

### 6.5.1 [208. 实现 Trie (前缀树)(Medium)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

> 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
>
> **示例:**
>
> Trie trie = new Trie();
>
> trie.insert("apple");
> trie.search("apple");   // 返回 true
> trie.search("app");     // 返回 false
> trie.startsWith("app"); // 返回 true
> trie.insert("app");   
> trie.search("app");     // 返回 true
> **说明:**
>
> 你可以假设所有的输入都是由小写字母 a-z 构成的。
> 保证所有输入均为非空字符串。

```python
class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.lookup = {}
        

    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        tree = self.lookup
        for a in word:
            if a not in tree:
                tree[a] = {}
            tree = tree[a]
        # 单词结束标志
        tree["#"] = "#"
        

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        tree = self.lookup
        for a in word:
            if a not in tree:
                return False
            tree = tree[a]
        if "#" in tree:
            return True
        return False
        

    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        tree = self.lookup
        for a in prefix:
            if a not in tree:
                return False
            tree = tree[a]
        return True
```



### 6.5.2 [677. 键值映射(Medium)](https://leetcode-cn.com/problems/map-sum-pairs/)

```python
class MapSum:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.lookup = {}


    def insert(self, key: str, val: int) -> None:
        tree = self.lookup
        for k in key:
            if k not in tree:
                tree[k] = {}
            tree = tree[k]
        tree['$'] = val


    def sum(self, prefix: str) -> int:
        tree = self.lookup
        ret = 0
        for k in prefix:
            if k not in tree:
                return 0
            tree = tree[k]
        ret = 0
        def dsf(tree: dict):
            for k, v in tree.items():
                print(k, v)
                if k == '$':
                    nonlocal ret 
                    ret += v
                else:
                    dsf(v)

        dsf(tree)
        return ret
```



# 7.图

## 7.1 二分图

> 二分图：可以用两种颜色对节点着色，并保证相邻节点颜色不同。

### 7.1.1 [785. 判断二分图(Medium)](https://leetcode-cn.com/problems/is-graph-bipartite/)

> 给定一个无向图graph，当这个图为二分图时返回true。
>
> 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。
>
> **graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。**每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。
>
> **示例 1:**
> 输入: [[1,3], [0,2], [1,3], [0,2]]
> 输出: true
> 解释: 
> 无向图如下:
> 0----1
> |    |
> |    |
> 3----2
> 我们可以将节点分成两组: {0, 2} 和 {1, 3}。
>
> **示例 2:**
> 输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
> 输出: false
> 解释: 
> 无向图如下:
> 0----1
> | \  |
> |  \ |
> 3----2
> 我们不能将节点分割成两个独立的子集。
> 注意:
>
> graph 的长度范围为 [1, 100]。szd
> graph[i] 中的元素的范围为 [0, graph.length - 1]。
> graph[i] 不会包含 i 或者有重复的值。
> 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。

```PYTHON
"""
1.深度优先遍历
"""
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)  # 邻接表方式，graph[i]表示图中与节点i相连的所有节点
        UNCOLORED, RED, GREEN = 0, 1, 2 # 定义全局常量
        colors = [UNCOLORED] * n # 初始化着色记录
        valid = True    # 不符合条件提前跳出
        
        def dsf(node: int, color: int):
            nonlocal valid
            colors[node] = color
            nextColor = GREEN if color == RED else RED
            for k in graph[node]:
                if colors[k] == UNCOLORED:
                    dsf(k, nextColor)
                    if valid == False:
                        return 
                elif colors[k] != nextColor:
                    valid = False
                    return 

        for i in range(n): # 邻接表方式，可以通过for循环，传入i，无需传入具体节点
            if colors[i] == UNCOLORED:
                dsf(i, RED) # 表示i节点将着色RED？
            if valid == False:
                break
        return valid

"""
2. 广度优先遍历
"""
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        colors = [UNCOLORED] * n

        for k in range(n):
            if colors[k] == UNCOLORED:
                stack = collections.deque([k]) # 创建deque需要容器，插入用append
                colors[k] = RED
                while stack:
                    node = stack.popleft()
                    nextColor = (GREEN if colors[node] == RED else RED)
                    for j in graph[node]:
                        if colors[j] == UNCOLORED:
                            stack.append(j)
                            colors[j] = nextColor
                        elif colors[j] != nextColor:
                            return False

        return True

```





## 7.2 拓扑排序

> 拓扑排序：对一个[有向无环图](https://baike.baidu.com/item/有向无环图/10972513)(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。

###  7.2.1 [207. 课程表(Medium)](https://leetcode-cn.com/problems/course-schedule/)

> 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
>
> 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
> 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
>
> 
>
> 示例 1：
>
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：true
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
> 示例 2：
>
> 输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
> 输出：false
> 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
>
>
> 提示：
>
> 1 <= numCourses <= 105
> 0 <= prerequisites.length <= 5000
> prerequisites[i].length == 2
> 0 <= ai, bi < numCourses
> prerequisites[i] 中的所有课程对 互不相同

```PYTHON
"""
1.需要转换为邻接表
2.判断图中是否有环即可
"""

"""
一、深度优先遍历
"""
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        edges = collections.defaultdict(list) # defaultdict不用担心取不到key报异常
        visited = [0] * numCourses
        result = list()
        valid = True

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            nonlocal valid
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)
                    if not valid:
                        return
                elif visited[v] == 1:
                    valid = False
                    return
            visited[u] = 2
            result.append(u)
        
        for i in range(numCourses):
            if valid and not visited[i]:
                dfs(i)
        
        return valid
```



### 7.2.2 [210. 课程表 II(Medium)](https://leetcode-cn.com/problems/course-schedule-ii/)

> 现在你总共有 n 门课需要选，记为 0 到 n-1。
>
> 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
>
> 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
>
> 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
>
> **示例 1:**
>
> 输入: 2, [[1,0]] 
> 输出: [0,1]
> 解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
> **示例 2:**
>
> 输入: 4, [[1,0],[2,0],[3,1],[3,2]]
> 输出: [0,1,2,3] or [0,2,1,3]
> 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
>   因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。

```python
"""
与上题差不多,使用 DFS 来实现拓扑排序，使用一个栈存储后序遍历结果，这个栈的逆序结果就是拓扑
排序结果。
"""
```



## 7.3 并查集 

### 7.3.1 [684. 冗余连接(Medium)](https://leetcode-cn.com/problems/redundant-connection/)

> 在本问题中, 树指的是一个连通且无环的无向图。
>
> 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。
>
> 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。
>
> 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。
>
> 示例 1：
>
> 输入: [[1,2], [1,3], [2,3]]
> 输出: [2,3]
> 解释: 给定的无向图为:
> 1
> / \
> 2 - 3
> 示例 2：
>
> 输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
> 输出: [1,4]
> 解释: 给定的无向图为:
> 5 - 1 - 2
>  |   |
>  4 - 3



# 8.位运算

| 符号 | 描述 | 运算规则                                                     |
| :--- | :--- | :----------------------------------------------------------- |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

## 8.0 基本原理 

## 8.1 [461. 汉明距离(Easy)(二进制不同位数)](https://leetcode-cn.com/problems/hamming-distance/)

## 8.2 [136. 只出现一次的数字(Easy)](https://leetcode-cn.com/problems/single-number/)

## 8.3 [268. 丢失的数字(Easy)](https://leetcode-cn.com/problems/missing-number/)

> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
>
> 
>
> 进阶：
>
> 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?
>
> **示例 1：**
>
> 输入：nums = [3,0,1]
> 输出：2
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失

```python
"""
方法1：哈希表，时间复杂度On，空间复杂度On

方法2：参见上题268，时间复杂度On，空间复杂度O1
"""
```

## 8.4 [260. 只出现一次的数字 III(Medium)](https://leetcode-cn.com/problems/single-number-iii/)

>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
>
>
>
>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
>
>
>
>示例 1：
>
>输入：nums = [1,2,1,3,2,5]
>输出：[3,5]
>解释：[5, 3] 也是有效的答案。
>示例 2：
>
>输入：nums = [-1,0]
>输出：[-1,0]
>示例 3：
>
>输入：nums = [0,1]
>输出：[1,0]
>提示：
>
>2 <= nums.length <= 3 * 104
>-231 <= nums[i] <= 231 - 1
>除两个只出现一次的整数外，nums 中的其他数字都出现两次

```python
"""
方法很巧妙，感觉很快忘记
"""
```



## 8.5 [190. 颠倒二进制位(Easy)](https://leetcode-cn.com/problems/reverse-bits/)

>颠倒给定的 32 位无符号整数的二进制位。
>
>**示例 1：**
>
>输入: 00000010100101000001111010011100
>输出: 00111001011110000010100101000000
>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
>因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
>**示例 2：**
>
>输入：11111111111111111111111111111101
>输出：10111111111111111111111111111111
>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
>因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

```PYTHON
"""
1.取最右一位(记住：n&1 取最右一位)
2.左移32-i位
"""
```



## 8.6 不用额外变量交换两个整数(程序员代码面试指南P317)

## 8.7 [231. 2的幂(Easy)](https://leetcode-cn.com/problems/power-of-two/)

> 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
>
> **示例 1:**
>
> 输入: 1
> 输出: true
> 解释: 20 = 1
> **示例 2:**
>
> 输入: 16
> 输出: true
> 解释: 24 = 16
> **示例 3:**
>
> 输入: 218
> 输出: false

```python
"""
方法1：n&(n-1) == 0

解析：
    首先，2次幂的特点：1个1+N个0
    1： 1
    2：10
    4：100
    8：1000

    x-1: 最右边的1变成0，最右边1右边的0变成1
    若x只有1个0 ，则x&(x-1)就没有0了
    若x超过1个0，则x&(x-1)不等于0

"""
```



## 8.8 [342. 4的幂(Easy)](https://leetcode-cn.com/problems/power-of-four/)

> 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。
>
> 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x

```python
"""
1. 2的幂（上一题）
2. 并且奇数位不能位1：1010.....1010"与" 为0，也即 num & 0xaaaaaaaa == 0
"""

class Solution:
    def isPowerOfFour(self, num: int) -> bool:
        return num > 0 and num & (num - 1) == 0 and num & 0x10101010101010....10101010 == 0
```



## 8.9 [693. 交替位二进制数(Easy)](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)

> 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。
>
> **示例 1：**
>
> 输入：n = 5
> 输出：true
> 解释：5 的二进制表示是：101
> **示例 2：**
>
> 输入：n = 7
> 输出：false
> 解释：7 的二进制表示是：111.
> **示例 3：**
>
> 输入：n = 11
> 输出：false
> 解释：11 的二进制表示是：1011.
> **示例 4：**
>
> 输入：n = 10
> 输出：true
> 解释：10 的二进制表示是：1010.
> **示例 5：**
>
> 输入：n = 3
> 输出：false

```python
"""
1. 如何转化为0000001111111   A  
2. 0000000111111-1 = 11111111000000000  B
3. A & B == 0
"""
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        tmp = n^(n>>1)
        return tmp&(tmp+1) == 0
```

![image-20210217212355607](image-20210217212355607.png)

![image-20210217212406158](image-20210217212406158.png)



## 8.10 [476. 数字的补数(Easy)(看不懂，出现频率很低)](https://leetcode-cn.com/problems/number-complement/)

> 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。
>
> **示例 1:**
>
> 输入: 5
> 输出: 2
> 解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
> **示例 2:**
>
> 输入: 1
> 输出: 0
> 解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。



# 9. 双指针

## 9.1 [167. 两数之和 II - 输入有序数组(Easy)](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
>
> 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。
>
> 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
>
> **示例 1：**
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
> **示例 2：**
>
> 输入：numbers = [2,3,4], target = 6
> 输出：[1,3]
> **示例 3：**
>
> 输入：numbers = [-1,0], target = -1
> 输出：[1,2]

```python
"""
其实并不容易想到，时间复杂度为On的方法（首尾双指针法）。
为什么双指针法不会漏掉某些情况？https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/
"""
```



## 9.2 [633. 平方数之和(Medium)](https://leetcode-cn.com/problems/sum-of-square-numbers/)

> 给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a^2 + b^2 = c` 。
>
> **示例 1：**
>
> 输入：c = 5
> 输出：true
> 解释：1 * 1 + 2 * 2 = 5
> **示例 2：**
>
> 输入：c = 3
> 输出：false
> **示例 3：**
>
> 输入：c = 4
> 输出：true
> **示例 4：**
>
> 输入：c = 2
> 输出：true
> **示例 5：**
>
> 输入：c = 1
> 输出：true

```python
"""
1. a，b范围肯定在[0,Square(c)]
	0：因为负数的平方是正数，所以a大于0包含了小于0的情况。
	square(c): 如果a > square（c） ， 结果a^2+b^2 肯定大于c
2. 参考167题使用首位双指针搜索。时间复杂度为0n
"""
```



## 9.3 [345. 反转字符串中的元音字母(Easy)](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

> 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。
>
> **示例 1：**
>
> 输入："hello"
> 输出："holle"
> **示例 2：**
>
> 输入："leetcode"
> 输出："leotcede"

```python
"""很简单"""
```



## 9.4 [680. 验证回文字符串 Ⅱ(Easy)](https://leetcode-cn.com/problems/valid-palindrome-ii/)

> 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
>
> **示例 1:**
>
> 输入: "aba"
> 输出: True
> **示例 2:**
>
> 输入: "abca"
> 输出: True
> 解释: 你可以删除c字符。

```python
"""
1. 贪心算法
2. 时间复杂度其实只有O(n)
"""
```



## 9.5 [88. 合并两个有序数组(Easy)](https://leetcode-cn.com/problems/merge-sorted-array/)

> 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
>
> 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
>
> **示例 1：**
>
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> **示例 2：**
>
> 输入：nums1 = [1], m = 1, nums2 = [], n = 0
> 输出：[1]

```python
"""
双指针法，从后往前。
时间复杂度On，空间复杂度O1
"""
```



## 9.6 [141. 环形链表(Easy)](https://leetcode-cn.com/problems/linked-list-cycle/)

> 给定一个链表，判断链表中是否有环。

```python

```



## 9.7 [524. 通过删除字母匹配到字典里最长单词(Medium)](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

> 给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。

```python
"""
方法 4：不需要排序
时间复杂度： O(n*x) 。这里 n 是列表 d 中字符串的数目， x 是字符串平均长度。
空间复杂度： O(x) 。使用了变量 max_str 。
"""
```

## 9.8 [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

> 给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 `0` 且不重复的三元组。
>
> **注意：**答案中不可以包含重复的三元组。
>
> **示例 1：**
>
> ```
> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2],[-1,0,1]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [0]
> 输出：[]
> ```

```python
# 为保证不重复，需要先排序，三层循环的起始位是上层当前位+1
nums.sort()
for first = 0 .. n-1
    // 只有和上一次枚举的元素不相同，我们才会进行枚举
    if first == 0 or nums[first] != nums[first-1] then
        for second = first+1 .. n-1
            if second == first+1 or nums[second] != nums[second-1] then
                for third = second+1 .. n-1
                    if third == second+1 or nums[third] != nums[third-1] then
                        // 判断是否有 a+b+c==0
                        check(first, second, third)
可以发现，如果我们固定了前两重循环枚举到的元素a和b，那么只有唯一的c满足 a+b+c=0。当第二重循环往后枚举一个元素 b′时，由于 b>b′，那么满足 a+b′+c=0 的 c′一定有 c<c′，即c在数组中一定出现在c的左侧。也就是说，我们可以从小到大枚举b，同时从大到小枚举c，即第二重循环和第三重循环实际上是并列的关系。
有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针，从而得到下面的伪代码：
nums.sort()
for first = 0 .. n-1
    if first == 0 or nums[first] != nums[first-1] then
        // 第三重循环对应的指针
        third = n-1
        for second = first+1 .. n-1
            if second == first+1 or nums[second] != nums[second-1] then
                // 向左移动指针，直到 a+b+c 不大于 0
                while nums[first]+nums[second]+nums[third] > 0
                    third = third-1
                // 判断是否有 a+b+c==0
                check(first, second, third)
```

## 9.9 [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/) gzl

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>
> **示例：**
>
> 输入：nums = [-1,2,1,-4], target = 1
> 输出：2
> 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

## 9.10 [18. 四数之和](https://leetcode-cn.com/problems/4sum/) gzl

> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
>
> 注意：答案中不可以包含重复的四元组。
>
> 
>
> 示例 1：
>
> 输入：nums = [1,0,-1,0,-2,2], target = 0
> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
> 示例 2：
>
> 输入：nums = [], target = 0
> 输出：[]

## 9.11 [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/) gzl tx

## 9.12 [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) gzl

## 9.13 [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/) gzlkl



## 9.20 滑动窗口

>**【总结】**
>
>**滑动窗口题目：**
>
>[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
>
>[30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)
>
>[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
>
>[159. 至多包含两个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/)
>
>[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
>
>[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
>
>[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)
>
>[632. 最小区间](https://leetcode-cn.com/problems/smallest-range/)
>
>[727. 最小窗口子序列](https://leetcode-cn.com/problems/minimum-window-subsequence/)

### 9.20.1 [28. 实现 strStr()(Easy)](https://leetcode-cn.com/problems/implement-strstr/)

>实现 strStr() 函数。
>
>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
>
>**示例 1:**
>
>输入: haystack = "hello", needle = "ll"
>输出: 2
>**示例 2:**
>
>输入: haystack = "aaaaa", needle = "bba"
>输出: -1
>**说明:**
>
>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
>
>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。



### 9.20.2 [340. 至多包含 K 个不同字符的最长子串(Medium)](https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/)

> 给定一个字符串 s ，找出 至多 包含 k 个不同字符的最长子串 T。
>
> **示例 1:**
>
> 输入: s = "eceba", k = 2
> 输出: 3
> 解释: 则 T 为 "ece"，所以长度为 3。
> **示例 2:**
>
> 输入: s = "aa", k = 1
> 输出: 2
> 解释: 则 T 为 "aa"，所以长度为 2。
>
> **示例3:**
>
> 输入: s = "loveleetcode", k = 4

```python
"""
总结：1. 什么时候适合用滑动窗口：遍历可知跳过下次遍历边界值，用滑动窗口，时间复杂度O(N^2)降到O(N*k)
思路：
1.如果用滑动窗口，左指针什么时候需要右移好判断（哈希表元size>k），但是若左指针只右移一位，可能哈希表size还是>k，我们怎样知道右移到哪可以保证哈希表较少一个元素？
  哈希表存放的是每个字符最右边的位置，找到最小的value，左指针移动到value+1位置，可以保证哈希表size减1、
  
第二次刷：loveleetcode为例，右指针到t时，左指针直接到l是不对的，比如loveleetvvvvvvvvvvvvvvvvvvvv。以l出现2次左指针移动2个位置到v，也是不对的,例如loveloeetcode。应该是想想左指针移动如何保证 窗口内不同字母数减1。

窗口初始大小直接就是k？对复杂度并没有多少提高
方法一：使用普通hash记录
	最坏情况是没有重复字符，每移动一次右指针，都要移动左指针（移动到哪需要找min,时间复杂度O(k)），时间复杂度O(N*k)
	
方法二：有序字典，时间复杂度O(N)
"""
```



### 9.20.3 [3.无重复字符的最长字串(Medium)](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
>
> 
>
> **示例 1:**
>
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> **示例 2:**
>
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> **示例 3:**
>
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
> 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> **示例 4:**
>
> 输入: s = ""
> 输出: 0

```python
"""
具体实现利用【滑动窗口】: 时间复杂度O(N)
20210219: 原理很简单，好的实现不简单。出现频率高。
"""

""" TODO: https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/
```



### 9.20.4 [30. 串联所有单词的子串(Hard)](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

> 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
>
> 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
>
> **示例 1：**
>
> 输入：
> s = "barfoothefoobarman",
> words = ["foo","bar"]
> 输出：[0,9]
> 解释：
> 从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
> 输出的顺序不重要, [9,0] 也是有效答案。
> **示例 2：**
>
> 输入：
> s = "wordgoodgoodgoodbestword",
> words = ["word","good","best","word"]
> 输出：[]

```python
"""
注意给出的字符串数组words单词长度相等。
至少想出第一种方法吧。

第二种方法就是3种情况的跳过遍历：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/
1. 已经存在不符合，下次跳过
	1. 单词不符合
	1. 单词重复超出
2. 已经判断过的单词，下次遍历中无需判断（保留hashmap）
"""
```

### 9.20.5 [76.最小覆盖子串(Hard)](https://leetcode-cn.com/problems/minimum-window-substring/)

> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
>
> 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。
>
> **示例 1：**
>
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
> **示例 2：**
>
> 输入：s = "a", t = "a"
> 输出："a"
>
>
> 提示：
>
> 1 <= s.length, t.length <= 105
> s 和 t 由英文字母组成
>
> **进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？**

```PYTHON
"""
https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/
注意，t中可能存在重复，因此要记录出现的次数

滑动窗口，为什么能用滑动窗口？靠熟练感觉？
1. 需要两个hashmap存储，和比较
"""
```

### 9.20.6 [159. 至多包含两个不同字符的最长子串(Medium)](https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/)

> 给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。
>
> **示例 1:**
>
> 输入: "eceba"
> 输出: 3
> 解释: t 是 "ece"，长度为3。
> **示例 2:**
>
> 输入: "ccaabbb"
> 输出: 5
> 解释: t 是 "aabbb"，长度为5。

```python
"""
与上题类似。
"""
```



### 9.20.7 [209. 长度最小的子数组(Medium)](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

> 给定一个含有 n 个正整数的数组和一个正整数 target 。
>
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
>
> **示例 1：**
>
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> **示例 2：**
>
> 输入：target = 4, nums = [1,4,4]
> 输出：1
> **示例 3：**
>
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0

```python
"""
什么时候移右指针什么时候回移左指针？
"""
```



### 9.20.8 [239. 滑动窗口最大值(Hard)](https://leetcode-cn.com/problems/sliding-window-maximum/)

> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
>
> 返回滑动窗口中的最大值。
>
> **示例 1：**
>
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
>
> ---------------               -----
>
> [1  3  -1] -3  5  3  6  7       3
> 1 [3  -1  -3] 5  3  6  7       3
> 1  3 [-1  -3  5] 3  6  7       5
> 1  3  -1 [-3  5  3] 6  7       5
> 1  3  -1  -3 [5  3  6] 7       6
> 1  3  -1  -3  5 [3  6  7]      7
> **示例 2：**
>
> 输入：nums = [1], k = 1
> 输出：[1]
> **示例 3：**
>
> 输入：nums = [1,-1], k = 1
> 输出：[1,-1]
> **示例 4：**
>
> 输入：nums = [9,11], k = 2
> 输出：[11]
> **示例 5：**
>
> 输入：nums = [4,-2], k = 2
> 输出：[4]

```python
"""
看上去很简单，时间复杂度是O(n*k)。
但是如何优化到O(n)：每个窗口前进的时候，要添加一个数同时减少一个数，所以想在O(1)的时间得出新的最值，就需要「单调队列」这种特殊的数据结构来辅助了。介绍单调队列（下图）。

本题利用单调递减的单调队列达到目的。（下图是单调递增的单调队列）
窗口前进时：
1.比右指针更小的值可以永久删掉了。单调队列的 push 方法：队尾添加元素，把前面比新元素小的元素都删掉。
2.左指针的元素不等于队首元素时，表示左指针元素已提前删除，也就是左指针右边存在比它更大的元素。因此左指针移动时需要pop(n)，判断n==front，则pop掉队首元素。
"""
```

![image-20210221175127945](image-20210221175127945.png)





### 9.20.9 [567. 字符串的排列(Medium)](https://leetcode-cn.com/problems/permutation-in-string/)

> 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
>
> 换句话说，第一个字符串的排列之一是第二个字符串的子串。
>
> 
>
> 示例 1：
>
> 输入: s1 = "ab" s2 = "eidbaooo"
> 输出: True
> 解释: s2 包含 s1 的排列之一 ("ba").
> 示例 2：
>
> 输入: s1= "ab" s2 = "eidboaoo"
> 输出: False
>
> **提示：**
>
> - 输入的字符串只包含小写字母

```PYTHON
"""
与76的简单版，因为匹配字符串要连续，也就是长度固定，也就左右指针同时移动。
总结：排列组合使用hashmap记录
"""
```

### 9.20.10 [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)gzlkl



# 10.排序

[912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

![image-20210221213035483](image-20210221213035483.png)

```PYTHON
"""
面向找工作： https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/
1.快排
2.堆排序:
	理解：https://www.cnblogs.com/chengxiao/p/6129630.html
	实现：https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/
3.归并排序
"""


"""2.s堆排序"""
public class Solution {

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 将数组整理成堆
        heapify(nums);

        // 循环不变量：区间 [0, i] 堆有序
        for (int i = len - 1; i >= 1; ) {
            // 把堆顶元素（当前最大）交换到数组末尾
            swap(nums, 0, i);
            // 逐步减少堆有序的部分
            i--;
            // 下标 0 位置下沉操作，使得区间 [0, i] 堆有序
            siftDown(nums, 0, i);
        }
        return nums;
    }

    /**
     * 将数组整理成堆（堆有序）
     *
     * @param nums
     */
    private void heapify(int[] nums) {
        int len = nums.length;
        // 只需要从 i = (len - 1) / 2 这个位置开始逐层下移
        for (int i = (len - 1) / 2; i >= 0; i--) {
            siftDown(nums, i, len - 1);
        }
    }

    /**
     * @param nums
     * @param k    当前下沉元素的下标
     * @param end  [0, end] 是 nums 的有效部分
     */
    private void siftDown(int[] nums, int k, int end) {
        while (2 * k + 1 <= end) {
            int j = 2 * k + 1;
            if (j + 1 <= end && nums[j + 1] > nums[j]) {
                j++;
            }
            if (nums[j] > nums[k]) {
                swap(nums, j, k);
            } else {
                break;
            }
            k = j;
        }
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```



## 10.1 快速排序 [215. 数组中的第K个最大元素(Medium)](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

## 10.3 桶排序

### 10.3.1 [347. 前 K 个高频元素(Meidum)](https://leetcode-cn.com/problems/top-k-frequent-elements/)

> 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
>
> **示例 1:**
>
> 输入: nums = [1,1,1,2,2,3], k = 2
> 输出: [1,2]
> **示例 2:**
>
> 输入: nums = [1], k = 1
> 输出: [1]
>
> **提示：**
>
> 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
> 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
> 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
> 你可以按任意顺序返回答案。

```python
"""
桶排序最优，时间复杂度On，空间复杂度on
1. hashmap On
2. 频率作为下标，相同频率的放进同一个桶 on
3. 倒叙遍历所有桶  On
时间复杂度O(3n)
"""
```



### 10.3.2 [451. 根据字符出现频率排序(Medium)](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

> 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
>
> 示例 1:
>
> 输入:
> "tree"
>
> 输出:
> "eert"
>
> 解释:
> 'e'出现两次，'r'和't'都只出现一次。
> 因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。

```PYTHON
"""
容易想到桶排序，时间复杂度O(N)
"""
```



## 10.4 荷兰国旗问题

### 10.4.1 [75. 颜色分类(Medium)](https://leetcode-cn.com/problems/sort-colors/)

> 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
>
> **示例 1：**
>
> 输入：nums = [2,0,2,1,1,0]
> 输出：[0,0,1,1,2,2]
> 示例 2：
>
> 输入：nums = [2,0,1]
> 输出：[0,1,2]
> **示例 3：**
>
> 输入：nums = [0]
> 输出：[0]
> **示例 4：**
>
> 输入：nums = [1]
> 输出：[1]

```python
"""
遍历遇到0就交换到头部，遇到2则交换到尾部，遇到1跳过。

需要3个指针：1.cur用于遍历  2. head记录当前头部，表示可以放置0  3. tail标记当前尾部，表示可以放置2 

"""
public void sortColors(int[] nums) {
int zero = -1, one = 0, two = nums.length;
while (one < two) {
if (nums[one] == 0) {
swap(nums, ++zero, one++);
} else if (nums[one] == 2) {
swap(nums, --two, one);
} else {
++one;
}
}
}
private void swap(int[] nums, int i, int j) {
int t = nums[i];
nums[i] = nums[j];
nums[j] = t;
}
```



# 11. 二分查找

## 11.1 [69. x 的平方根(Easy)](https://leetcode-cn.com/problems/sqrtx/)

> 实现 int sqrt(int x) 函数。
>
> 计算并返回 x 的平方根，其中 x 是非负整数。
>
> 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
>
> **示例 1:**
>
> 输入: 4
> 输出: 2
> **示例 2:**
>
> 输入: 8
> 输出: 2
> 说明: 8 的平方根是 2.82842..., 
>   由于返回类型是整数，小数部分将被舍去。

```python
"""
easy也不容易想到。。
1. 注意是 ret^2 = x ，不是2^ret = x 
2. 0~x，二分法
"""
```



## 11.2 [744. 寻找比目标字母大的最小字母(Easy)](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

> 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。
>
> 在比较时，字母是**依序循环出现的**。举个例子：
>
> **如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'**
>
>
> 示例：
>
> 输入:
> letters = ["c", "f", "j"]
> target = "a"
> 输出: "c"

````python
"""注意依序循环的，意思是当二分查找找不到结果时，返回第一个"""
````



## 11.3 [540. 有序数组中的单一元素(Medium)](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

> 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
>
> **示例 1:**
>
> 输入: [1,1,2,3,3,4,4,8,8]
> 输出: 2
> **示例 2:**
>
> 输入: [3,3,7,7,10,11,11]
> 输出: 10
>
> **注意:** 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。

```python
"""
方法三：仅对偶数索引进行二分搜索
事实证明我们只需要对偶数索引进行二分搜索。这种方法与方法二都是不错的方法，但是该方法比方法二更加优雅。
在该算法中，我们对所有偶数索引进行搜索，直到遇到第一个其后元素不相同的索引。
我们可以使用二分搜索替代线性搜索。
在单个元素的后面，则成对的元素变为奇数索引后跟他们的同一元素。说明我们在检索单个元素后面的偶数索引时，其后都没有它的同一元素。因此，我们可以通过偶数索引确定单个元素在左侧还是右侧。
算法：

奇数长度的数组首尾元素索引都为偶数，因此我们可以将 lo 和 hi 设置为数组首尾。
我们需要确保 mid 是偶数，如果为奇数，则将其减 1。
然后，我们检查 mid 的元素是否与其后面的索引相同。
如果相同，则我们知道 mid 不是单个元素。且单个元素在 mid 之后。则我们将 lo 设置为 mid + 2。
如果不是，则我们知道单个元素位于 mid，或者在 mid 之前。我们将 hi 设置为 mid。
一旦 lo == hi，则当前搜索空间为 1 个元素，那么该元素为单个元素，我们将返回它。
"""
def singleNonDuplicate(self, nums: List[int]) -> int:
    lo = 0
    hi = len(nums) - 1
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if mid % 2 == 1:
            mid -= 1
        if nums[mid] == nums[mid + 1]:
            lo = mid + 2
        else:
            hi = mid
    return nums[lo]
```



## 11.4 [278. 第一个错误的版本(Easy)](https://leetcode-cn.com/problems/first-bad-version/)

> 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
>
> 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
>
> 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
>
> **示例:**
>
> 给定 n = 5，并且 version = 4 是第一个错误的版本。
>
> 调用 isBadVersion(3) -> false
> 调用 isBadVersion(5) -> true
> 调用 isBadVersion(4) -> true
>
> 所以，4 是第一个错误的版本。

```python
"""
就。。很容易
"""
```



## 11.5 [153. 寻找旋转排序数组中的最小值(Medium)](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。
>
> 请找出其中最小的元素。
>
> **示例 1：**
>
> 输入：nums = [3,4,5,1,2]
> 输出：1
> **示例 2：**
>
> 输入：nums = [4,5,6,7,0,1,2]
> 输出：0
> **示例 3：**
>
> 输入：nums = [1]
> 输出：1
>
> **提示：**
>
> 1 <= nums.length <= 5000
> -5000 <= nums[i] <= 5000
> nums 中的所有整数都是 唯一 的
> nums 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转

```python
"""
二分查找，关键是如何确定是在中点左边还是右边？

    如果左边有序，则第一个元素比中点小。
    如果右边有序，则最后一个元素比中点大。
    反之，该区间被旋转，最小值在该区间，这两种情况是互斥时间，只需要判断一种。
    
什么时候搜索成功？
	nums[mid] > nums[mid+1] ，mid+1是最小点
	或者nums[mid] < nums[mid-1]，mid是最小点
	由于mid可能是最后一个元素也可能是倒数第二个元素，所以上面两种情况都可能存在，不能只判断一种。
"""
```



## 11.6 [34. 在排序数组中查找元素的第一个和最后一个位置(Medium)](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) 0222

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 target，返回 [-1, -1]。
>
> 进阶：
>
> 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
>
> **示例 1：**
>
> 输入：nums = [5,7,7,8,8,10], target = 8
> 输出：[3,4]
> **示例 2：**
>
> 输入：nums = [5,7,7,8,8,10], target = 6
> 输出：[-1,-1]
> **示例 3：**
>
> 输入：nums = [], target = 0
> 输出：[-1,-1]

```python
"""
拆分成两个搜索：
1. 查找第一个等于target的位置
2. 查找第一个大于target的位置(为什么不是查找最后一个大于target的位置？？)

1. 查找第一个等于target
	回顾简单的查找：if nums[mid] == taget return; 
					if nums[mid] > target; right = mid-1;
					if nums[mid] < target;left = mid+1
					
看上去没那么简洁，但是更易理解
https://time.geekbang.org/column/article/42733
结合等于target的第一个位置与最后一个位置两个函数。
"""

```

## 11.7 [704. 二分查找(Easy)](https://leetcode-cn.com/problems/binary-search/)

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
>
> 示例 1:
>
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> 示例 2:
>
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1

## 11.8 [35. 搜索插入位置(Easy)](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。
>
> **示例 1:**
>
> 输入: [1,3,5,6], 5
> 输出: 2
> **示例 2:**
>
> 输入: [1,3,5,6], 2
> 输出: 1
> **示例 3:**
>
> 输入: [1,3,5,6], 7
> 输出: 4
> **示例 4:**
>
> 输入: [1,3,5,6], 0
> 输出: 0

## 11.9 [33. 搜索旋转排序数组(Medium)](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

> 整数数组 nums 按升序排列，数组中的值 互不相同 。
>
> 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
>
> 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。
>
> 
>
> **示例 1：**
>
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> **示例 2：**
>
> 输入：nums = [4,5,6,7,0,1,2], target = 3
> 输出：-1
> **示例 3：**
>
> 输入：nums = [1], target = 0
> 输出：-1

## 11.10 [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/) gzl

```python
# 方法一： 最直观的方法，时间复杂度O(N)
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        for i in range(0,len(nums)):
            if nums[i] != i:
                return i
        return len(nums) # 缺的是最后一个数
# 方法二：二分法，时间复杂度O(logN)。二分. 花了2个小时，不好写，适当放弃
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        # 如果最后一个数也符合要求，说明缺最后一个数+1，一开始处理省去最后判断。例如：[0,1,2,3], 说明缺4
        if nums[len(nums)-1] == (len(nums) -1):
            return len(nums)
        left = 0
        right = len(nums)-1
        while left < right: # 不能有等号，否则left=right出现死循环
            mid = (left+right) >> 1  #  位运算提速
            if nums[mid] == mid:
                # 说明 [left, mid] 区间没有缺失任何数
                left = mid+1   
            else:
                # 说明缺失的数在 [left, mid] 区间内
                right = mid    

        return left          
```



# 12. 搜索

## 12.1 BFS

### 12.1.1 [1091. 二进制矩阵中的最短路径(Medium)](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

> 

### 12.1.2 [279. 完全平方数(Medium)](https://leetcode-cn.com/problems/perfect-squares/)

> 定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
>
> 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
>
> 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
>
> **示例 1：**
>
> ```
> 输入：n = 12
> 输出：3 
> 解释：12 = 4 + 4 + 4
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 13
> 输出：2
> 解释：13 = 4 + 9
> ```

```python
"""
1.暴力法：也要会。

2. DFS 广度优先遍历
	为什么用广度优先：
		因为是寻找最少的个数，也即最少层数，广度优先当找到符合要求的路线则直接返回
	循环终止条件：
		1. 遇到减去 n^2 后结果为0的节点时。表示找到最短路线，直接返回
		2. 遇到已访问过相同值的节点时，跳过该节点。因为越前访问的节点路线越短或者相等，既然节点值相同，后续的路线肯定相同，不可能是更短的路线。
		
遗留：时间复杂度分析
		如何构造1，4，9....序列
"""
```



### 12.1.3 [127. 单词接龙(Hard)](https://leetcode-cn.com/problems/word-ladder/)

> todo,  题目都没读懂，为啥endword必须在wordList。
>
> 虽然是hard题，但是出现频率高。。

## 12.2 DFS

### 12.2.1 [695. 岛屿的最大面积(Medium)](https://leetcode-cn.com/problems/max-area-of-island/)

> 给定一个包含了一些 0 和 1 的非空二维数组 grid 。
>
> 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)
>
> 
>
> **示例 1:**
>
> [[0,0,1,0,0,0,0,1,0,0,0,0,0],
> [0,0,0,0,0,0,0,1,1,1,0,0,0],
> [0,1,1,0,1,0,0,0,0,0,0,0,0],
> [0,1,0,0,1,1,0,0,1,0,1,0,0],
> [0,1,0,0,1,1,0,0,1,1,1,0,0],
> [0,0,0,0,0,0,0,0,0,0,1,0,0],
> [0,0,0,0,0,0,0,1,1,1,0,0,0],
> [0,0,0,0,0,0,0,1,1,0,0,0,0]]
> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。
>
> **示例 2:**
>
> [[0,0,0,0,0,0,0,0]]
> 对于上面这个给定的矩阵, 返回 0。

```python
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0; 
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {
                    res = Math.max(res, dfs(i, j, grid));
                }
            }
        } 
        return res;
    }
    // 每次调用的时候默认num为1，进入后判断如果不是岛屿，则直接返回0，就可以避免预防错误的情况。
    // 每次找到岛屿，则直接把找到的岛屿改成0，这是传说中的沉岛思想，就是遇到岛屿就把他和周围的全部沉默。
    // ps：如果能用沉岛思想，那么自然可以用朋友圈思想。有兴趣的朋友可以去尝试。
    private int dfs(int i, int j, int[][] grid) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == 0) { 
            return 0;
        } 
        grid[i][j] = 0;
        int num = 1;
        num += dfs(i + 1, j, grid);
        num += dfs(i - 1, j, grid);
        num += dfs(i, j + 1, grid);
        num += dfs(i, j - 1, grid);
        return num;
        
    }
}
```



### 12.2.2 [200. 岛屿数量(Medium)](https://leetcode-cn.com/problems/number-of-islands/)  0223

> 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
> 
>
> **示例 1：**
>
> ```
> 输入：grid = [
> ["1","1","1","1","0"],
> ["1","1","0","1","0"],
> ["1","1","0","0","0"],
> ["0","0","0","0","0"]
> ]
> 输出：1
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [
> ["1","1","0","0","0"],
> ["1","1","0","0","0"],
> ["0","0","1","0","0"],
> ["0","0","0","1","1"]
> ]
> 输出：3
> ```

```python
"""
1.访问过的节点可以置为0，但是会修改传入数组，应该问面试官是否可以修改。
2 todo 并查集
"""
```

### 12.2.3 [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/) gzl

### 12.2.3 [547. 省份数量(Medium)](https://leetcode-cn.com/problems/number-of-provinces/)

> 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
>
> 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
> 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
>
> 返回矩阵中 省份 的数量。
>
> **示例 1：**
>
> 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
> 输出：2
> **示例 2：**
>
> 输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
> 输出：3

```python
"""
貌似跟200差不多
"""
```



### 12.2.4 [130. 被围绕的区域(Medium)](https://leetcode-cn.com/problems/surrounded-regions/) 0223

> 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。
>
> 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
>
> **示例:**
>
> X X X X
> X O O X
> X X O X
> X O X X
> 运行你的函数后，矩阵变为：
>
> X X X X
> X X X X
> X X X X
> X O X X
> **解释:**
>
> 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

```python
"""跟上面2道题差不多"""
```



### 12.2.5 [417. 太平洋大西洋水流问题(Medium)](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

> 给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。
>
> 规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。
>
> 请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。
>
> **提示：**
>
> 输出坐标的顺序不重要
> m 和 n 都小于150
>
>
> 示例：
>
> 
>
> 给定下面的 5x5 矩阵:
>
> 太平洋 ~   ~   ~   ~   ~ 
>     ~  1   2   2   3  (5) *
>     ~  3   2   3  (4) (4) *
>     ~  2   4  (5)  3   1  *
>     ~ (6) (7)  1   4   5  *
>     ~ (5)  1   1   2   4  *
>
>           *   *   *   *   * 大西洋
>
> 返回:
>
> [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).

```python
"""
用两个数组记录每个点能否到达太平洋和大西洋

遍历上和左的边界节点，逆流而上，能到达的点标记可以到达太平洋。已经标记过的跳过。
遍历右和下边界系节点，逆流而上，能到达的点标记可以到大西洋。已经标记过的跳过。

返回同时满足的点

代码参考pdf
"""
```



## 12.3 Backtracking

> Backtracking（回溯）属于 DFS。
> 普通 DFS 主要用在 可达性问题 ，这种问题只需要执行到特点的位置然后返回即
> 可。
> 而 Backtracking 主要用于求解 **排列组合** 问题，例如有 { 'a','b','c' } 三个字符，求解
> 所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会
> 继续执行求解过程。
> 因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素
> 的标记问题：
> 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能
> 在继续递归调用时不用重复访问该元素；
> 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不
> 同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。
>
> 
>
> [回溯算法入门级详解 + 练习（持续更新）](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

### 12.3.1 [17. 电话号码的字母组合(Medium)](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []

        phone = {'2':['a','b','c'],
                 '3':['d','e','f'],
                 '4':['g','h','i'],
                 '5':['j','k','l'],
                 '6':['m','n','o'],
                 '7':['p','q','r','s'],
                 '8':['t','u','v'],
                 '9':['w','x','y','z']}
                
        def backtrack(conbination,nextdigit):
            if len(nextdigit) == 0:
                res.append(conbination)
            else:
                for letter in phone[nextdigit[0]]:
                    backtrack(conbination + letter,nextdigit[1:])

        res = []
        backtrack('',digits)
        return res
```



### 12.3.2 [93. 复原IP地址(Medium)](https://leetcode-cn.com/problems/restore-ip-addresses/)

```python
"""
剪枝：
1. 层数>4
2. 超出256
3. 0开头

符合条件：
1. 层数=4，并且字符串已分完

注意需要临时字符串保留分割情况，不会覆盖？

"""
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        SEG_COUNT = 4
        MAX_NUM_DIGIT = 3
        MAX_NUM = 255
        MIN_NUM = 0
        n = len(s)

        def backtrack(i, tmp, segNum):
            if i == n and segNum == SEG_COUNT:
                res.append(tmp[:-1])
                return
            if segNum > SEG_COUNT:
                return
            for j in range(i, i + MAX_NUM_DIGIT):
                if j < n:
                    if i == j and s[j] == "0":
                        backtrack(j + 1, tmp + s[j] + ".", segNum + 1) # 当0开头只能是单独一组
                        break
                    if MIN_NUM < int(s[i:j + 1]) <= MAX_NUM:
                        backtrack(j + 1, tmp + s[i:j + 1] + ".", segNum + 1)
        backtrack(0, "", 0)
        return res
```

![image.png](https://pic.leetcode-cn.com/5276b1631cb1fc47d8d88dd021f1302213291bf05bfdfdc6209370ce9034be83-image.png)



### 12.3.3 [79. 单词搜索(Medium)](https://leetcode-cn.com/problems/word-search/)

> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
> **示例:**
>
> board =
> [
> ['A','B','C','E'],
> ['S','F','C','S'],
> ['A','D','E','E']
> ]
>
> 给定 word = "ABCCED", 返回 true
> 给定 word = "SEE", 返回 true
> 给定 word = "ABCB", 返回 false

```python
"""
不能重复使用字母，所以一次遍历中要记录visit，但是回溯的时候要清除
"""
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1:
                return True
            
            visited.add((i, j))
            result = False
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1):
                            result = True
                            break
            
            visited.remove((i, j))
            return result

        h, w = len(board), len(board[0])
        visited = set()
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False
```



### 12.3.4 [257. 二叉树的所有路径(Easy)](https://leetcode-cn.com/problems/binary-tree-paths/)

> 给定一个二叉树，返回所有从根节点到叶子节点的路径。
>
> 说明: 叶子节点是指没有子节点的节点。
>
> **示例:**
>
> 输入:
>
> 1
> /   \
> 2     3
> \
> 5
>
> 输出: ["1->2->5", "1->3"]
>
> 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3

```python
class Solution:
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        def construct_paths(root, path):
            if root:
                path += str(root.val)
                if not root.left and not root.right:  # 当前节点是叶子节点
                    paths.append(path)  # 把路径加入到答案中
                else:
                    path += '->'  # 当前节点不是叶子节点，继续递归遍历
                    construct_paths(root.left, path)
                    construct_paths(root.right, path)

        paths = []
        construct_paths(root, '')
        return paths
```



### 12.3.5 [46. 全排列(Medium)](https://leetcode-cn.com/problems/permutations/) 0224

> 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
>
> **示例:**
>
> 输入: [1,2,3]
> 输出:
> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

![image-20210225210241958](image-20210225210241958.png)

```python
"""
我们可以将题目给定的n个数的数组 nums 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。

具体来说，假设我们已经填到第 first 个位置，那么 nums 数组中 [0,first−1] 是已填过的数的集合，[first,n−1] 是待填的数的集合。我们肯定是尝试用 [first,n−1] 里的数去填第 first 个数，假设待填的数的下标为 i ，那么填完以后我们将第 i 个数和第 first 个数交换，即能使得在填第 first+1个数的时候 nums 数组的 [0,first] 部分为已填过的数，[first+1,n−1] 为待填的数，回溯的时候交换回来即能完成撤销操作。

举个简单的例子，假设我们有 [2, 5, 8, 9, 10] 这 5 个数要填入，已经填到第 3 个位置，已经填了 [8,9] 两个数，那么这个数组目前为 [8, 9 | 2, 5, 10] 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填 [8, 9, 10 | 2, 5] 。
"""
class Solution:
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        def backtrack(first):
            # 所有数都填完了
            if first == n:  
                res.append(nums[:])	# 不能res.append(nums) nums后续会被修改
                return
            for i in range(first, n):
                # 动态维护数组
                nums[first], nums[i] = nums[i], nums[first]
                # 继续递归填下一个数
                backtrack(first + 1)
                # 撤销操作
                nums[first], nums[i] = nums[i], nums[first]
        
        n = len(nums)
        res = []
        backtrack(0)
        return res
```



**传统做法**

![img](https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)

```PYTHON
from typing import List

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, size, depth, path, used, res):
            if depth == size:
                res.append(path)
                return

            for i in range(size): 	
                if not used[i]:
                    used[i] = True
                    path.append(nums[i])

                    dfs(nums, size, depth + 1, path, used, res)

                    used[i] = False
                    path.pop()

        size = len(nums)
        if len(nums) == 0:
            return []

        used = [False for _ in range(size)]
        res = []
        dfs(nums, size, 0, [], used, res)
        return res


if __name__ == '__main__':
    nums = [1, 2, 3]
    solution = Solution()
    res = solution.permute(nums)
    print(res)
```





### 12.3.6 [47. 全排列 II(Medium)](https://leetcode-cn.com/problems/permutations-ii/)

> 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
>
> **示例 1：**
>
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
> [1,2,1],
> [2,1,1]]
> **示例 2：**
>
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```python
"""
为什么一种方法另一种方法可以不先排序？https://leetcode-cn.com/problems/permutations-ii/solution/47-quan-pai-lie-iiche-di-li-jie-pai-lie-zhong-de-q/
"""
class Solution(object):
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        def backtrack(current_len = 0):
            visit=[]
            if current_len == n:  
                res.append(nums[:])
                return
            for i in range(current_len, n):
                if nums[i] in visit:		# current_len 是当前待排位置，保证该位置没有重复情况即可
                    continue
                visit.append(nums[i])
                nums[current_len], nums[i] = nums[i], nums[current_len]
                backtrack(current_len + 1)
                nums[current_len], nums[i] = nums[i], nums[current_len]

        n = len(nums)
        res = []
        backtrack()
        return res


"时间复杂度：O(N \times N!)O(N×N!)，这里 NN 为数组的长度。
"空间复杂度：O(N \times N!)O(N×N!)。
```



### 12.3.7 [77. 组合(Medium)](https://leetcode-cn.com/problems/combinations/)

> 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
>
> **示例:**
>
> 输入: n = 4, k = 2
> 输出:
> [[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]

![image-20210226234216671](image-20210226234216671.png)

```python
"""
友情提示：对于这一类问题，画图帮助分析是非常重要的解题方法。
组合与排列不一样，因为这道题输入天然有序，并且没有重复，比较好实现。begin
"""
class Solution(object):

    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        def dsf(begin, retStr):
            if len(retStr)==k:
                ret.append(retStr[:])
                return

            for i in range(begin, n+1):
                retStr.append(i)
                dsf(i+1, retStr)
                retStr.pop()
        ret=[]
        dsf(1, [])
        return ret

"""
下面是46题：排列，与上面组合不一样for循环时从0开始，所以要visit标记

什么时候使用 used 数组，什么时候使用 begin 变量
有些朋友可能会疑惑什么时候使用 used 数组，什么时候使用 begin 变量。这里为大家简单总结一下：

排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；
组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。
注意：具体问题应该具体分析， 理解算法的设计思想 是至关重要的，请不要死记硬背


：参考代码 1 和参考代码 2 的 Python 部分，没有严格按照回溯算法来写，这里需要了解的知识点是：

Python3 的 [1, 2] + [3] 语法生成了新的列表，一层一层传到根结点以后，直接 res.append(path) 就可以了；
基本类型变量在传参的时候，是复制，因此变量值的变化在参数里体现就行，所以 Python3 的代码看起来没有「回溯」这个步骤。

"""
```



### 12.3.8  [39. 组合总和(Medium)](https://leetcode-cn.com/problems/combination-sum/)

> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的数字可以无限制重复被选取。
>
> **说明：**
>
> 所有数字（包括 target）都是正整数。
> 解集不能包含重复的组合。 
> **示例 1：**
>
> 输入：candidates = [2,3,6,7], target = 7,
> 所求解集为：[[7],[2,2,3]]
> **示例 2：**
>
> 输入：candidates = [2,3,5], target = 8,
> 所求解集为：[[2,2,2,2],[2,3,3],[3,5]]

```python
"""
讲得好：https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/

由于元素可以重复使用，我们考虑了所有的组合，所以会出现重复列表。如何避免？
组合问题，需要按某个顺序搜索，使用begin变量
"""
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        def dsf(begin, nums,sumNum):
            if sumNum == target:
                ret.append(nums[:])
                return
            if sumNum > target: """可以剪枝"""
                return

            for i in range(begin, len(candidates)):
                if sumNum + candidates[i] > target: """可以剪枝"""
                    continue
                nums.append(candidates[i])
                sumNum+=candidates[i]
                dsf(i, nums,sumNum)	"""也是使用begin控制搜索顺序，但是跟77不一样，77元素不能重复使用"""
                nums.pop()
                sumNum-=candidates[i]

        ret = []
        dsf(0,[],0)
        return ret
```

### 12.3.9 [40. 组合总和 II(Medium)](https://leetcode-cn.com/problems/combination-sum-ii/) todo

> 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用一次。
>
> **说明：**
>
> 所有数字（包括目标数）都是正整数。
> 解集不能包含重复的组合。 
> **示例 1:**
>
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 所求解集为:
> [[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]
> **示例 2:**
>
> 输入: candidates = [2,5,2,1,2], target = 5,
> 所求解集为:[[1,2,2],[5]]

```PYTHON
"""
与第 39 题（组合之和）的差别
这道题与上一问的区别在于：

第 39 题：candidates 中的数字可以无限制重复被选取；
第 40 题：candidates 中的每个数字在每个组合中只能使用一次

因此40题只用begin还不能保证组合不重复

关键词：组合，候选有重复，不可重复选择
组合：begin
候选有重复：sort 和 判断 i>begin and nums[i]==nums[i]-1 剪枝
"""
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def dsf(begin, nums,sumNum):
            if sumNum == target:
                ret.append(nums[:])
                return
            if sumNum > target: 
                return

            for i in range(begin, len(candidates)):
                if i > begin and candidates[i] == candidates[i-1]:
                    continue
                dsf(i+1, nums+[candidates[i]],sumNum+candidates[i])

        ret = []
        candidates.sort()
        print(candidates)
        dsf(0,[],0)
     
        return ret
```



### 12.3.10 [216. 组合总和 III(Medium)](https://leetcode-cn.com/problems/combination-sum-iii/) 0227

> 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
>
> **说明：**
>
> 所有数字都是正整数。
> 解集不能包含重复的组合。 
> **示例 1:**
>
> 输入: k = 3, n = 7
> 输出: [[1,2,4]]
> **示例 2:**
>
> 输入: k = 3, n = 9
> 输出: [[1,2,6], [1,3,5], [2,3,4]]

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:

        def dsf(begin, nums,sumNum):
            if sumNum == n and len(nums)==k:
                ret.append(nums[:])
                return

            if sumNum > n or len(nums) > k:
                return
            for i in range(begin, 10):
                if sumNum+begin > n:
                    return

                dsf(i+1, nums+[i],sumNum+i)

        ret = []
        dsf(1,[],0)
        return ret
```



### 12.3.11 [78. 子集(Medium)](https://leetcode-cn.com/problems/subsets/) 0227

> 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
>
> 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
>
> **示例 1：**
>
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> **示例 2：**
>
> 输入：nums = [0]
> 输出：[[],[0]]

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:

        def dsf(begin, retNums):
            ret.append(retNums[:])
            if begin > len(nums):
                return

            for i in range(begin, len(nums)):
                dsf(i+1,retNums+[nums[i]])

        ret = []
        dsf(0,[])
        return ret
```



### 12.3.12 [90. 子集 II(Medium)](https://leetcode-cn.com/problems/subsets-ii/)

> 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
>
> **说明：解集不能包含重复的子集。**
>
> **示例:**
>
> 输入: [1,2,2]
> 输出:[[2],[1],[1,2,2],[2,2],[1,2],[]]

```python
"""
与40题差不多
"""
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        def dsf(begin, retNums):
            if begin > len(nums):
                return
            ret.append(retNums[:])
            for i in range(begin, len(nums)):
                if i-begin>0 and nums[i]==nums[i-1]:
                    continue
                dsf(i+1,retNums+[nums[i]])

        ret = []
        nums.sort()
        dsf(0,[])

        return ret
```



### 12.3.13 [131. 分割回文串(Medium)](https://leetcode-cn.com/problems/palindrome-partitioning/)

> 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
>
> 返回 s 所有可能的分割方案。
>
> **示例:**
>
> 输入: "aab"
> 输出:
> [
> ["aa","b"],
> ["a","a","b"]

![131.分割回文串.png](https://pic.leetcode-cn.com/1604822955-WbvWRE-131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.png)

```python
"""
我们来分析一下切割，其实切割问题类似组合问题。

例如对于字符串abcdef：

组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个.....。
切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段.....。

1. 跟组合一样，需要begin，用来下一轮递归遍历的起始位置。
2. 截取后判断如果是回文则继续，如果不是回文则剪枝

不画图很难，想清楚循环范围 for 0 len(s2)

"""
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        
        def dsf(s2 , retTemp):
            if len(s2) == 0:
                ret.append(retTemp)
                return
            for i in range(0, len(s2)):
                if isPatition(s2[:i+1]) == False:
                    continue
                dsf(s2[i+1:],retTemp+[s2[:i+1]])

        def isPalindrome(s)-> bool:
            return s == s[::-1]

        ret = []
        dsf(s, [])
        return ret
```



### 12.3.14 [37. 解数独(Hard)](https://leetcode-cn.com/problems/sudoku-solver/) 0228

> 编写一个程序，通过填充空格来解决数独问题。
>
> 一个数独的解法需遵循如下规则：
>
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
> 空白格用 '.' 表示

```python
"""
问题1：如何在O(1)时间内知道行、列、9格块3个列表内改数字是否已填入？
	x取值范围是1~9
	x是存在，用哈希表hash[i-1]=True
	x在行内存在，用line[x-1]=True
	x在第i行内存在用，line[i][x-1]=True
	x在第j列内存在用，col[j][x-1]=True
	x在第9格块是存在用，block[k][x-1]=True，其中i，j可以确定k，比如i=1，j=2,则k=0
	当line[i][x-1] == false and col[j][x-1] == false and block[k][x-1]==false 表示第i行第列可以放入x
	

问题2（最不好理解的点）：遍历空位置 与 遍历选择插入数（1~9） 两者什么关系？
类比一般的排列题：从1~3 选择，排列成2位数：13,12,21,23,31,32。遍历条件是for 1~3， 递归层数（递归终止条件）是lay=2。
对应本题：
	每个位置可能选择1~9，也就是遍历条件是for 1~9
	空位置数也就是排列题的空位置数，也就是空位置数就是递归层数，当空位置数=0时，递归终止，成功找到解。
	可以用一个数组space记录空格位置，判断lay==len(space[])
		
问题3：排列还是组合？
明显是组合，因此for 1~9, 另外要标记已访问与恢复
	
问题4: 遍历范围
每个空格都能填入1~9，即for i range(1~9)
当line[i][x-1] == True or col[j][x-1] == True or block[k][x-1]==Ture 则跳过

问题4：终止条件
1.解成功：space最后一个点也能放入数字，即pos==len(space)-1。由于本题只需要哦
2.解失败剪枝：当没有数字可填入时，需要遍历所有数字才知道没有数字可填入，因此该题无需刻意判断剪枝。

其他注意点：回溯标记，与恢复

总结：
1.判断是排列还是组合。排列则for 0~n, 访问标记与恢复；组合则使用begin顺序选择,备选有重复时需要先sort并在选择时判断与前一个相等则跳过
2.终止条件：
	1.层数：待填充位数则是递归层数
	2.成功
	3.失败
3.若只需要返回一个成功解，则使用一个全局变量，在终止并成功找到解时做标记，在递归完后判断，标记成功则直接return。
"""
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def dsf(pos):
            nonlocal findAnswer
            if pos == len(space):
                findAnswer=True
                return

            [i,j] = space[pos]
            for k in range(1,10):
                if line[i][k] or col[j][k] or block[getBlockNum(i,j)][k]:
                    continue
                line[i][k]=col[j][k]=block[getBlockNum(i,j)][k]=True 
                board[i][j]=str(k)   # 不用恢复，后面会被正确解覆盖
                dsf(pos+1)
                line[i][k]=col[j][k]=block[getBlockNum(i,j)][k]=False
                if findAnswer:
                    return

        def getBlockNum(i,j)->int:
            return i//3 * 3 + j//3

        findAnswer = False
        line = [[False]*10 for _ in range(9)] # line[i][j] = True 表示第i行在已填入数j
        col = [[False]*10 for _ in range(9)] # col[i][j] = True 表示第i列在已填入数j
        block = [[False]*10 for _ in range(9)] # block[i][j] = True 每3*3宫为一个block，表示第i个block在已填入数j

        # 设置line,col,block 并找出空位置
        space = []
        for i in range(9):
            for j in range(9):
                if board[i][j] == ".":
                    space.append([i,j]) # 插入元组比较好取？
                else:
                    num = int(board[i][j])
                    line[i][num] = True
                    col[j][num] = True
                    block[getBlockNum(i,j)][num] = True
        dsf(0)
```



### 12.3.15 [51. N 皇后(Hard)](https://leetcode-cn.com/problems/n-queens/)

```python
"""
0. 排列问题？为什么？
1. 看上去是要判断行、列、正对角线、副对角线4个方向是否冲突。但其实选一个方向遍历（这里我们选择行），判断其余3个条件是否冲突。
2. 冲突条件记录，记录的数据结构不需要考虑记录详细的放置位置，只需要能线性时间复杂度内判断出冲突即可。这里需要记录3个冲突情况，分别用3个集合，colSet，diagonal1Set， diagonal2Set记录，若记录详细的已放置位置反而很难判断是否冲突。
3. 分析对角线的下标规律：用col标识列， line+col 可标识正对角线，用line-col可以标识副对角线
"""
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def dsf(row:int, record):
            if row == n:
                ret.append(record)
                return
            
            for i in range(n):
                if i in colFlag or i+row in diagonal1 or i-row in diagonal2:
                    continue
                colFlag.add(i)
                diagonal1.add(i+row)
                diagonal2.add(i-row)
                dsf(row+1,record+ [s[:i]+"Q"+s[i+1:]])
                colFlag.remove(i)
                diagonal1.remove(i+row)
                diagonal2.remove(i-row)
        ret=[]
        colFlag,diagonal1,diagonal2 = set(),set(),set()
        s = "." * n
        dsf(0,[])

        return ret
```



> 总结：
>
> 1. 排列和组合的代码结构特点是？
>    1. **排列**使用visit记录，回溯时需要回退到原来的结果（也可以不使用visit，使用交换法）
>    2. **组合**需要按照顺序搜索，使用begin传到下层

# 13. 分治

## 13.1 [241. 为运算表达式设计优先级(Medium)](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/) 0226delay0228

> 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。
>
> **示例 1:**
>
> 输入: "2-1-1"
> 输出: [0, 2]
> 解释: 
> ((2-1)-1) = 0 
> (2-(1-1)) = 2
> **示例 2:**
>
> 输入: "2\*3-4\*5"
> 输出: [-34, -14, -10, -10, 10]
> 解释: 
> (2\*(3-(4\*5))) = -34 
> ((2\*3)-(4\*5)) = -14 
> ((2\*(3-4))\*5) = -10 
> (2\*((3-4)\*5)) = -10 
> (((2\*3)-4)*5) = 10

```python
"""
为什么一开始完全想不到。什么题型应该用分治
"""
class Solution:
    def diffWaysToCompute(self, input: str) -> List[int]:
        ret = []
        for i,s in enumerate(input):
            if s != '+' and s != '-' and s != '*':
                continue
            left = self.diffWaysToCompute(input[:i])
            right = self.diffWaysToCompute(input[i+1:])

            for j in left:
                for k in right:
                    if s == '+':
                        ret.append(j+k)
                    elif s == '-':
                        ret.append(j-k)
                    else:
                        ret.append(j*k)
            
        if len(ret)==0: # ret等于0，说明input是一个数字，直接返回
            ret.append(int(input))
        return ret
```



## 13.2 [95. 不同的二叉搜索树 II(Medium)](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) 0226 delay 0301

> 给定一个整数 n，生成所有由 1 ... n 为节点所组成的 **二叉搜索树** 。
>
> **示例：**
>
> 输入：3
> 输出：
> [
> [1,null,3,2],
> [3,2,null,1],
> [3,1,null,null,2],
> [2,1,3],
> [1,null,2,null,3]
> ]
> 解释：
> 以上的输出对应以下 5 种不同结构的二叉搜索树：
>
> 1         3     3      2      1
>  \       /     /      / \      \
>   3     2     1      1   3      2
>  /     /       \                 \
> 2     1         2                 3

```python
"""
二叉搜索树：左子树比父节点小，右子树比父节点大
"""
public List<TreeNode> generateTrees(int n) {
if (n < 1) {
return new LinkedList<TreeNode>();
}
return generateSubtrees(1, n);
}
private List<TreeNode> generateSubtrees(int s, int e) {
List<TreeNode> res = new LinkedList<TreeNode>();
if (s > e) {
res.add(null);
return res;
}
for (int i = s; i <= e; ++i) {
List<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);
List<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);
for (TreeNode left : leftSubtrees) {
for (TreeNode right : rightSubtrees) {
TreeNode root = new TreeNode(i);
root.left = left;
root.right = right;
res.add(root);
}
}
}
return res;
}

class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        def generateTrees(start, end):
            if start > end:
                return [None,]
            
            allTrees = []
            for i in range(start, end + 1):  # 枚举可行根节点
                # 获得所有可行的左子树集合
                leftTrees = generateTrees(start, i - 1)
                
                # 获得所有可行的右子树集合
                rightTrees = generateTrees(i + 1, end)
                
                # 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
                for l in leftTrees:
                    for r in rightTrees:
                        currTree = TreeNode(i)
                        currTree.left = l
                        currTree.right = r
                        allTrees.append(currTree)
            
            return allTrees
        
        return generateTrees(1, n) if n else []

```



# 14. 贪心思想

> ![image-20210302222144540](image-20210302222144540.png)
>
> 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。
>
> 贪心算法是一种在解决问题的过程中追求局部最优的算法，**对于一个有多种属性的事物来说**，贪心算法会优先满足某种条件，追求局部最优的同时希望达到整体最优的效果。以背包问题为例，可以放在背包中的物体有它的重量和价值两种属性，背包的容量也是有限的，我们希望得到一种价值最大的物品摆放方式，如果我们倾向于重量贪心，那么在摆放物品的时候会优先放重量小的，但这和我们追求的价值最优没有关系，自然不能采用；如果倾向于价值贪心，而忽略了物品的重量，可能会导致摆放物品的数量不多，总价值很小；如果是以价值和重量的比值设计贪心算法求解，便可以实现最优的方案。

## 14.1 [455. 分发饼干(Easy)](https://leetcode-cn.com/problems/assign-cookies/)

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
> **示例 1:**
>
> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> **示例 2:**
>
> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.

```python
"""
为了了满足更多的小孩，就不要造成饼干尺寸的浪费。

大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。

1. 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度
比较大的孩子。
2. 因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。
在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，
但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优
解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。
如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。
证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第
m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第
n 个饼干，并且 m < n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干
一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩
子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略

感觉四种都可以
1、从小到大遍历小孩，从小到大找饼干
2、从大到小遍历小孩，从大到小找饼干
3、从小到大遍历饼干，从小到大找小孩
4、从大到小遍历饼干，找大到小找小孩
https://leetcode-cn.com/problems/assign-cookies/solution/dan-shuang-pai-xu-you-xian-dui-lie-9jie-uhwdm/
"""
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int res = 0;
        int index = 0;
        for(int i = 0;i < s.size();++i){
            if(index < g.size() && g[index] <= s[i]){
                index++;
                res++;
            }
        }
        return res;
    }
};
```



## 14.2 [435. 无重叠区间(Medium)](https://leetcode-cn.com/problems/non-overlapping-intervals/)

> 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
>
> 注意:
>
> 可以认为区间的终点总是大于它的起点。
> 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
> **示例 1:**
>
> 输入: [ [1,2], [2,3], [3,4], [1,3] ]
>
> 输出: 1
>
> 解释: 移除 [1,3] 后，剩下的区间没有重叠。
> **示例 2:**
>
> 输入: [ [1,2], [1,2], [1,2] ]
>
> 输出: 2
>
> 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
> **示例 3:**
>
> 输入: [ [1,2], [2,3] ]
>
> 输出: 0
>
> 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

```python
"""
理解还是不够透彻，TODO
https://leetcode-cn.com/problems/non-overlapping-intervals/solution/435-wu-zhong-die-qu-jian-tan-xin-jing-di-qze0/
"""
```

## 14.2.2 [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/) gzl

## 14.2.3[57. 插入区间](https://leetcode-cn.com/problems/insert-interval/) gzl

## 14.3 [452. 用最少数量的箭引爆气球(Medium)](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/) 

```python
"""
与435 基本一样，都是计算不重叠区间个数，只是本题边界相等看做重叠
还是待总结
https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/tu-jie-tan-tao-wei-shi-yao-yao-an-qu-jian-de-you-d/
"""
```



## 14.4 [406. 根据身高重建队列(Medium)](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

```python
"""
究竟什么贪心的套路是怎样？什么题目用贪心，贪心一般代码结构？

https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/
https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/406du-shuo-shi-tan-xin-na-yao-wei-shi-yao-yong-tan/
"""
```



## 14.5 [121. 买卖股票的最佳时机(Easy)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

> 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
>
> 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
>
> **示例 1：**
>
> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>   注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> **示例 2：**
>
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

```python
"""
跟贪心不知道有毛关系

在最低点买入，最高点卖出。
一次遍历：遍历时记录最低点，以及最大收益值。
"""
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0

        minPoint = prices[0]
        maxProfit = 0
        for i in range(1,len(prices)):
            if prices[i] < minPoint:
                minPoint = prices[i]
            elif prices[i] - minPoint > maxProfit:
                maxProfit = prices[i] - minPoint
        
        return maxProfit
```



## 14.6  [122. 买卖股票的最佳时机 II(Easy)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/) 0227 0302

> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **实例0**
>
> [7,1,5,6,10] 
>
> 输出：5，
>
> **示例 1:**
>
> 输入: [7,1,5,3,6,4]
> 输出: 7
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
> **示例 2:**
>
> 输入: [1,2,3,4,5]
> 输出: 4
> 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
> **示例 3:**
>
> 输入: [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

```python
"""
这题关键是可以同一天卖出再买入，所以只要把正数加起来就可以，，什么贪心算法。。。
这两道股票题是可以用动态规划，但是贪心算法更高效简单，后面的股票题貌似只能用动态规划。
https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/
"""
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ret=0
        for i in range(1, len(prices)):
            tmp=prices[i] - prices[i-1]
            if tmp > 0:
                ret += tmp
        return ret
```

## 14.7 [605. 种花问题(Easy)](https://leetcode-cn.com/problems/can-place-flowers/)

> 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
>
> 给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。
>
> **示例 1**：
>
> 输入：flowerbed = [1,0,0,0,1], n = 1
> 输出：true
> **示例 2：**
>
> 输入：flowerbed = [1,0,0,0,1], n = 2
> 输出：false

```python
#todo
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        // 每次跳两格
         for (int i = 0; i < flowerbed.size(); i += 2) {
             // 如果当前为空地
            if (flowerbed[i] == 0) {
                // 如果是最后一格或者下一格为空
                if (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0) {
                    n--;
                } else {
                    i++;
                }
            }
        }
        return n <= 0;
    }
};
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        for(int i=0; i<flowerbed.length; i++) {
            if(flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == flowerbed.length-1 || flowerbed[i+1] == 0)) {
                n--;
                if(n <= 0) return true;
                flowerbed[i] = 1;
            }
        }

        return n <= 0;
    }
}
```



## 14.8 [392. 判断子序列(Easy)](https://leetcode-cn.com/problems/is-subsequence/)

> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
>
> **进阶：**
>
> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
>
> **示例 1：**
>
> 输入：s = "abc", t = "ahbgdc"
> 输出：true
> **示例 2：**
>
> 输入：s = "axc", t = "ahbgdc"
> 输出：false

![image-20210302230633005](image-20210302230633005.png)

```python
"""
好像很简单，但也不容易想到，总结可以用贪心算法题目的共性
"""
```



## 14.9 [665. 非递减数列(Easy)](https://leetcode-cn.com/problems/non-decreasing-array/) 0302

> 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
>
> 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。
>
> **示例 1:**
>
> 输入: nums = [4,2,3]
> 输出: true
> 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
> **示例 2:**
>
> 输入: nums = [4,2,1]
> 输出: false
> 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。

```python
"""
当nums[i] < nums[i - 1]时，修改为前一个数可行？
4 2 3 ：判断4 比2小，修改 4 为后一个数-》2 2 3
1 4 3 ：判断4 比3小，修改 4 为后一个数-》1 3 3
3, 4, 2, 5 ：判断4比2小，修改 4 为后一个数 3 2 2 5，修改次数超过两次
			但其实 修改 2 为5 -》3 ，4 ，5 ，5返回True
			
在出现 nums[i] < nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改
能使 i 之前的数组成为非递减数组，并且 不影响后续的操作 。优先考虑令 nums[i - 1]
= nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就
有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i]
< nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改
nums[i] = nums[i - 1]。
"""

class Solution(object):
    def checkPossibility(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        N = len(nums)
        count = 0
        for i in range(1, N):
            if nums[i] < nums[i - 1]:
                count += 1
                if i == 1 or nums[i] >= nums[i - 2]:
                    nums[i - 1] = nums[i]
                else:
                    nums[i] = nums[i - 1]
        return count <= 1
    
    
class Solution:
    def checkPossibility(self, nums: List[int]) -> bool:
        count = 0
        for i in range(1,len(nums)):
            if nums[i] < nums[i-1]:
                count += 1
                if i+1 < len(nums) and i-2 >= 0:
                    if nums[i+1] < nums[i-1] and nums[i-2] > nums[i]:
                        return False
            if count > 1:
                return False
        return True
```



## 14.10 [53. 最大子序和(Easy)](https://leetcode-cn.com/problems/maximum-subarray/) 0303

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **示例 1：**
>
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> **示例 2：**
>
> 输入：nums = [1]
> 输出：1
> **示例 3：**
>
> 输入：nums = [0]
> 输出：0
> **示例 4：**
>
> 输入：nums = [-1]
> 输出：-1
> **示例 5：**
>
> 输入：nums = [-100000]
> 输出：-100000

```python
"""
贪心算法，局部最优是当前部分和为正数时，就能可能更大。
"""
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums)==0:
            return 0
        maxSum = nums[0]
        curSum  = 0
        for i in range(0, len(nums)):
            if curSum  > 0:
                curSum += nums[i]
            else:
                curSum = nums[i]
                print(curSum)
            maxSum = max(maxSum, curSum)
        return maxSum
```



## 14.11 [763. 划分字母区间(Medium)](https://leetcode-cn.com/problems/partition-labels/)

> 字符串 S 由小写字母组成。我们要把这个字符串划分为**尽可能多**的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
>
> **示例：**
>
> 输入：S = "ababcbacadefegdehijhklij"
> 输出：[9,7,8]
> 解释：
> 划分结果为 "ababcbaca", "defegde", "hijhklij"。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。

```python
"""
这怎么又是贪心算法。。。

核心：当一个字母出现最开头与最末尾，那么肯定在一个分割区间。
1.首先记录每个字母的最末尾位置
2.再次遍历，扩展当前区间，当遍历到走到区间最末尾时，表示该区间分割完毕
"""
```

## 14.12 [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/) gzlkl



# 15. 动态规划

>思路：
>
>首先考虑题目问什么，就把什么定义成状态。题目问最长上升子序列的长度，其实可以把「子序列的长度」定义成状态，但是发现「状态转移」不好做。
>
>基于「动态规划」的状态设计需要满足「无后效性」的设计思想，可以将状态定义为「以 nums[i] 结尾 的「上升子序列」的长度」。
>
>「无后效性」的设计思想：让不确定的因素确定下来，以保证求解的过程形成一个逻辑上的有向无环图。这题不确定的因素是某个元素是否被选中，而我们设计状态的时候，让 nums[i] 必需被选中，这一点是「让不确定的因素确定下来」，也是我们这样设计状态的原因。
>
>
>
>1. 定义dp[i] ，问题问什么，就定义什么，而且【无后效性】
>2. 从dp[0] 开始，画图，模拟，找规律，总结递推公式

## 15.1 斐波那契数列

### 15.1.1 [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> 注意：给定 n 是一个正整数。
>
> **示例 1：**
>
> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
>
> 1. 1 阶 + 1 阶
>
> 2. 2 阶
>
> **示例 2**
>
> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
>
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶

```python
"""
在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。

那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.

其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。



我们用f(x)表示爬到第x级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：
f(x) = f(x - 1) + f(x - 2)


1. 想出状态转移函数
2. 从f(1)=1 f(2)=2, 得到f(3)，手写循环计算找规律
3. 实现上述规律，代码实现顺序与实际走楼梯顺序没什么关系
"""
class Solution:
    def climbStairs(self, n: int) -> int:
        pre1,pre2=2,1
        if n<=1:
            return pre2
        if n==2:
            return pre1

        for i in range(2,n): # 注意，这里i并没有用，所以n只是用于循环次数。 当n=3时，只需要循环一次，因此循环范围是2~2，也就是 range(2,3)
            tmp=pre1
            pre1+=pre2
            pre2=tmp
        return pre1
```



### 15.1.2 [198. 打家劫舍(Medium)](https://leetcode-cn.com/problems/house-robber/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
> **示例 1：**
>
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>   偷窃到的最高金额 = 1 + 3 = 4 。
> **示例 2：**
>
> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>   偷窃到的最高金额 = 2 + 9 + 1 = 12 。

```python
"""
讲得很好：https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/


动态规划的的四个解题步骤是：
1.定义子问题
	这要求子问题需要具备两个性质：
	1）原问题要能由子问题表示。例如这道小偷问题中，k=nk=n 时实际上就是原问题。否则，解了半天子问题还是解不出原问题，那子问题岂不是白解了。
	2）一个子问题的解要能通过其他子问题的解求出。
2.写出子问题的递推关系
	这一步是求解动态规划问题最关键的一步。然而，这一步也是最无法在代码中体现出来的一步。在做题的时候，最好把这一步的思路用注释的形式写下来。做动态规划题目不要求快，而要确保无误。
3.确定 DP 
	不过在普通的动态规划题目中，99% 的情况我们都不需要用到备忘录方法，所以我们最好坚持用自底向上的 dp 数组。
4.空间优化（可选）
"""
def rob(self, nums: List[int]) -> int:
    prev = 0
    curr = 0
    
    # 每次循环，计算“偷到当前房子为止的最大金额”
    for i in nums:
        # 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]
        # dp[k] = max{ dp[k-1], dp[k-2] + i }
        prev, curr = curr, max(curr, prev + i)
        # 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]

    return curr
```



### 15.1.3 [213. 打家劫舍 II(Medium)](https://leetcode-cn.com/problems/house-robber-ii/)

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。
>
> **示例 1：**
>
> 输入：nums = [2,3,2]
> 输出：3
> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
> **示例 2：**
>
> 输入：nums = [1,2,3,1]
> 输出：4
> 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
>   偷窃到的最高金额 = 1 + 3 = 4 。
> **示例 3：**
>
> 输入：nums = [0]
> 输出：0

```python
"""
环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：
1.在不偷窃第一个房子的情况下（即 nums[1:]nums[1:]），最大金额是 p1
2.在不偷窃最后一个房子的情况下（即 nums[:n-1]nums[:n−1]），最大金额是 p2
综合偷窃最大金额： 为以上两种情况的较大值，即 max(p1,p2)
其中单排偷房子问题见198题。

首尾两间房A和B只能偷一间 等价于 AB不能同时偷 等价与 不偷房A房或者不偷B房。这个有点转不过来
AB两间房只能偷一间	=》不偷A or 不偷B
"""
class Solution:
    def rob(self, nums: [int]) -> int:
        def my_rob(nums):
            cur, pre = 0, 0
            for num in nums:
                cur, pre = max(pre + num, cur), cur
            return cur
        return max(my_rob(nums[:-1]),my_rob(nums[1:])) if len(nums) != 1 else nums[0]
```



### 15.1.4 信件错排

> 题目描述：有 N 个 信 和 信封，它们已被打乱，求错误装信方式的数量。

```python
"""
题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。
定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设
第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，
有两种情况：
i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有
dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信
方式。
i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1]
种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。
综上所述，错误装信数量方式数量为：
"""
```

![image-20210304085733430](image-20210304085733430.png)

### 15.1.5 母牛生产（程序员代码面试指南-P181）

> 题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有
> 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小
> 母牛。给定整数 N，求 N 年后牛的数量。
> 第 i 年成熟的牛的数量为：

没看懂题目。一时第二年可以生，一时第三年可以生

### 15.1.6 [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/) gzlkl 



## 15.2 矩阵路径

### 15.2.1 [64. 最小路径和(Medium)](https://leetcode-cn.com/problems/minimum-path-sum/)



```python
"""
到达右下角得最短路径 = min（到达右下角上面块最短路径， 到达右下角左边块最短路径）+ 右下角数
"""
```



### 15.2.2 [62. 不同路径(Medium)](https://leetcode-cn.com/problems/unique-paths/)

```python
"""
到达右下角路径数 = 到达右下角上面块路径数+到达右下角左边块路径数
"""
```

### 15.2.3 [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) gzl



## 15.3 数据区间

### 15.3.1 [303. 区域和检索 - 数组不可变(Easy)](https://leetcode-cn.com/problems/range-sum-query-immutable/)

```python
"""
在O(1) 时间内查询。

1.利用前缀和preSum 之差快速得出：
sum(i,j) = preSum(j) - preSum(i-1)，其中preSum为 0~i的和

但，由于对于i=0，需要特殊处理，代码不简洁，定义preSum[0]不用，从preSum[1]开始放i=0的前缀和，也就是preSum[1]=nums[0]，preSum[2]=nums[0]+nums[1]，因此：sum（0，1）= preSum[2]-preSum[1]。
归纳得出：sum(i,j) = preSum(j+1)-preSum(i),
"""
class NumArray:
    def __init__(self, nums: List[int]):
         # 为了代码更简洁，避免i-1<0需要特殊处理，preSum[0]不用，从preSum[1]开始用，preSum[1] = nums[0]
        self.preSum=[0]
        for i in range(0, len(nums)):
            self.preSum.append(self.preSum[i] + nums[i]) # 正常思维从preSum[0]开始存放前缀和的话，preSum[i-1]+nums[i], 但由于改成从preSum[1]开始，因此是 preSum[i]+nums[i]
        print(self.preSum)

    def sumRange(self, i: int, j: int) -> int:
        return self.preSum[j+1] - self.preSum[i]
```



### 15.3.2 [413. 等差数列划分(Medium)](https://leetcode-cn.com/problems/arithmetic-slices/)

> 如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。
>
> 例如，以下数列为等差数列:
>
> 1, 3, 5, 7, 9
> 7, 7, 7, 7
> 3, -1, -5, -9
> 以下数列不是等差数列。
>
> 1, 1, 2, 5, 7
>
>
> 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。
>
> 如果满足以下条件，则称子数组(P, Q)为等差数组：
>
> 元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。
>
> 函数要返回数组 A 中所有为等差数组的子数组个数。
>
> **示例:**
>
> A = [1, 2, 3, 4]
>
> 返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。

![image-20210305230427806](image-20210305230427806.png)

```python
"""
dp[i] 表是以A[i]结尾的的等差子数组个数。

[1, 3, 5]
dp[2] = 1

[1, 3, 5，7] // [1, 3, 5] 之后加一个 7
[3, 5，7] // 新的递增子区间，由于子数组限制长度位2，因此增加一个等差数，则会增加一个子数组
dp[3] = dp[2] + 1 = 2

[1, 3, 5，7，9], // [1, 3, 5，7] 之后加一个9
[3, 5，7，9], // [3, 5，7] 之后加一个 9
[5，7，9] // 新的递增子区间
dp[4] = dp[3] + 1 = 3

如果新增数A[i]没有保持末3位等差，则新增这个数不会增加等差数组个数，也就是dp[i]=0
"""
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return 0
        ans = 0
        dp = [0]*len(nums)
        for i in range(2, len(nums)):
            if nums[i]-nums[i-1] == nums[i-1]-nums[i-2]:
                dp[i] = dp[i-1] + 1
                ans += dp[i]
            else:
                dp[i] = 0
        return ans
```

### 15.3.3 [1191. K 次串联后最大子数组之和](https://leetcode-cn.com/problems/k-concatenation-maximum-sum/) gzl

## 15.4 分割整数

### 15.4.1 [343. 整数拆分(Medium)](https://leetcode-cn.com/problems/integer-break/) 0306

> 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
>
> **示例 1:**
>
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1。
> **示例 2:**
>
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

![image-20210306115620481](image-20210306115620481.png)

```python
"""
对于的正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n−k，n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。

创建数组 dp，其中dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。
当 i≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下两种方案：
将 i 拆分成 j 和 i-j 的和，且 i-j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；
将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 [i-j]j×dp[i−j]。
因此，当 j 固定时，有 dp[i]=max(j×(i−j),j×dp[i−j])。由于 j 的取值范围是 1 到 i−1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程如上图。

最终得到dp[n] 的值即为将正整数 n 拆分成至少两个正整数的和之后，这些正整数的最大乘积。
"""
class Solution:
    def integerBreak(self, n: int) -> int:
        # 定义dp[i]，为i能拆分2个或2个以上的正整数，这些数的最大乘积
        # dp[i] = max ( max( j*(i-j),j*dp[i-j] ) ) j=（1，i-1）
        # dp[0]=0, dp[1] = 0, dp[2]=1

        dp = [0]*(n+1)
        dp[2] = 1
        for i in range(3, n+1):
            tmpMax = 0
            for j in range(1, i):
                dp[i] = max(dp[i],max(j*(i-j), j*dp[i-j]))
        return dp[n]
```



### 15.4.2 [279. 完全平方数(Medium)](https://leetcode-cn.com/problems/perfect-squares/)

> 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
>
> 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
>
> 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
>
> **示例 1：**
>
> 输入：n = 12
> 输出：3 
> 解释：12 = 4 + 4 + 4
> **示例 2：**
>
> 输入：n = 13
> 输出：2
> 解释：13 = 4 + 9
>
> **示例 2：**
>
> 输入：n = 4
> 输出：1
> 解释：4 = 4

```python
"""
该题与343 都比较难想出来，题目和解法上有共同点：
1.将一个数分割成若干个数
2.需要两个for循环，第二个for 循环变量变量j从0到i-1,  第二for循环内执行 dp[i]= max/min(a,dp[i-f(j)]*b+c) 
3.具体递推公式，通用化但并不好理解的numSquares(n-k) + 1， 子问题 numSquares(n-k)的解分割成若干个数）+ 1（分割出k）：
numSquares(n)=min(numSquares(n-k) + 1)
"""
class Solution:
    def numSquares(self, n: int) -> int:
        squaresNums = [i**2 for i in range(int(math.sqrt(n) + 1))] # 预先保存平方数列表，减少重复计算
        dp = [i for i in range(n+1)] # dp[i]为i能分割成完全平方数的最小个数。初始化为最坏情况，也即是分割为i个1，也就是dp[i]初始为i
        print(dp)
        for i in range(0, n+1):
            for j in squaresNums:
                if i-j < 0: # 表示当前平方和数j已经比i大，停止遍历
                    break
                dp[i] = min(dp[i], dp[i-j] + 1) # 分割一个j，转化为子问题d[i-j]的解，因为分割出一个数，所以+1 
        print(dp)
        return dp[n]
```

### 15.3.4 [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/) gzl

### 15.3.5 [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/) gzl



### 15.4.3 [91. 解码方法(Medium)](https://leetcode-cn.com/problems/decode-ways/)

![image-20210306172517126](image-20210306172517126.png)

```python
"""
1. 这里为什么是dp[i] = dp[i-1] + dp[i-2]?
  字符串分割，不受限制的话，s[i]单独一组，情况位dp[i-1]；若s[i-1]s[i]组合一组，dp[i-2]。。。。。。
 因此 dp[i]=dp[i-1]+dp[i-2]+dp[i-3]+....+dp[0]，该题限制了组合必须小于等于26，也就是组合位数不能超过2位,故有dp[i] = dp[i-1] + dp[i-2]
 
2. 分情况讨论
	首先，考虑s[i]单独译码，译码情况等于dp[i-1]
	然后，考虑s[i-1]与s[i]合并编码，译码情况 dp[i-2]，需要满足s[i-1]*10+s[i]>=10 且 s[i-1]*10+s[i]<=26 
"""

# 比较容易写的方法，空间复杂度O(n)
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        if n == 0 or s[0] == "0":
            return 0
        dp = [0]*(n+1)
        dp[0]=1
        for i in range(1, n+1):
            if s[i-1] != "0":
                dp[i] = dp[i-1]
            lastTwo = int(s[i-2])*10+int(s[i-1])
            if i>=2 and lastTwo >=10 and lastTwo <=26:
                dp[i] += dp[i-2]
        return dp[n]
    
    
# 只存放d[i-1] 和 dp[i-2], 空间复杂度O(1)
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        if n == 0 or s[0] == "0":
            return 0
        pre, cur = 1,1   # 分别保存dp[i-2]和dp[i-1],  当前i=0，考虑"10",  dp[-1] = dp[0] = 1, todo初始值比较难理解
        for i in range(1, n):
            tmp = cur
            # cur存放的是dp[i-1]
            if s[i] == "0":
                cur = 0 # 当前数位0，不能单独组合
            lastTwo = int(s[i-1])*10+int(s[i])
            if i>=1 and lastTwo >=10 and lastTwo <=26:
                cur += pre # d[i] = d[i-1] + d[i-2]
            pre = tmp # pre 存放当前循环dp[i-1]，也就是下一循环的dp[i-2]
        return cur
```



## 15.5 最长递增子序列

### 15.5.1 [300. 最长递增子序列(Medium)](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
> **示例 1：**
>
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> **示例 2：**
>
> 输入：nums = [0,1,0,3,2,3]
> 输出：4
> **示例 3：**
>
> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1
>
> **进阶：**
>
> - 你可以设计时间复杂度为 `O(n2)` 的解决方案吗？
> - 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

```python
# 方法一：动态规划，时间复杂度o(n^2)
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        ans = 1
        for i in range(1, len(nums)):
            maxLast = 0
            for j in range (1, i+1):    # 很容易写成 range(1,i)，记住这种 i-j 的情况，需要遍历到i-i=0,因此是range(1,i+1)
                if nums[i] > nums[i-j]:
                    maxLast = max(maxLast, dp[i-j])
            dp[i] = maxLast + 1
            ans = max(ans, dp[i])
        return ans
    
# 方法二：修改状态定义（同时用到了贪心算法、二分查找) todo
# https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
```



### 15.5.2 [646. 最长数对链(Medium)](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/) 

> #### [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)
>
> 难度中等151收藏分享切换为英文接收动态反馈
>
> 给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。
>
> 现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。
>
> 给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。
>
> 
>
> **示例：**
>
> ```
> 输入：[[1,2], [2,3], [3,4]]
> 输出：2
> 解释：最长的数对链是 [1,2] -> [3,4]
> ```

```python
"""
思路1：动态规划，时间复杂度O(n^2)

思路2：动态规划+二分法，时间复杂度O(nlogn)，空间复杂度O(n)O(n)，同样可使用可使用300. 最长上升子序列 的 常规动态规划解法。

思路3：贪心算法，时间复杂度O(nlogn)（主要是sort的时间复杂度为O(nlogn)O(nlogn)，贪心的时间复杂度为O(n)O(n)），空间复
"""
# 思路1：动态规划，时间复杂度O(n^2)
# 与300不一样，组合顺序可以变化，因此应sort，保证输入顺序与解顺序一致
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        dp = [1] * len(pairs)
        pairs.sort() 
        ans = 1
        for i in range(1 ,len(pairs)):
            maxLast = 0
            for j in range(1, i+1):
                if pairs[i][0] > pairs[i-j][1]:
                    maxLast = max(maxLast, dp[i-j])
            dp[i] = maxLast + 1
            ans = max(ans, dp[i])
        return ans
    
# todo O(nlogn)
https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/cdong-tai-gui-hua-er-fen-fa-tan-xin-fa-yi-ti-duo-j/
```



### 15.5.3 [376. 摆动序列(Medium)](https://leetcode-cn.com/problems/wiggle-subsequence/)

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
>
> 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
>
> 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。
>
> **示例 1:**
>
> 输入: [1,7,4,9,2,5]
> 输出: 6 
> 解释: 整个序列均为摆动序列。
> **示例 2:**
>
> 输入: [1,17,5,10,13,15,10,5,16,8]
> 输出: 7
> 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
> **示例 3:**
>
> 输入: [1,2,3,4,5,6,7,8,9]
> 输出: 2
> **进阶:**
> 你能否用 O(n) 时间复杂度完成此题?

![image-20210306205056916](image-20210306205056916.png)

```python
# O(N)：
"""
定义两个变量up：up[i]代表nums[0:i+1]上升摆动序列的长度 。down：down[0:i+1]代表下降摆动序列的长度。
1 nums[i]>nums[i-1]则说明这个摆动序列在上升，此时上升摆动序列长度=下降摆动序列+1（加1是加的nums[i]）
2 nunm[i]<nums[i-1]则说明这个摆动序列在下降，此时下降摆动序列长度=上升摆动序列+1（加1是加的nums[i]）
TODO 总结：1.如何想到用2个变量保存，
			如何看出是线性复杂度，当前状态只依赖上一状态.
        300题最长子序列，要保存每一个状态，需要一个数组dp[]保存所有状态
        本题只需要保存最后一次爬的状态，与最后一次升的状态，用两个变量保存即可。
       2. 什么题型需要两个for？
       需要遍历所有状态的需要两个for
       只需要常数个状态的只用一个for，总体时间复杂度就是O(N)
"""
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        up,down=1,1 #up表示当前最后两个数为上升的最长字串（这个很难想得到啊），一个数时，up=1

        for i in range(1,len(nums)):
            if nums[i]>nums[i-1]:
                up = down+1
            elif nums[i]<nums[i-1]:
                down = up+1
        return max(up,down) if len(nums)!=0 else 0
```



## 15.6 最长公共子序列

### 15.6.1 [1143. 最长公共子序列(Medium)](https://leetcode-cn.com/problems/longest-common-subsequence/) 

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
>
> 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
>
> 若这两个字符串没有公共子序列，则返回 0。
>
> **示例 1:**
>
> 输入：text1 = "abcde", text2 = "ace" 
> 输出：3 
> 解释：最长公共子序列是 "ace"，它的长度为 3。
> **示例 2:**
>
> 输入：text1 = "abc", text2 = "abc"
> 输出：3
> 解释：最长公共子序列是 "abc"，它的长度为 3。
> **示例 3:**
>
> 输入：text1 = "abc", text2 = "def"
> 输出：0
> 解释：两个字符串没有公共子序列，返回 0。

![image-20210307185233802](image-20210307185233802.png)

```python
"""
1.　S{s1,s2,s3....si} T{t1,t2,t3,t4....tj}
2.　子问题划分
(1) 如果S的最后一位等于T的最后一位，则最大子序列就是{s1,s2,s3...si-1}和{t1,t2,t3...tj-1}的最大子序列+1
(2) 如果S的最后一位不等于T的最后一位，那么最大子序列就是
① {s1,s2,s3..si}和 {t1,t2,t3...tj-1} 最大子序列
② {s1,s2,s3...si-1}和{t1,t2,t3....tj} 最大子序列
以上两个自序列的最大值
3.　边界
只剩下{s1}和{t1}，如果相等就返回1，不等就返回0
4.　使用一个表格来存储dp的结果
如果 S[i] == T[j] 则dp[i][j] = dp[i-1][j-1] + 1
否则dp[i][j] = max(dp[i][j-1],dp[i-1][j])


解说2：
第一步，一定要明确 dp 数组的含义。
对于两个字符串的动态规划问题，套路是通用的。

比如说对于字符串 s1 和 s2，它们的长度分别是 m、n，一般来说都要构造一个这样的 DP table：int[][] dp = new int[m+1][n+1]。

这里为什么要加1，原因是你可以不加1，但是不加1你就会用其它限制条件来确保这个index是有效的，而当你加1之后你就不需要去判断只是让索引为0的行和列表示空串。

第二步，定义 base case
我们专门让索引为0的行和列表示空串，dp[0][...] 和 dp[...][0] 都应该初始化为0，这就是base case。


总结： 两个字符串，匹配
1.需要二维dp[][]
2.状态转移公式：
如果 S[i] == T[j] 则dp[i][j] = dp[i-1][j-1] + 1
否则dp[i][j] = max(dp[i][j-1],dp[i-1][j])
"""
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n1 = len(text1)
        n2 = len(text2)

        # dp[i][j]的定义 text1[0:i] 和text[0:j]的最长公共子序列
        # 为什么是n+1？可以兼容 字符串遍历到i=0时需要dp[i-1]的情况不需要额外限制。也可以理解空串的状态用dp[0][xxx]=0 dp[xxx][0]=0表示
        # dp = [[0]*(n2+1)] * (n1+1) # 很坑，如果用*，其实是引用，每一行的都是统一个引用
        dp= [[0]*(n2+1) for i in range(n1+1)]

        # 状态转移公式：dp[i][j] = dp[i-1][j-1]+1 , if str1[i]==str2[j]
        for i in range(1, n1+1):
            for j in range(1, n2+1):
    
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] +1
                else: 
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])             
        
        return dp[n1][n2]
```

### 15.6.2 [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) gzlkl

### 15.6.3 [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/) gzl

## 15.7 0-1背包

> 相关问题
> 「力扣」上的 0-1 背包问题：
>
> 「力扣」第 416 题：分割等和子集（中等）；
> 「力扣」第 474 题：一和零（中等）；
> 「力扣」第 494 题：目标和（中等）；
> 「力扣」第 879 题：盈利计划（困难）；
> 「力扣」上的 完全背包问题：
>
> 「力扣」第 322 题：零钱兑换（中等）；
> 「力扣」第 518 题：零钱兑换 II（中等）；
> 「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）。
> 这里要注意鉴别：「力扣」第 377 题，不是「完全背包」问题。
>
> 参考资料
> 背包问题资料下载，链接：百度云下载，密码：sjop 。
>
> [01背包、完全背包、多重背包](https://blog.csdn.net/wzy_1988/article/details/12260343)



### 15.7.1 [416. 分割等和子集(Medium)](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

> 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素**和相等**。
>
> 注意:
>
> 每个数组中的元素不会超过 100
> 数组的大小不会超过 200
> **示例 1:**
>
> 输入: [1, 5, 11, 5]
>
> 输出: true
>
> 解释: 数组可以分割成 [1, 5, 5] 和 [11].
>
> **示例 2:**
>
> 输入: [1, 2, 3, 5]
>
> 输出: false
>
> 解释: 数组不能分割成两个元素和相等的子集.



```python
# 解释很好：https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/

"""
1.本题与0-1背包的区别，以及如何转化为0-1背包
2. 0-1背包思路：
	1.特点：每个数只能用一次
	2.基本思路：物品一个一个选，容量一点一点增加考虑
	3.具体做法：画一个len行，targe+1列的表格，len是物品个数，target是背包容量。
				len表示表示一个一个物品考虑，target+1多出来的1列，表示容量从0开始。很多时候需要考虑容量为0的数值
3.状态转移：
	dp[i][j]=True/False 的定义：从数组[0,i]中选一些数，能否恰好等于j。
	- 不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；
   - 选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。
状态转移方程：
dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]

4.初始化条件
	- 由于依赖d[i-1]，i 从1开始遍历，因此要初始化d[0]。d[0][0]为Ture, d[0][nums[0]]为True，其他dp[0][j]为False
   - 
"""

# 不压缩空间
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        target = 0
        length = len(nums)
        for num in nums:
            target+=num
        if target%2 ==1 or target == 0 or length<=1:
            return False
        target //= 2
        dp = [[False] * (target+1) for i in range(length)] # 需要有target+1 列，+1一列是需要考虑target为0情况
        
        if nums[0] <= target:	# nums[0] 可能会比总和的一半大，则越界
            dp[0][nums[0]] = True

        for i in range(0, length): 
            dp[i][0] = True # 在状态转移时dp[i-1][j-nums[i]] ，若nums[i]刚好等于j，也就是只需要nums[i]一个数即可满足target， 因此需要把d[i][0]都初始化为True
        
        for i in range(1, length):
            for j in range(0, target+1):
                if j-nums[i]>=0:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]
                else:
                    dp[i][j] = dp[i-1][j]
                
            # 由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作
            if dp[i][target]:
                return True
   
        return dp[length-1][target]

"""
说明：这个技巧很常见、很基础，请一定要掌握。

「0-1 背包问题」常规优化：「状态数组」从二维降到一维，减少空间复杂度。

在「填表格」的时候，当前行只参考了上一行的值，因此状态数组可以只设置 22 行，使用「滚动数组」的技巧「填表格」即可；

实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值。因此，我们可以只开一个一维数组，从后向前依次填表即可。

友情提示：这一点在刚开始学习的时候，可能会觉得很奇怪。理解的办法是：拿题目中的示例，画一个表格，自己模拟一遍程序是如何「填表」的行为，就很清楚为什么状态数组降到 1 行的时候，需要「从后前向」填表。

「从后向前」 写的过程中，一旦 nums[i] <= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是「从前向后」填表所不具备的。
说明：如果对空间优化技巧还有疑惑的朋友，本题解下的精选评论也解释了如何理解这个空间优化的技巧，请大家前往观看。

参考代码 3：只展示了使用一维表格，并且「从后向前」填表格的代码。
""" TODO
public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if ((sum & 1) == 1) {
            return false;
        }

        int target = sum / 2;
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;

        if (nums[0] <= target) {
            dp[nums[0]] = true;
        }
        for (int i = 1; i < len; i++) {
            for (int j = target; nums[i] <= j; j--) {
                if (dp[target]) {
                    return true;
                }
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[target];
    }
}

```



![image-20210307212258926](image-20210307212258926.png)



![image-20210307212206160](image-20210307212206160.png)



### 15.7.2 [494. 目标和(Medium)](https://leetcode-cn.com/problems/target-sum/)

> 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
>
> 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
>
> **示例：**
>
> 输入：nums: [1, 1, 1, 1, 1], S: 3
> 输出：5
> 解释：
>
> -1+1+1+1+1 = 3
> +1-1+1+1+1 = 3
> +1+1-1+1+1 = 3
> +1+1+1-1+1 = 3
> +1+1+1+1-1 = 3
>
> 一共有5种方法让最终目标和为3。
>
>
> 提示：
>
> 数组非空，且长度不会超过 20 。
> 初始的数组的和不会超过 1000 。
> 保证返回的最终结果能被 32 位整数存下。

```python
""" 
1.为什么这是背包问题，背包问题什么特征？
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：

f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放，放与不放影响和
这里虽然不是选不选择的问题，但也是二选一问题，一个选择是+nums[i]一个选择是-nums[i]

2.如何想到该题dp[][]放的是解的个数，动态规划题目一般是问什么存什么。
  定义dp[i][j]： nums[0,i]元素，组合得到j的方法数。
  递推公式：d[i][j] = d[i-1][j-nums[i]] + d[i-1][j+nums[i]]

3.考虑本题不是放不放问题，是加减问题，taget会出现负数，taget范围是 [-sum,sum]，其中sum是num[i]的和。
  又因为数组下标不能为负数，因此数组初始化大小为 2*sum+1, 原dp[i][-sum]变为dp[0]，由此递推公式变为：
  dp[i][j+sum] = d[i-1][j-nums[i]+sum] + d[i-1][j+nums[i]+sum] ,其中j的遍历范围：【-sum,sum】（从0开始遍历不好理解）
  
4. 空间优化
因为d[i][..]只有与d[i-1][...]有关，因此使用d[2][2*sum+1]数组即可
"""

class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        numSum = 0
        length = len(nums)
        for num in nums:
            numSum+=num

        dp=[0]*(2*numSum+1)

        if length==0 or S > numSum: # S 若不在这里判断后面会出现越界，这也是背包问题常常需要处理的
            return 0
        
        # 后面需要dp[i-1]，这里要先初始化dp[0]。
        # 例如：nums[1,1,1],则dp[0][+1+3]要初始化为1，dp[-1+3]要初始化为1。
        #      nums[0,0,1],则dp[0][+0+3]要初始化为1，dp[-0+3]要初始化为1，则覆盖了，因此要累加。
        dp[nums[0]+numSum] += 1
        dp[-nums[0]+numSum] += 1
        print(dp)
        for i in range(1, length):
            temp=[0]*(2*numSum+1)   # dp[i] 只依赖dp[i-1] 只需要一个临时数组保存即可
            for j in range(-numSum, numSum+1):
                if j+nums[i]+numSum<=2*numSum:
                    temp[j+numSum]+=dp[j+nums[i]+numSum]
                if j-nums[i]+numSum >=0:
                    temp[j+numSum]+=dp[j-nums[i]+numSum]
            dp = temp
            print(dp)
        return dp[S+numSum]
"""
再总结吧：
1. 看出是背包问题，特点是：每种物品仅有一件，且有重量（这里就是数字），可以选择放或不放（这里是加或者减），影响背包重量（和）
2. 背包问题一般需要二位数组保存递推状态 dp[i][j]，根据问题定义dp[i][j]
3. 确定递推公式
4. 观察递推公式，需要初始化哪些状态, 例如依赖dp[i-1], 则要初始化dp[0]
5. 先处理异常情况，例如 背包太小，或者和太大等等，否则需要处理数据越界
6. 在递归过程，存在i-nums[i] 等需要判断是否越界
7. 观察递推公式，依赖情况，是否可以压缩空间
"""
```



### 15.7.3 [474. 一和零(Medium)](https://leetcode-cn.com/problems/ones-and-zeroes/) 

> 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
>
> 请你找出并**返回 strs 的最大子集的大小**，该子集中 最多 有 **m 个 0 和 n 个 1** 。
>
> 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。
>
> **示例 1：**
>
> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
> 输出：4
> 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
> 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
> **示例 2：**
>
> 输入：strs = ["10", "0", "1"], m = 1, n = 1
> 输出：2
> 解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
>
> **提示：**
>
> 1 <= strs.length <= 600
> 1 <= strs[i].length <= 100
> strs[i] 仅由 '0' 和 '1' 组成
> 1 <= m, n <= 100

```python
"""
1.首先，为什么看出来是背包问题
2.为什么能想到是dp[i][j][k] 3维矩阵，
状态有三个， [背包对1的容量]、[背包对0的容量]和 [可选择的字符串]；
3.dp[i][j][k]的定义与题目怎样关联起来，找的是最大子集大小，dp也是存的最大子集
4.递推公式还是选与不选当前元素问题
5.为了省去初始化d[0]的情况，dp[0]表示空串，为啥之前题目不用这招
6.当j-zero<0 或 k-one<0, 为什么是可以跳过？这就要跟初始化状态匹配
"""
# 1.不压缩空间的动态规划
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        def countNums(str1: str):
            one=0
            two=0
            for i in range(0, len(str1)):
                if (str1[i] == '1'):
                    one+=1
                else:
                    two+=1
            return one,two

        # 1.为了避免处理i-1，dp[0]定义为选择空串
        # 2. 定义dp[i][0][0] = 0 是必须要的，递推公式dp[i][j-one][k-two]，当 j-one == 0 and k-two==0 时，表示只需选择当前字符串str[i]刚好符合要求j个1，k个0，只需要选择一个字符串，因此需要初始化dp[i][0][0]=0
        dp = [[[0]*(m+1) for _ in range(n+1)] for _ in range(len(strs) +1)] 

        for i in range(1, len(strs)+1):
            for j in range(0,n+1):
                one, two = countNums(strs[i-1])
                for k in range(0, m+1):
                    dp[i][j][k] = dp[i-1][j][k] # 由于dp[i-1][j-one][k-two] 可能越界，则无法执行递推公式，因此现赋值不需要特殊处理的情况
                    if j-one >=0 and k-two>=0:
                        dp[i][j][k]= max(dp[i-1][j][k], dp[i-1][j-one][k-two]+1)

        return dp[-1][-1][-1] # 取最后一个元素的讨巧写法
"""
 2. 空间优化
因为当前行只参考了上一行的值，因此可以使用「滚动数组」，也可以「从后向前赋值」。 
参考代码2：这里选用「从后向前赋值」 
TODO理解不了
为何要倒序访问背包空间？ 因为原状态方程中 dp[i][j][k]=max( dp[i-1][j][k],dp[i-1][j-num0][k-num1]+1 ); ，我们每次更新dp[i][j][k]时，都要借助上一层的dp[i-1][j- zeros][k- ones]。很显然，[j][k]要比[j- zeros][k- ones]大，如果我们顺序访问，则先修改[j- zeros][k- ones]后修改[j][k]。这里思考下，我们修改dp[i][j][k]之前，[j- zeros][k- ones]已经被改过了，那他还是不是dp[i-1][j- zeros][k- ones]呢？ 答案是：否！他已经变成了dp[i][j- zeros][k- ones]，二狗子已经不是当初的那个纯洁的二狗子了。。。。。所以正确做法，需要倒序访问。
倒序访问，dp[i - zeros][j - ones] 这个会不会还没有来得及赋值呀？ 答：不会，已经赋值了。我们每次更新dp[i][j][k]，借助的都是上一层dp[i-1]。也就是说在你进入第i层前，已经在i-1层为他们赋过值了。（就算是i=1,也没问题，因为你已经把i=0那一层全部置为0了）。
"""
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        def countNums(str1: str):
            one=0
            two=0
            for i in range(0, len(str1)):
                if (str1[i] == '1'):
                    one+=1
                else:
                    two+=1
            return one,two

        # 1.为了避免处理i-1，dp[0]定义为选择空串
        # 2. 定义dp[i][0][0] = 0 是必须要的，递推公式dp[i][j-one][k-two]，当 j-one == 0 and k-two==0 时，表示只需选择当前字符串str[i]刚好符合要求j个1，k个0，只需要选择一个字符串，因此需要初始化dp[i][0][0]=0
        dp = [[0]*(m+1) for _ in range(n+1)]

        for i in range(1, len(strs)+1):
            for j in range(0,n+1):               
                one, two = countNums(strs[i-1])
                for k in range(0,m+1):
                    dp[j][k] = dp[j][k] # 由于dp[i-1][j-one][k-two] 可能越界，则无法执行递推公式，因此现赋值不需要特殊处理的情况
                    if j-one >=0 and k-two>=0:
                        dp[j][k]= max(dp[j][k], dp[j-one][k-two]+1)

        return dp[-1][-1] # 取最后一个元素的讨巧写法

```



### 15.7.4 [322. 零钱兑换(Medium)](https://leetcode-cn.com/problems/coin-change/) 

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的**最少的硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 -1。
>
> 你可以认为每种硬币的数量是无限的。
>
> **示例 1：**
>
> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1
> **示例 2：**
>
> 输入：coins = [2], amount = 3
> 输出：-1
> **示例 3：**
>
> 输入：coins = [1], amount = 0
> 输出：0
> **示例 4：**
>
> 输入：coins = [1], amount = 1
> 输出：1
> **示例 5：**
>
> 输入：coins = [1], amount = 2
> 输出：2
>
> **提示：**
>
> 1 <= coins.length <= 12
> 1 <= coins[i] <= 231 - 1
> 0l <= amount <= 104

```python
"""
总结和思路在最后
"""
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:

        length = len(coins)
        dp = [amount+1] * (amount+1)  # 求最少个数，需要初始化不能的值amount。dp[0]有意义，因此初始化amount+1个元素
        dp[0]=0
        
        for i in range(0, length):
            #dp[i][j]=min(dp[i-1][j], dp[i][j-coins[i]]),因此j<coin[i],则dp[i][j]= dp[i-1][j],也即dp[j]=dp[j],可省略，因此j从coins[i]开始遍历
            for j in range(coins[i], amount+1): 
                if j >= coins[i]: # 省略 else j < coins: dp[j] = dp[j]
                    dp[j] = min(dp[j], dp[j-coins[i]]+1)

        if dp[-1] == amount+1: # 若结果没有重新赋值，表示没有解，返回-1
            dp[-1] = -1
        
        return dp[-1]
```



### 15.7.5 [518. 零钱兑换 II(Medium)](https://leetcode-cn.com/problems/coin-change-2/)

> 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币**组合数**。假设每一种面额的硬币有无限个。 
>
> **示例 1:**
>
> 输入: amount = 5, coins = [1, 2, 5]
> 输出: 4
> 解释: 有四种方式可以凑成总金额:
> 5=5
> 5=2+2+1
> 5=2+1+1+1
> 5=1+1+1+1+1
> **示例 2:**
>
> 输入: amount = 3, coins = [2]
> 输出: 0
> 解释: 只用面额2的硬币不能凑成总金额3。
> **示例 3:**
>
> 输入: amount = 10, coins = [10] 
> 输出: 1

```python
# 面试如何说明思路？
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp=[0]*(amount+1)
        dp[0]=1

        for i in range(0 ,len(coins)):
            for j in range(coins[i], amount+1):
                dp[j] += dp[j-coins[i]]

        return dp[-1]
```



### 15.7.6 [139. 单词拆分(Medium)](https://leetcode-cn.com/problems/word-break/)

> 给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
>
> **说明：**
>
> 拆分时可以重复使用字典中的单词。
> 你可以假设字典中没有重复的单词。
> **示例 1：**
>
> 输入: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
> **示例 2：**
>
> 输入: s = "applepenapple", wordDict = ["apple", "pen"]
> 输出: true
> 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
>   注意你可以重复使用字典中的单词。
> **示例 3：**
>
> 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
> 输出: false

```python
"""
leetcode大部分都是  dp[i]=dp[j] && check(s[j..i−1]) 这种解法，并不能归纳到完全背包的解法。
"""
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:       
        n=len(s)
        dp=[False]*(n+1)
        dp[0]=True
        for i in range(n):
            for j in range(i+1,n+1):
                if(dp[i] and (s[i:j] in wordDict)):
                    dp[j]=True
        return dp[-1]

"""
个人倾向这种接法，容易理解，目前看也使用所有完全背包：
	对物品的迭代放到最里层，对背包的迭代放到最外层

定义dp[i]：s[0:i]能由wordlist组成
d[i] = d[i-len(word)] and (wordDict存在word是s[0:i]的结尾)
"""
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        length = len(s)
        dp = [False] * (length +1)
        dp[0] = True

        for i in range(1, length+1):
            for word in wordDict:
                wordLen = len(word)
                if i-wordLen>=0 and s[i-wordLen:i] == word:
                    dp[i] = dp[i] or dp[i-wordLen] # 只要存在一个符合即可，所以是or
        return dp[-1]
```



### 15.7.7 [377. 组合总和 Ⅳ(Medium)](https://leetcode-cn.com/problems/combination-sum-iv/) 0306

> 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
>
> **示例:**
>
> nums = [1, 2, 3]
> target = 4
>
> 所有可能的组合为：
> (1, 1, 1, 1)
> (1, 1, 2)
> (1, 2, 1)
> (1, 3)
> (2, 1, 1)
> (2, 2)
> (3, 1)
>
> 请注意，顺序不同的序列被视作不同的组合。
>
> 因此输出为 7。
> **进阶：**
> 如果给定的数组中含有负数会怎么样？
> 问题会产生什么变化？
> 我们需要在题目中添加什么限制来允许负数的出现？

```python
"""
https://leetcode-cn.com/problems/combination-sum-iv/solution/dong-tai-gui-hua-python-dai-ma-by-liweiwei1419/
* 这里状态定义就是题目要求的，并不难，状态转移方程要动点脑子，也不难：
* 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 >= 0）
* 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案
* 再举一个具体的例子：nums=[1, 3, 4], target=7;
* dp[7] = dp[6] + dp[4] + dp[3]
* 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];
"""
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target+1) # dp[i]定义：由nums中选择若干个数字，和为i的组合个数
        dp[0]=1
    
        for i in range(1, target+1):
            for num in nums:
                if i-num >= 0:
                    dp[i] += dp[i-num]
        return dp[-1]
```



> 总结：
>
> 题型：0-1背包，完全背包
>
> ​	难点：压缩空间的从后往前遍历是什么原理，完全背包又是从前完后：
>
> 思考顺序：
>
> 代码细节：

> 难点：压缩空间的从后往前遍历是什么原理，为什么完全背包又是从0开始：
>
> 优化空间复杂度，这篇文章说的比较好：https://blog.csdn.net/wzy_1988/article/details/12260343
>
> **0-1背包：**
>
> 题目：有N件物品和一个容量为V的背包。第i建物品的费用是weight[i],价值是value[i]。求解将哪些物品装入背包可使价值总和最大。
>
> 首先，0-1背包用二维数组 保存状态是比较好理解的，状态转移方程：
>
> ```python
> for i in [0, N]:
> 	for j in [0, V]:
> 		dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]}
> ```
>
> 
>
> 观察状态转移方程，当前状态 **`d[i][j]`** 只于前一个状态**`dp[i-1][j]`**和**`dp[i-1][j-x]`**相关，可以压缩为一维数组，进入i 层，`dp[j]`仍然保存着 i-1层`d[j]`的值。
>
> 但注意到 **j - weight[i] < j** ，假如 j 从 0开始遍历，到 **`d[j] `**时，**`dp[j-weight]`**已经被覆盖为 i 层的值，**因此 j 要从后开始遍历**，进入 i 层计算**`dp[j]`**时，**`dp[j-weight]`** 仍然保存着 i-1 层的值。因此一维数组的状态转移方程：
>
> ```python
> for i in [0, N]:
> 	for j in [V, 0]:
> 		dp[j] = max{dp[j], dp[j - weight[i]] + value[i]}
> ```
>
> 
>
> **完全背包：**
>
> 一、类比0-1背包，【完全背包】第二层遍历从0开始顺序遍历
>
> 题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是weight[i],价值是value[i].求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
>
> **1. 状态转移方程(二维数组，3层循环)：**
>
> ![image-20210313181520206](image-20210313181520206.png)
>
> 
>
> **2. 转化（二维数组，2层循环）**（具体推到过程很复杂https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/）
>
> ![image-20210313184007814](image-20210313184007814.png)
>
> **3. 空间优化（一维数组，2层循环）**
>
> 0-1背包为了防止 **i-1 层的dp[j-w[i]]** 被 **i 层的dp[j-w[i]] 覆盖掉** ，所以 j 从后行前遍历
>
> 对比【完全背包】与【0-1背包】上面的方程，【完全背包】恰好需要 i 层的dp[j-w[i]]，因此 j 应从 0 开始遍历，那么进入i层计算dp[j]时，d[j-w[i]] 就是 i层的值 
>
> ```python
> for i in [0, N]:
> 	for j in [0, V]:
> 		dp[j] = max{dp[j], dp[j - weight[i]] + value[i]}
> ```
>
> 
>
> **4.不需要这么多层转化，更简单的说法**
>
> 我们记得在优化01背包时，我们为了获取到上一次计算的值，我们选择从后往前计算，但是完全背包`正好相反，这才是它此昂要的`，完全背包因为需要累计多个同一物品的值，前一次计算可能是1个、2个等等，下一次j变化了以后，计算的可能是3个或者更多，所以我们需要保存实时计算出来的多个同一物品的最大价值，我们选取从前往后的顺序，这样每次前面计算的我们都可以在j增大以后累加获得更多个同一物品的最大价值(根据状态转移方程可知，我们计算一个位置的最大价值只需要当前位置的上一次计算的值和当前次循环内更前面的值)
>
> 例如：
>
> 在我们计算第2个物品dp[5]的时候，物品2的体积为2，价值为5，我们需要上一次计算也就是第一个物品的dp[5]的值，还需要dp[5-2]=dp[3]的值，dp[3]我们在本次循环内计算dp[5]之前就已经算过了，dp[3]可能选了一个物品2，也可能没有选，我们计算dp[5]就根据这个dp[3]的大小在进行选取，就可以进行多次选取。
>
> 参考：https://www.dzou.top/post/napzack-algorithm.html
>
> 
>
> 二、对物品的迭代放到最里层，对背包的迭代放到最外层。比较容易理解。
>
> [也就是方法一：动态规划与记忆化递归](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/)
>
> [官方解答的第二种方法：动态规划](https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/)
>
> ```python
> dp[amount] = min(dp[amount], 1 + dp[amount - coins[i]]) for i in [0, len - 1] if coins[i] <= amount
> 
> for (int i = 1; i <= amount; i++) {
>  for (int coin : coins) {
>      if (i - coin >= 0 && dp[i - coin] != amount + 1) {
>          dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
>      }
>  }
> }
> ```

> 简单好记的方法论：https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/
>
> 解题思路
> 常见的背包问题有1、组合问题。2、True、False问题。3、最大最小问题。
> 以下题目整理来自大神CyC，github地址：
> github
> 我在大神整理的基础上，又做了细分的整理。分为三类。
> 1、组合问题：
>
> 377. 组合总和 Ⅳ
> 378. 目标和
> 379. 零钱兑换 II
>      2、True、False问题：
> 380. 单词拆分
> 381. 分割等和子集
>      3、最大最小问题：
> 382. 一和零
> 383. 零钱兑换
>
> 组合问题公式
>
>
> dp[i] += dp[i-num]
> True、False问题公式
>
>
> dp[i] = dp[i] or dp[i-num]
> 最大最小问题公式
>
>
> dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)
> 以上三组公式是解决对应问题的核心公式。
>
> 当然拿到问题后，需要做到以下几个步骤：
> 1.分析是否为背包问题。
> 2.是以上三种背包问题中的哪一种。
> 3.是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。
> 4.如果是组合问题，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。
>
> 接下来讲一下背包问题的判定
> 背包问题具备的特征：给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。
>
> 背包问题技巧：
> 1.如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；
>
>
> for num in nums:
>     for i in range(target, nums-1, -1):
> 2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。
>
>
> for num in nums:
>     for i in range(nums, target+1):
> 3.如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。
>
> for i in range(1, target+1):
>     for num in nums:
> 代码
>
> class Solution:
>     def combinationSum4(self, nums: List[int], target: int) -> int:
>         if not nums:
>             return 0
>         dp = [0] * (target+1)
>         dp[0] = 1
>         for i in range(1,target+1):
>             for num in nums:
>                 if i >= num:
>                     dp[i] += dp[i-num]
>         return dp[target]

##  15.8 股票交易

### 15.8.1 [309. 最佳买卖股票时机含冷冻期(Medium)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

> 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
>
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
> **示例:**
>
> 输入: [1,2,3,0,2]
> 输出: 3 
> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

![image-20210314152039553](image-20210314152039553.png)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if length == 0:
            return 0

        dp = [[0]*3 for _ in range(0,length)]
        dp[0][1] = -prices[0]   # 第0天，持有股票，则必定买入股票，持有现金 -prices[0]

        for i in range(1, length):
            dp[i][0] = max(dp[i-1][0], dp[i-1][2]) # d[i][0]：第i天，不持有股票，握有最大现金数
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])  # d[i][1]：第i天，持有股票，握有最大现金数
            dp[i][2] = dp[i-1][1]+prices[i] # d[i][2]：第i天，冻结买卖，握有最大现金数

        return max(dp[-1][2],dp[-1][0])
    
# 空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if length == 0:
            return 0

        dp = [0, -prices[0], 0]
        for i in range(1, length):
            dp0 = max(dp[0], dp[2])
            dp1 = max(dp[1], dp[0]-prices[i])
            dp2 = dp[1]+prices[i]
            dp[0],dp[1],dp[2] = dp0,dp1,dp2
        return max(dp[2],dp[0])
```



### 15.8.2 [714. 买卖股票的最佳时机含手续费(medium)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

> 给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；非负整数 `fee` 代表了交易股票的手续费用。
>
> 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
>
> 返回获得利润的最大值。
>
> **注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
>
> **示例 1:**
>
> ```
> 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
> 输出: 8
> 解释: 能够达到的最大利润:  
> 在此处买入 prices[0] = 1
> 在此处卖出 prices[3] = 8
> 在此处买入 prices[4] = 4
> 在此处卖出 prices[5] = 9
> 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
> ```

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        length = len(prices)
        if length == 0:
            return 0

        dp = [0, -prices[0]]
        for i in range(1, length):
            dp0 = max(dp[0], dp[1]+prices[i]-fee)
            dp1 = max(dp[1], dp[0]-prices[i])
            dp[0],dp[1] = dp0,dp1
        return dp[0]
```



### 15.8.3 [123. 买卖股票的最佳时机 III(Hard)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

> 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **示例 1:**
>
> 输入：prices = [3,3,5,0,0,3,1,4]
> 输出：6
> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>   随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
> **示例 2：**
>
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
>   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
> **示例 3：**
>
> 输入：prices = [7,6,4,3,1] 
> 输出：0 
> 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
> **示例 4：**
>
> 输入：prices = [1]
> 输出：0

![image-20210314172656937](image-20210314172656937.png)

```python
# 画状态转移图

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if length == 0:
            return 0

        # dp = [[[0]*3]*2 for _ in range(0,length)]  # 这样初始化，不行，存在相同的引用
        dp = [ [[0,0,0],[0,0,0] ]  for _ in range(0,length)]
        dp[0][1][0] = -prices[0]
        dp[0][0][1] = float('-inf')
        dp[0][0][2] = float('-inf')
        dp[0][1][1]=float('-inf')   # 这个初始化很容易漏，如果设置为0，会导致后面计算有误
        dp[0][1][2]=float('-inf')
        for i in range(1, length):
            dp[i][0][1]=max(dp[i-1][0][1], dp[i-1][1][0]+ prices[i])
            dp[i][0][2]=max(dp[i-1][0][2], dp[i-1][1][1]+prices[i])
            dp[i][1][0]=max(dp[i-1][1][0], dp[i-1][0][0]- prices[i])
            dp[i][1][1]=max(dp[i-1][1][1], dp[i-1][0][1]- prices[i])
            dp[i][1][2]=float('-inf')
        return max(dp[-1][0][0],dp[-1][0][1], dp[-1][0][2],0)

#空间优化（使用滚动数组）
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if length == 0:
            return 0

        # dp = [[[0]*3]*2 for _ in range(0,length)]  # 这样初始化，不行，存在相同的引用
        dp = [[0]*k for _ in range(0,length) ]
        dp[1][0] = -prices[0]
        dp[0][1] = float('-inf')
        dp[0][2] = float('-inf')
        dp[1][1]=float('-inf')   # 这个初始化很容易漏，如果设置为0，会导致后面计算有误
        dp[1][2]=float('-inf')
        for i in range(1, length):
            dp[0][1]=max(dp[0][1], dp[1][0]+ prices[i])
            dp[0][2]=max(dp[0][2], dp[1][1]+prices[i])
            dp[1][0]=max(dp[1][0], dp[0][0]- prices[i])
            dp[1][1]=max(dp[1][1], dp[0][1]- prices[i])
            dp[1][2]=float('-inf')
        return max(dp[0][0],dp[0][1], dp[0][2],0)
```



### 15.8.4 [188. 买卖股票的最佳时机 IV(Hard)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/) 

> 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **示例 1：**
>
> 输入：k = 2, prices = [2,4,1]
> 输出：2
> 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
> **示例 2：**
>
> 输入：k = 2, prices = [3,2,6,5,0,3]
> 输出：7
> 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
>   随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

```python
# 参考123题，从交易次数限制为2中，找规律
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        length = len(prices)
        if length == 0:
            return 0

        dp = [[float('-inf')]*(k+1) for _ in range(0,2) ]
        dp[1][0] = -prices[0] # 持有股票，交易0次，持现金-prices[0]
        dp[0][0] = 0 # 没有持有股票，交易0次，现金为0
        ret = 0
        for i in range(1, length):
            for j in range(1,k+1):# j从1开始，不用考虑越界情况。另一方面，dp[0][0]和dp[1][0]是确定值，在前面已经初始化，所以也不用处理j=0的情况。
                dp[0][j]=max(dp[0][j], dp[1][j-1]+ prices[i])
                dp[1][j]=max(dp[1][j], dp[0][j]- prices[i])
                ret = max(ret,dp[0][j])
        return ret
```



## 15.9 字符串编辑

### 15.9.1 [583. 两个字符串的删除操作(Medium)](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。
>
>**示例**：
>
>输入: "sea", "eat"
>输出: 2
>解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

```python
"""
方法一：转化为最长子序列，dp存的是最长子序列长度
转化为 1143题，最长公共子序列
dp[i][j]：字符串s1[0:i] 与字符串 s2[0:j] 的最长公共子序列长度
状态转移方程：
	dp[i][j] = 
		if ==
			dp[i-1][j-1]+1
		else
			max(dp[i-1][j], dp[i][j-1])
"""
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1,len2= len(word1),len(word2)
        dp= [[0]*(len2+1) for _ in range(0,len1+1)] # len2 在里层，len1在外层

        for i in range(1, len1+1):
            for j in range(1, len2+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        return len1 + len2 - 2 * dp[-1][-1]
    
"""
方法二：根据问题，dp存的是最少删除字符数
		方法一dp存的是长度，只需要判断末尾字符，这个比较好理解
		若dp存的是最少删除字符数，为什么也只需要判断末尾字符？
			因为状态d[i][j] 与 前置状态 d[i-1][j-1],d[i-1][j]],dp[i][j-1] 区别只有末尾字符，前置状态已经得到了除末尾字符要删除的最少字符个数，因此只需要判断新增的末尾字符是否相等，不等则删除
"""
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1,len2= len(word1),len(word2)
        if len1==0 or len2==0:
            return len2 if len1==0 else len1
        dp= [[0]*(len2+1) for _ in range(0,len1+1)] # len2 在里层，len1在外层

        for i in range(0, len2+1):
            dp[0][i] = i
        
        for i in range(0, len1+1):
            dp[i][0]= i
        for i in range(1, len1+1):
            for j in range(1, len2+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) +1	# 这里为啥不是删除两个: dp[i-1][j-1]+2 ? ：可能只要删一个，例如：abc，bc
        return dp[-1][-1]
    
#更简洁写法，不用像上题那要，特地初始化 d[0][i] 和 dp[i][0]
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1,len2= len(word1),len(word2)
        if len1==0 or len2==0:
            return len2 if len1==0 else len1
        dp= [[0]*(len2+1) for _ in range(0,len1+1)] # len2 在里层，len1在外层

        for i in range(0, len1+1):
            for j in range(0, len2+1):
                if i==0 or j==0:
                    dp[i][j] = i+j
                elif word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) +1
        return dp[-1][-1]
```



### 15.9.2 [72. 编辑距离(Hard)](https://leetcode-cn.com/problems/edit-distance/)

> 题解：
>
> 我们可以发现，如果我们有单词 A 和单词 B：
>
> 对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；
>
> 同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；
>
> 对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -> c，和修改单词 B 的第一个字母 c -> b 是等价的。
>
> 这样以来，本质不同的操作实际上只有三种：
>
> 在单词 A 中插入一个字符；
>
> 在单词 B 中插入一个字符；
>
> 修改单词 A 的一个字符。
>
> 
>
> dp\[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数
>
> 所以，
>
> 当 word1[i] == word2[j]，dp\[i][j] = dp\[i-1][j-1]；
>
> 当 **word1[i] != word2[j]，dp\[i][j] = min(dp\[i-1][j-1], dp\[i-1][j], dp\[i][j-1]) + 1**
>
> 其中，**dp\[i-1][j-1]** 表示替换操作(因为替换成相同)，**dp\[i-1][j]** 表示删除操作，**dp\[i][j-1]** 表示插入操作。
>
> 注意，针对第一行，第一列要单独考虑，我们引入 '' 下图所示：
>
> ![image-20210314213107540](image-20210314213107540.png)
>
> 第一行，是 word1 为空变成 word2 最少步数，就是插入操作
>
> 第一列，是 word2 为空，需要的最少步数，就是删除操

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1,len2= len(word1),len(word2)
        if len1==0 or len2==0:
            return len2 if len1==0 else len1
        dp= [[0]*(len2+1) for _ in range(0,len1+1)] # len2 在里层，len1在外层

        for i in range(0, len2+1):
            dp[0][i] = i
        
        for i in range(0, len1+1):
            dp[i][0]= i
        for i in range(1, len1+1):
            for j in range(1, len2+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1],dp[i-1][j-1]) +1	# 这里为啥不是删除两个: dp[i-1][j-1]+2 ? ：可能只要删一个，例如：abc，bc
        return dp[-1][-1]

```



### 15.9.3 [650. 只有两个键的键盘(Medium) TODO 中高频，难想](https://leetcode-cn.com/problems/2-keys-keyboard/)

> 最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：
>
> Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
> Paste (粘贴) : 你可以粘贴你上一次复制的字符。
> 给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。
>
> **示例 1:**
>
> 输入: 3
> 输出: 3
> 解释:
> 最初, 我们只有一个字符 'A'。
> 第 1 步, 我们使用 Copy All 操作。
> 第 2 步, 我们使用 Paste 操作来获得 'AA'。
> 第 3 步, 我们使用 Paste 操作来获得 'AAA'。



### 15.9.4 [10.正则表达式匹配(Hard)](https://leetcode-cn.com/problems/regular-expression-matching/) 0321

![image-20210321160953350](image-20210321160953350.png)

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        lenS, lenP = len(s), len(p)
        dp = [ [False] * (lenP+1) for _ in range(lenS+1)]

        # base case
        dp[0][0] = True
        for j in range(1, lenP+1):  # 先初始化，在后面迭代无需判断i>=1
            if p[j - 1] == '*':
                 dp[0][j] = dp[0][j - 2];

        for i in range(1, lenS+1):
            for j in range(1, lenP+1):
                if s[i-1] == p[j-1] or p[j-1]=='.':
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == '*':  
                    # 由于默认P输入合法, *前面必须有元素，则当p[j-1] =='*', 必定有P>=2，因此该分支无需判断j>=2 
                    if p[j-2] == s[i-1] or p[j-2] == '.':
                            dp[i][j] = dp[i-1][j] or dp[i-1][j-2] or dp[i][j-2]
                    else:
                        dp[i][j] = dp[i][j-2]
        return dp[-1][-1]
```



### 15.9.5 [44. 通配符匹配(Hard)](https://leetcode-cn.com/problems/wildcard-matching/)0307 0321done

```python
# 参考10题
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        lenS, lenP = len(s), len(p)
        dp = [ [False] * (lenP+1) for _ in range(lenS+1)]

        # base case
        dp[0][0] = True
        for j in range(1, lenP+1):  # 先初始化，在后面迭代无需判断i>=1
            if p[j - 1] == '*':
                 dp[0][j] = dp[0][j - 1];

        for i in range(1, lenS+1):
            for j in range(1, lenP+1):
                if s[i-1] == p[j-1] or p[j-1]=='?':
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == '*':  
                    dp[i][j] = dp[i-1][j] or dp[i-1][j-1] or dp[i][j-1]
        return dp[-1][-1]
```



## 15.10 括号问题

### 15.10.0  5.5 [20. 有效的括号(Easy)]

### 15.10.1 [22.括号生成(Medium)](https://leetcode-cn.com/problems/generate-parentheses/) 

>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
>**示例 1：**
>
>输入：n = 3
>输出：["((()))","(()())","(())()","()(())","()()()"]
>**示例 2：**
>
>输入：n = 1
>输出：["()"]
>
>**提示：**
>
>1 <= n <= 8

![img](https://pic.leetcode-cn.com/7ec04f84e936e95782aba26c4663c5fe7aaf94a2a80986a97d81574467b0c513-LeetCode%20%E7%AC%AC%2022%20%E9%A2%98%EF%BC%9A%E2%80%9C%E6%8B%AC%E5%8F%B7%E7%94%9F%E5%87%BA%E2%80%9D%E9%A2%98%E8%A7%A3%E9%85%8D%E5%9B%BE.png)

```python
# 方法一：回溯法
from typing import List
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        res = []
        cur_str = ''

        def dfs(cur_str, left, right):
            """
            :param cur_str: 从根结点到叶子结点的路径字符串
            :param left: 左括号还可以使用的个数
            :param right: 右括号还可以使用的个数
            :return:
            """
            if left == 0 and right == 0:
                res.append(cur_str)
                return
            if right < left:
                return
            if left > 0:
                dfs(cur_str + '(', left - 1, right)
            if right > 0:
                dfs(cur_str + ')', left, right - 1)

        dfs(cur_str, n, n)
        return res

# 方法二：按括号序列的长度递归，找规律 -> 动态规划，很难理解，暂时放弃
class Solution:
    @lru_cache(None)
    def generateParenthesis(self, n: int) -> List[str]:
        if n == 0:
            return ['']
        ans = []
        for c in range(n):
            for left in self.generateParenthesis(c):
                for right in self.generateParenthesis(n-1-c):
                    ans.append('({}){}'.format(left, right))
        return ans
```

### 15.10.2 [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

# 16. 数学

## 16.1 素数分解

> **质数分解**
>
> **整除**
>
> **最大公约数最小公倍数**

###  16.1.1 [204. 计数质数(Easy)](https://leetcode-cn.com/problems/count-primes/)

> 统计所有小于非负整数 n 的质数的数量。
>
> **示例 1：**
>
> 输入：n = 10
> 输出：4
> 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
> **示例 2：**
>
> 输入：n = 0
> 输出：0
> **示例 3：**
>
> 输入：n = 1
> 输出：0

```python
#最容易理解的方法：440ms
class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 2: # 1 不是质数
            return 0

        isPrime = [True] * n
        isPrime[0]=isPrime[1]=0

        for i in range(2, n):
            if isPrime[i] is False:
                continue
            for k in range (i*i, n, i):
                isPrime[k] = False
        return sum(isPrime)

    
# 埃式筛：要得到自然数n以内的全部质数，必须把“不大于根号n”的所有质数的倍数剔除，剩下的就是质数。316ms
class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 2: # 1 不是质数
            return 0

        isPrime = [True] * n
        isPrime[0]=isPrime[1]=0

        for i in range(2, int(n**0.5)+1): # 只需要遍历到 根号n
            if isPrime[i]:
                for k in range (i*i, n, i):
                    isPrime[k] = False
        return sum(isPrime)
 

# 第二层for循环使用一个等式替换，python语法糖    112ms
class Solution:
    def countPrimes(self, n: int) -> int:
        """
        求n以内的所有质数个数（纯python代码）
        """
        # 最小的质数是 2
        if n < 2:
            return 0

        isPrime = [1] * n
        isPrime[0] = isPrime[1] = 0   # 0和1不是质数，先排除掉

        # 埃式筛，把不大于根号 n 的所有质数的倍数剔除
        for i in range(2, int(n ** 0.5) + 1):
            if isPrime[i]:
                isPrime[i * i:n:i] = [0] * ((n - 1 - i * i) // i + 1)

        return sum(isPrime)
```



### 16.1.2 最大公约数（貌似不考）

### 16.1.3 使用位操作和减法求解最大公约数 [编程之美2.7（貌似不考）]()



## 16.2 进制转换

### 16.2.1 [504. 七进制数(Easy)](https://leetcode-cn.com/problems/base-7/)

> 给定一个整数，将其转化为7进制，并以字符串形式输出。
>
> **示例 1:**
>
> ```
> 输入: 100
> 输出: "202"
> ```
>
> **示例 2:**
>
> ```
> 输入: -7
> 输出: "-10"
> ```

```python
class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return "0"
        sign = '-' if num < 0 else ''
        ans = []
        num = abs(num)
        while num > 0 :
            ans.append(str(num % 7))
            num = num//7
        return sign+ "".join(ans[::-1])
```

### 16.2.2 [405. 数字转换为十六进制数(Easy)](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

```python
# 先忽略吧，不懂
```



### 16.2.3 [168. Excel表列名称(Easy)](https://leetcode-cn.com/problems/excel-sheet-column-title/) 0308

```python
class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        ans = []

        while columnNumber > 0 :
            c = columnNumber % 26
            if c == 0:
                c = 26
                columnNumber-=1
            ans.append(chr( c -1 + ord('A')))
            columnNumber = columnNumber//26
            
        return "".join(ans[::-1])
```



## 16.3 阶乘

### 16.3.1 [172. 阶乘后的零(Easy)](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

>给定一个整数 n，返回 n! 结果尾数中零的数量。
>
>**示例 1:**
>
>输入: 3
>输出: 0
>解释: 3! = 6, 尾数中没有零。
>
>**示例 2:**
>
>输入: 5
>输出: 1
>解释: 5! = 120, 尾数中有 1 个零.
>
>**说明:** 你算法的时间复杂度应为 O(log n) 。

![image-20210321230056811](image-20210321230056811.png)

```python
class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
        while n > 0:
            count+=n//5
            n//=5
        return count
```



## 16.4 字符串加法减法

### 16.4.1 [67. 二进制求和(Easy)](https://leetcode-cn.com/problems/add-binary/)

> 给你两个二进制字符串，返回它们的和（用二进制表示）。
>
> 输入为 非空 字符串且只包含数字 1 和 0。
>
> **示例 1:**
>
> 输入: a = "11", b = "1"
> 输出: "100"
> **示例 2:**
>
> 输入: a = "1010", b = "1011"
> 输出: "10101"
>
>
> 提示：
>
> 每个字符串仅由字符 '0' 或 '1' 组成。
> 1 <= a.length, b.length <= 10^4
> 字符串如果不是 "0" ，就都不含前导零。

```python
"""
1. 左边补齐0
2.逆序遍历，相加并加上carry等于sum
3.字符串ans 加上 sum%2
4.记录进位carry=sum//2
5.最后若carry=1要加到ans最左边
"""
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        ans, carry = '', 0
        diff = len(b) - len(a)
        a = '0' * diff + a # n小于0值被视为0
        b = '0' * -diff + b
        for i, j in zip(a[::-1], b[::-1]):
            sum = int(i) + int(j) + carry
            ans = str(sum % 2) + ans
            carry = sum // 2
        return '1' + ans if carry else ans
```



### 16.4.2 [415. 字符串相加(Easy)](https://leetcode-cn.com/problems/add-strings/)

> 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
>
> **提示：**
>
> num1 和num2 的长度都小于 5100
> num1 和num2 都只包含数字 0-9
> num1 和num2 都不包含任何前导零
> 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        ans, carry = '', 0
        diff = len(num2) - len(num1)
        num1 = '0' * diff + num1 # n小于0值被视为0
        num2 = '0' * -diff + num2

        for i, j in zip(num1[::-1], num2[::-1]):
            sum = int(i) + int(j) + carry
            ans = str(sum % 10) + ans
            carry = sum // 10
        return '1' + ans if carry else ans
```



## 16.5 相遇问题

### 16.5.1 [462. 最少移动次数使数组元素相等 II(Medium)](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)

> 给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。
>
> **例如:**
>
> 输入:
> [1,2,3]
>
> 输出:
> 2
>
> **说明：**
> 只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 
>
> [1,2,3]  =>  [2,2,3]  =>  [2,2,2]

![image-20210322221823846](image-20210322221823846.png)

```python
# 从上图推导就是获取中位数，在计算每个数与中位数差值之和。二分排序获取中位数，快排获取第N大数时间复杂度 O(N)
public class Solution {
    public void swap(int[] list, int i, int pivot_index) {
        int temp = list[i];
        list[i] = list[pivot_index];
        list[pivot_index] = temp;
    }
    public int partition(int[] list, int left, int right) {
        int pivotValue = list[right];
        int i = left;
        for (int j = left; j <= right; j++) {
            if (list[j] < pivotValue) {
                swap(list, i, j);
                i++;
            }
        }
        swap(list, right, i);
        return i;
    }
    int select(int[] list, int left, int right, int k) {
        if (left == right) {
            return list[left];
        }
        int pivotIndex = partition(list, left, right);
        if (k == pivotIndex) {
            return list[k];
        } else if (k < pivotIndex) {
            return select(list, left, pivotIndex - 1, k);
        } else {
            return select(list, pivotIndex + 1, right, k);
        }
    }
    public int minMoves2(int[] nums) {
        int sum = 0;
        int median = select(nums, 0, nums.length - 1, nums.length / 2);

        for (int num : nums) {
            sum += Math.abs(median - num);
        }
        return sum;
    }
}
```



## 16.6 多数投票问题

### 16.6.1 [169. 多数元素(Easy)](https://leetcode-cn.com/problems/majority-element/) 0309 

> 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>
> **示例 1：**
>
> 输入：[3,2,3]
> 输出：3
> **示例 2：**
>
> 输入：[2,2,1,1,1,2,2]
> 输出：2

```python
# 跟462一样，找中位数
```



## 16.7 其他

### 16.7.1 [367. 有效的完全平方数(Easy)](https://leetcode-cn.com/problems/valid-perfect-square/)

> 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
>
> 进阶：不要 使用任何内置的库函数，如  sqrt 。
>
> **示例 1：**
>
> 输入：num = 16
> 输出：true
> **示例 2：**
>
> 输入：num = 14
> 输出：false

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        # 1,4,9,16,25
        # diff: 3,5,7,9
        cur = 0
        i = 0
        while num > cur:
            cur += 2*i+1
            i+=1
            if num == cur:
                return True
        return False
```



### 16.7.2 [326. 3的幂(Easy)(放弃，难记，频率低)](https://leetcode-cn.com/problems/power-of-three/)

> 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
>
> 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x
>
> **示例 1：**
>
> 输入：n = 27
> 输出：true
> **示例 2：**
>
> 输入：n = 0
> 输出：false
> **示例 3：**
>
> 输入：n = 9
> 输出：true
> **示例 4：**
>
> 输入：n = 45
> 输出：false

```python
# 1,8,27,64,75
# 7,19,37
```



### 16.7.3 [238. 除自身以外数组的乘积(Medium)](https://leetcode-cn.com/problems/product-of-array-except-self/)

> 给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
>
> **示例:**
>
> 输入: [1,2,3,4]
> 输出: [24,12,8,6]
>
>
> 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
>
> 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
>
> 进阶：
> 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

![238.png](https://pic.leetcode-cn.com/807c3f55d54e797c8603bb24e18390cf7bf42f152ed021d5f961cdc13c40ae15-238.png)

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        length = len(nums)
        answer = [0]*length
        
        # answer[i] 表示索引 i 左侧所有元素的乘积
        # 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
        answer[0] = 1
        for i in range(1, length):
            answer[i] = nums[i - 1] * answer[i - 1]
        
        # R 为右侧所有元素的乘积
        # 刚开始右边没有元素，所以 R = 1
        R = 1;
        for i in reversed(range(length)):
            # 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
            answer[i] = answer[i] * R
            # R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
            R *= nums[i]
        
        return answer
```



### 16.7.4 [628. 三个数的最大乘积(Easy)](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)

> 给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。
>
> **示例 1：**
>
> 输入：nums = [1,2,3]
> 输出：6
> **示例 2：**
>
> 输入：nums = [1,2,3,4]
> 输出：24
> **示例 3：**
>
> 输入：nums = [-1,-2,-3]
> 输出：-6

```python
# 排序，取最大的3个数，或者 最小两个数（可能是两个负数)与最大一个数 中较大值
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1]);
    }
};
```

### 16.7.5 [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/) gzl

### 16.7.6 [202. 快乐数](https://leetcode-cn.com/problems/happy-number/) gzl

### 16.7.7 [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/) gzl

### 16.7.8 [263. 丑数](https://leetcode-cn.com/problems/ugly-number/) gzlkl

### 16.7.9 [365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)  gzl





## 16.13 [8.字符串转换整数 (atoi)(Medium)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

```python

```



## 16.13 [13. 罗马数字转整数(Easy)](https://leetcode-cn.com/problems/roman-to-integer/) 0310 0323

```python

```


# 17. 设计数据结构

## 17.1 [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/) gzl

## 17.2 [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/) gzl

## 17.3 [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) gzl



# 18. 多线程

## 18.1 [1114. 按序打印](https://leetcode-cn.com/problems/print-in-order/) gzl

## 18.2 [1116. 打印零与奇偶数](https://leetcode-cn.com/problems/print-zero-even-odd/)gzl



# 19. 字节Hard

#### [1259. 不相交的握手](https://leetcode-cn.com/problems/handshakes-that-dont-cross/) 卡特兰数

#### [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

#### [30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)

#### [681. 最近时刻](https://leetcode-cn.com/problems/next-closest-time/)

#### [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

#### [726. 原子的数量](https://leetcode-cn.com/problems/number-of-atoms/)  看懂了没有写

#### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)  很牛逼

#### [460. LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)

#### [1172. 餐盘栈](https://leetcode-cn.com/problems/dinner-plate-stacks/)

#### [465. 最优账单平衡](https://leetcode-cn.com/problems/optimal-account-balancing/) dfs

#### [407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)  Python默认是最小堆

#### [786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)  与378很像

#### [1274. 矩形内船只的数目](https://leetcode-cn.com/problems/number-of-ships-in-a-rectangle/)

#### [1012. 至少有 1 位重复的数字](https://leetcode-cn.com/problems/numbers-with-repeated-digits/)  数学问题，排列组合

#### [317. 离建筑物最近的距离](https://leetcode-cn.com/problems/shortest-distance-from-all-buildings/)  BFS

#### [862. 和至少为 K 的最短子数组](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/)  超时
